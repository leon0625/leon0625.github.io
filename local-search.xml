<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ss命令查看socket上包的占用内存</title>
    <link href="/2024/01/04/ss%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8Bsocket%E4%B8%8A%E5%8C%85%E7%9A%84%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98/"/>
    <url>/2024/01/04/ss%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8Bsocket%E4%B8%8A%E5%8C%85%E7%9A%84%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="统计socket接收发送队列上的数据长度"><a href="#统计socket接收发送队列上的数据长度" class="headerlink" title="统计socket接收发送队列上的数据长度"></a>统计socket接收发送队列上的数据长度</h1><p>一般情况下使用只会显示接收发送队列的包数</p><figure class="highlight apache"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># ./ss -ntp</span><br><span class="hljs-attribute">State</span>      Recv-Q Send-Q  Local Address:Port    Peer Address:Port Process                             <br><span class="hljs-attribute">ESTAB</span>      <span class="hljs-number">0</span>      <span class="hljs-number">0</span>      <span class="hljs-number">192.168.66.252:54130</span> <span class="hljs-number">14.116.220.228:443</span>   users:((<span class="hljs-string">&quot;tycfs&quot;</span>,pid=<span class="hljs-number">10271</span>,fd=<span class="hljs-number">8</span>))   <br><span class="hljs-attribute">ESTAB</span>      <span class="hljs-number">0</span>      <span class="hljs-number">572</span>    <span class="hljs-number">192.168.66.252:35838</span>   <span class="hljs-number">113.249.86.3:443</span>   users:((<span class="hljs-string">&quot;tycfs&quot;</span>,pid=<span class="hljs-number">10271</span>,fd=<span class="hljs-number">15</span>))  <br><span class="hljs-attribute">ESTAB</span>      <span class="hljs-number">0</span>      <span class="hljs-number">572</span>    <span class="hljs-number">192.168.66.252:35832</span>   <span class="hljs-number">113.249.86.3:443</span>   users:((<span class="hljs-string">&quot;tycfs&quot;</span>,pid=<span class="hljs-number">10271</span>,fd=<span class="hljs-number">21</span>))  <br><span class="hljs-attribute">CLOSE</span>-WAIT <span class="hljs-number">25</span>     <span class="hljs-number">0</span>      <span class="hljs-number">192.168.66.252:55502</span>  <span class="hljs-number">14.18.110.142:443</span>   users:((<span class="hljs-string">&quot;tycfs&quot;</span>,pid=<span class="hljs-number">10282</span>,fd=<span class="hljs-number">14</span>))  <br><span class="hljs-attribute">ESTAB</span>      <span class="hljs-number">0</span>      <span class="hljs-number">0</span>      <span class="hljs-number">192.168.66.252:56252</span>  <span class="hljs-number">14.18.110.142:443</span>   users:((<span class="hljs-string">&quot;tycfs&quot;</span>,pid=<span class="hljs-number">10271</span>,fd=<span class="hljs-number">25</span>))  <br><span class="hljs-attribute">ESTAB</span>      <span class="hljs-number">0</span>      <span class="hljs-number">77</span>        <span class="hljs-number">192.168.6.1:445</span>      <span class="hljs-number">192.168.6.2:49213</span> users:((<span class="hljs-string">&quot;smbd&quot;</span>,pid=<span class="hljs-number">10839</span>,fd=<span class="hljs-number">47</span>))   <br><span class="hljs-attribute">ESTAB</span>      <span class="hljs-number">82690</span>  <span class="hljs-number">0</span>      <span class="hljs-number">192.168.66.252:35804</span>   <span class="hljs-number">113.249.86.3:443</span>   users:((<span class="hljs-string">&quot;tycfs&quot;</span>,pid=<span class="hljs-number">10271</span>,fd=<span class="hljs-number">24</span>))  <br><span class="hljs-attribute">CLOSE</span>-WAIT <span class="hljs-number">25</span>     <span class="hljs-number">0</span>      <span class="hljs-number">192.168.66.252:55542</span>  <span class="hljs-number">14.18.110.142:443</span>   users:((<span class="hljs-string">&quot;tycfs&quot;</span>,pid=<span class="hljs-number">10282</span>,fd=<span class="hljs-number">15</span>))  <br></code></pre></td></tr></table></figure><p>统计内存信息需要<code>-m</code>参数，但可能开了-m参数还是没有，这时需要打开内核宏</p><p>内核打开宏：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">CONFIG_INET_DIAG</span>=y<br><span class="hljs-attribute">CONFIG_INET_TCP_DIAG</span>=y<br>CONFIG_INET_UDP_DIAG<br></code></pre></td></tr></table></figure><p>这时输出如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># ./ss -ntpm</span><br><span class="hljs-attribute">State</span>      Recv-Q Send-Q  Local Address:Port    Peer Address:Port Process                                                                                           <br><span class="hljs-attribute">ESTAB</span>      <span class="hljs-number">0</span>      <span class="hljs-number">570</span>    <span class="hljs-number">192.168.66.252:35980</span>   <span class="hljs-number">113.249.86.3:443</span>   users:((<span class="hljs-string">&quot;tycfs&quot;</span>,pid=<span class="hljs-number">10271</span>,fd=<span class="hljs-number">14</span>))<br>         <span class="hljs-attribute">skmem</span>:(r0,rb1492008,t0,tb48640,f194176,w2432,o0,bl0,d0)      <br><span class="hljs-attribute">ESTAB</span>      <span class="hljs-number">0</span>      <span class="hljs-number">570</span>    <span class="hljs-number">192.168.66.252:35998</span>   <span class="hljs-number">113.249.86.3:443</span>   users:((<span class="hljs-string">&quot;tycfs&quot;</span>,pid=<span class="hljs-number">10271</span>,fd=<span class="hljs-number">16</span>))<br>         <span class="hljs-attribute">skmem</span>:(r0,rb1737680,t0,tb48640,f140928,w2432,o0,bl0,d0)      <br><span class="hljs-attribute">ESTAB</span>      <span class="hljs-number">0</span>      <span class="hljs-number">0</span>      <span class="hljs-number">192.168.66.252:54130</span> <span class="hljs-number">14.116.220.228:443</span>   users:((<span class="hljs-string">&quot;tycfs&quot;</span>,pid=<span class="hljs-number">10271</span>,fd=<span class="hljs-number">8</span>))<br>         <span class="hljs-attribute">skmem</span>:(r0,rb1946944,t0,tb48640,f0,w0,o0,bl0,d1)               <br><span class="hljs-attribute">ESTAB</span>      <span class="hljs-number">65652</span>  <span class="hljs-number">0</span>      <span class="hljs-number">192.168.66.252:35996</span>   <span class="hljs-number">113.249.86.3:443</span>   users:((<span class="hljs-string">&quot;tycfs&quot;</span>,pid=<span class="hljs-number">10271</span>,fd=<span class="hljs-number">13</span>))<br>         <span class="hljs-attribute">skmem</span>:(r111360,rb1408120,t0,tb48640,f32000,w0,o0,bl0,d0)     <br></code></pre></td></tr></table></figure><p>主要看r，t这两个就够了，r表示接收的包，t表示发送的包。</p><p>fwd_alloc（接收缓存），wmem_queued（发送缓存）。这两个字段没有实际意义，查了下资料，它只表明一个额度，一个水线。并不真正会占用内存。</p><h1 id="统计总共占用内存"><a href="#统计总共占用内存" class="headerlink" title="统计总共占用内存"></a>统计总共占用内存</h1><p><strong>接收缓冲占用总内存</strong>（单位KB）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./ss -napm | awk -F <span class="hljs-string">&#x27;[\(|,]&#x27;</span> <span class="hljs-string">&#x27;/skmem/ &#123;print $2&#125;&#x27;</span> | <span class="hljs-built_in">cut</span> -c 2- | awk <span class="hljs-string">&#x27;&#123;a+=$1&#125;END&#123;print a/1024&#125;&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>发送缓冲占用总内存</strong>（单位KB）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/ss -napm | awk -F <span class="hljs-string">&#x27;[\(|,]&#x27;</span> <span class="hljs-string">&#x27;/skmem/ &#123;print $4&#125;&#x27;</span> | <span class="hljs-built_in">cut</span> -c 2- | awk <span class="hljs-string">&#x27;&#123;a+=$1&#125;END&#123;print a/1024&#125;&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="其他内存信息含义"><a href="#其他内存信息含义" class="headerlink" title="其他内存信息含义"></a>其他内存信息含义</h1><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs vim">-<span class="hljs-keyword">m</span>, --memory<br>              Show socket memory usage. The output format <span class="hljs-keyword">is</span>:<br><br>              skmem:(r<span class="hljs-symbol">&lt;rmem_alloc&gt;</span>,rb<span class="hljs-symbol">&lt;rcv_buf&gt;</span>,t<span class="hljs-symbol">&lt;wmem_alloc&gt;</span>,tb<span class="hljs-symbol">&lt;snd_buf&gt;</span>,<br>                            <span class="hljs-keyword">f</span><span class="hljs-symbol">&lt;fwd_alloc&gt;</span>,<span class="hljs-keyword">w</span><span class="hljs-symbol">&lt;wmem_queued&gt;</span>,<span class="hljs-keyword">o</span><span class="hljs-symbol">&lt;opt_mem&gt;</span>,<br>                            <span class="hljs-keyword">bl</span><span class="hljs-symbol">&lt;back_log&gt;</span>,d<span class="hljs-symbol">&lt;sock_drop&gt;</span>)<br>             <span class="hljs-symbol">&lt;rmem_alloc&gt;</span><br>                     the memory allocated <span class="hljs-keyword">for</span> receiving packet<br><br>              <span class="hljs-symbol">&lt;rcv_buf&gt;</span><br>                     the total memory can <span class="hljs-keyword">be</span> allocated <span class="hljs-keyword">for</span> receiving packet<br><br>              <span class="hljs-symbol">&lt;wmem_alloc&gt;</span><br>                     the memory used <span class="hljs-keyword">for</span> sending packet (which <span class="hljs-built_in">has</span> been sent <span class="hljs-keyword">to</span> layer <span class="hljs-number">3</span>)<br><br>              <span class="hljs-symbol">&lt;snd_buf&gt;</span><br>                     the total memory can <span class="hljs-keyword">be</span> allocated <span class="hljs-keyword">for</span> sending packet<br><br>              <span class="hljs-symbol">&lt;fwd_alloc&gt;</span><br>                     the memory allocated by the socket <span class="hljs-keyword">as</span> cache, but not used <span class="hljs-keyword">for</span> receiving/sending packet yet. If need memory <span class="hljs-keyword">to</span> send/receive packet, the mem‐<br>                     ory in this cache will <span class="hljs-keyword">be</span> used before allocate additional memory.<br><br>              <span class="hljs-symbol">&lt;wmem_queued&gt;</span><br>                     The memory allocated <span class="hljs-keyword">for</span> sending packet (which <span class="hljs-built_in">has</span> not been sent <span class="hljs-keyword">to</span> layer <span class="hljs-number">3</span>)<br><br>              <span class="hljs-symbol">&lt;ropt_mem&gt;</span><br>                     The memory used <span class="hljs-keyword">for</span> storing socket option, <span class="hljs-keyword">e</span>.g., the key <span class="hljs-keyword">for</span> TCP MD5 signature<br><br>              <span class="hljs-symbol">&lt;back_log&gt;</span><br>                     The memory used <span class="hljs-keyword">for</span> the sk backlog queue. On <span class="hljs-keyword">a</span> process context, <span class="hljs-keyword">if</span> the process <span class="hljs-keyword">is</span> receiving packet, <span class="hljs-built_in">and</span> <span class="hljs-keyword">a</span> <span class="hljs-keyword">new</span> packet <span class="hljs-keyword">is</span> received,  it  will<br>                     <span class="hljs-keyword">be</span> <span class="hljs-keyword">put</span> into the sk backlog queue, <span class="hljs-keyword">so</span> it can <span class="hljs-keyword">be</span> received by the process immediately<br><br>              <span class="hljs-symbol">&lt;sock_drop&gt;</span><br>                     the <span class="hljs-keyword">number</span> of packets dropped before they are de-multiplexed into the socket            <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>flock使用体会</title>
    <link href="/2023/12/29/flock%E4%BD%BF%E7%94%A8%E4%BD%93%E4%BC%9A/"/>
    <url>/2023/12/29/flock%E4%BD%BF%E7%94%A8%E4%BD%93%E4%BC%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>它的API很简单，如下</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/file.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">flock</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> operation)</span>;<br></code></pre></td></tr></table></figure><p>operation可指定：</p><ul><li>LOCK_SH：设置共享（读）锁</li><li>LOCK_EX：设置独占（写）锁</li><li>LOCK_UN：解锁</li></ul><p>它是建议锁。需要所有使用该文件的人都遵循规矩先flock上锁再使用文件才有效。</p><p>它是一个系统调用，在内核<code>fs/locks.c</code>中实现。</p><h1 id="实现本质"><a href="#实现本质" class="headerlink" title="实现本质"></a>实现本质</h1><p>每个打开的文件都对应有fd—file结构—inode结构三种数据结构。fd和file结构是进程自己独有的，inode是文件系统层面，所有进程共享。<br>flock在inode上记录了加锁的file结构信息，组成一个链表。通过比较file结构，判断是否需要锁定。<br>所以它的特性很多和文件相关。关键函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">flock_lock_inode</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file_lock *request)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_lock</span> *<span class="hljs-title">new_fl</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_lock</span> *<span class="hljs-title">fl</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_lock_context</span> *<span class="hljs-title">ctx</span>;</span><br><span class="hljs-type">int</span> error = <span class="hljs-number">0</span>;<br><span class="hljs-type">bool</span> found = <span class="hljs-literal">false</span>;<br>LIST_HEAD(dispose);<br><br><span class="hljs-comment">// 获取inode上的lock信息</span><br>ctx = locks_get_lock_context(inode, request-&gt;fl_type);<br><span class="hljs-keyword">if</span> (!ctx) &#123;<br><span class="hljs-keyword">if</span> (request-&gt;fl_type != F_UNLCK)<br><span class="hljs-keyword">return</span> -ENOMEM;<br><span class="hljs-keyword">return</span> (request-&gt;fl_flags &amp; FL_EXISTS) ? -ENOENT : <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (!(request-&gt;fl_flags &amp; FL_ACCESS) &amp;&amp; (request-&gt;fl_type != F_UNLCK)) &#123;<br>new_fl = locks_alloc_lock();<br><span class="hljs-keyword">if</span> (!new_fl)<br><span class="hljs-keyword">return</span> -ENOMEM;<br>&#125;<br><br>percpu_down_read_preempt_disable(&amp;file_rwsem);<br>spin_lock(&amp;ctx-&gt;flc_lock);<br><span class="hljs-keyword">if</span> (request-&gt;fl_flags &amp; FL_ACCESS)<br><span class="hljs-keyword">goto</span> find_conflict;<br><br><span class="hljs-comment">// 遍历inode上的锁</span><br>list_for_each_entry(fl, &amp;ctx-&gt;flc_flock, fl_list) &#123;<br><span class="hljs-comment">// file指针比较</span><br><span class="hljs-keyword">if</span> (request-&gt;fl_file != fl-&gt;fl_file)<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-comment">// 锁类型(LOCK_EX,LOCK_SH)比较</span><br><span class="hljs-keyword">if</span> (request-&gt;fl_type == fl-&gt;fl_type)<br><span class="hljs-keyword">goto</span> out;<br>found = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// file结构上找到锁，但是类型不同，直接删除老的</span><br>locks_delete_lock_ctx(fl, &amp;dispose);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (request-&gt;fl_type == F_UNLCK) &#123;<br><span class="hljs-keyword">if</span> ((request-&gt;fl_flags &amp; FL_EXISTS) &amp;&amp; !found)<br>error = -ENOENT;<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br><br><span class="hljs-comment">//file结构上没找到锁也会走这儿</span><br>find_conflict:<br>list_for_each_entry(fl, &amp;ctx-&gt;flc_flock, fl_list) &#123;<br><span class="hljs-keyword">if</span> (!flock_locks_conflict(request, fl))<br><span class="hljs-keyword">continue</span>;<br>error = -EAGAIN;<br><span class="hljs-keyword">if</span> (!(request-&gt;fl_flags &amp; FL_SLEEP))<br><span class="hljs-keyword">goto</span> out;<br><span class="hljs-comment">// 返回这个就会上锁</span><br>error = FILE_LOCK_DEFERRED;<br>locks_insert_block(fl, request);<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br><span class="hljs-keyword">if</span> (request-&gt;fl_flags &amp; FL_ACCESS)<br><span class="hljs-keyword">goto</span> out;<br>locks_copy_lock(new_fl, request);<br>locks_insert_lock_ctx(new_fl, &amp;ctx-&gt;flc_flock);<br>new_fl = <span class="hljs-literal">NULL</span>;<br>error = <span class="hljs-number">0</span>;<br><br>out:<br>spin_unlock(&amp;ctx-&gt;flc_lock);<br>percpu_up_read_preempt_enable(&amp;file_rwsem);<br><span class="hljs-keyword">if</span> (new_fl)<br>locks_free_lock(new_fl);<br>locks_dispose_list(&amp;dispose);<br>trace_flock_lock_inode(inode, request, error);<br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><blockquote><p>从上面的原理可知：</p></blockquote><ul><li>fork,dup文件描述符后，fd对应的file结构不变，锁定关系不变。</li><li>单个进程可使用一个fd多次重复加锁（内核实际只加锁一次），所以只需要解锁一次。</li><li>单个进程对同一文件open两个fd（file结构不同），在这两个fd上依次加锁会死锁</li><li>关闭文件fd，在该fd上加的锁自动释放</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C语言实现默认参数</title>
    <link href="/2023/12/14/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0/"/>
    <url>/2023/12/14/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>关键字：可变参数，可变长参数</p><p>疑惑open函数为什么可以两个参数，也可以三个参数。如下是man open看到的声明：</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode)</span>;<br></code></pre></td></tr></table></figure><p>c语言本身不支持重载，它是怎么做到的呢？</p><p>下面来一个简单的实现。<br>利用逗号表达式和宏来实现，c为默认参数，默认0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> aa(a,b,c...) _aa(a,b,(0,##c))</span><br><br><span class="hljs-type">void</span> _aa(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d,%d\n&quot;</span>, a,b,c);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>aa(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>aa(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span><br><span class="hljs-attribute">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>malloc何时返回失败</title>
    <link href="/2023/12/12/malloc%E4%BD%95%E6%97%B6%E8%BF%94%E5%9B%9E%E5%A4%B1%E8%B4%A5/"/>
    <url>/2023/12/12/malloc%E4%BD%95%E6%97%B6%E8%BF%94%E5%9B%9E%E5%A4%B1%E8%B4%A5/</url>
    
    <content type="html"><![CDATA[<p>关键字：内存分配机制</p><p>在 [[linux是怎样工作的-内存管理]]中怀疑过malloc返回值的意义，感觉它从来不会失败。下面来分析一下应用层的内存分配机制。</p><h1 id="应用层机制"><a href="#应用层机制" class="headerlink" title="应用层机制"></a>应用层机制</h1><p>从系统层面看，进程分配内存有两种方式，brk和mmap（暂不考虑共享内存）。<br><strong>1、brk是将数据段(.data)的最高地址指针_edata往高地址推；</strong><br><strong>2、mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存</strong>。<br><strong>这两种方式分配的都是虚拟内存，没有分配物理内存</strong>。<strong>在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。</strong></p><p>一般程序分配内存使用的标准c库提供的malloc&#x2F;free。c库本身使用上面的两种方式向内核申请一块内存，然后自己管理。<br><strong>默认情况下，当malloc分配的内存小于128KB, 使用brk，分配的内存大于128KB时使用mmap</strong></p><h2 id="情况1-使用brk"><a href="#情况1-使用brk" class="headerlink" title="情况1 - 使用brk"></a>情况1 - 使用brk</h2><p>因为小内存分配才调用brk， brk只是推数据段的指针，而数据段的虚拟地址限制是很长的（多长以后再来填坑）。所以brk调用不会失败，即malloc不会失败。</p><p>系统调用的实现函数：<code>SYSCALL_DEFINE1(brk, unsigned long, brk)</code></p><h2 id="情况2-使用mmap"><a href="#情况2-使用mmap" class="headerlink" title="情况2 - 使用mmap"></a>情况2 - 使用mmap</h2><p>mmap的内核实现很复杂，梳理出检查内存的大致路线为：</p><figure class="highlight xl"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">do_mmap</span> --&gt;</span> <span class="hljs-function"><span class="hljs-title">mmap_region</span> --&gt;</span> <span class="hljs-function"><span class="hljs-title">security_vm_enough_memory_mm</span> --&gt;</span> __vm_enough_memory<br></code></pre></td></tr></table></figure><p><code>__vm_enough_memory</code>只是检查”剩余可用内存”，而mmap次数限制，地址空间限制在前面的流程就检查了。</p><p>那么函数<code>__vm_enough_memory</code>何时返回ENOMEM呢？</p><h1 id="内核机制"><a href="#内核机制" class="headerlink" title="内核机制"></a>内核机制</h1><p>应用层分配的虚拟内存大于系统的物理内存这种情况叫overcommit。<br>overcommit有三种策略，可通过<code>/proc/sys/vm/overcommit_memory</code>调整，默认值为0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERCOMMIT_GUESS0   <span class="hljs-comment">//估测可用内存，限制overcommit</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERCOMMIT_ALWAYS1   <span class="hljs-comment">//不限制，随意overcommit</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERCOMMIT_NEVER2   <span class="hljs-comment">//不允许overcommit</span></span><br></code></pre></td></tr></table></figure><p>当配置为策略为<code>OVERCOMMIT_NEVER</code>时，如下两个参数起作用：</p><ul><li>overcommit_kbytes：当不允许overcommit时，设置vm允许申请值的上限</li><li>overcommit_ratio：当不允许overcommit时，设置vm允许申请的百分比，默认50%</li></ul><p>查看内存分配够不够的关键函数为<code>__vm_enough_memory</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERCOMMIT_GUESS0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERCOMMIT_ALWAYS1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERCOMMIT_NEVER2</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Check that a process has enough memory to allocate a new virtual</span><br><span class="hljs-comment"> * mapping. 0 means there is enough memory for the allocation to</span><br><span class="hljs-comment"> * succeed and -ENOMEM implies there is not.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * cap_sys_admin is 1 if the process has admin privileges, 0 otherwise.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> __vm_enough_memory(<span class="hljs-keyword">struct</span> mm_struct *mm, <span class="hljs-type">long</span> pages, <span class="hljs-type">int</span> cap_sys_admin)<br>&#123;<br><span class="hljs-type">long</span> <span class="hljs-built_in">free</span>, allowed, reserve;<br>    <span class="hljs-comment">//增加vm_committed_as计数，这个全局变量统计系统当前vm申请量</span><br>    <span class="hljs-comment">//这个值也就是/proc/meminfo里Committed_AS的值</span><br>    <span class="hljs-comment">//因为最开始就增加了，因此本次申请数量也包含了</span><br>vm_acct_memory(pages);<br><br><span class="hljs-comment">//完全不限制虚拟内存的分配，随意overcommit，因此总是能成功</span><br><span class="hljs-keyword">if</span> (sysctl_overcommit_memory == OVERCOMMIT_ALWAYS)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//根据一定规则限制vm的overcommit，这也是系统默认行为</span><br>    <span class="hljs-comment">//这时就要计算下当前系统free的内存了</span><br><span class="hljs-keyword">if</span> (sysctl_overcommit_memory == OVERCOMMIT_GUESS) &#123;<br>        <span class="hljs-comment">//1、NR_FREE_PAGES是系统完全free的内存，也就是free命令查到的free项</span><br><span class="hljs-built_in">free</span> = global_page_state(NR_FREE_PAGES);<br>        <span class="hljs-comment">//2、NR_FILE_PAGES是page cache使用的页面，这些页面是可以释放的，</span><br>        <span class="hljs-comment">//因此也要计入free中，但是要扣除共享内存</span><br><span class="hljs-built_in">free</span> += global_page_state(NR_FILE_PAGES);<br><br><span class="hljs-comment">//3、NR_SHMEM是共享内存，这些不能计入free中</span><br><span class="hljs-built_in">free</span> -= global_page_state(NR_SHMEM);<br>        <span class="hljs-comment">//4、获取swap的free页数</span><br><span class="hljs-built_in">free</span> += get_nr_swap_pages();  <br><br><span class="hljs-comment">//5、slab里可回收的肯定是要记入free中啦</span><br><span class="hljs-built_in">free</span> += global_page_state(NR_SLAB_RECLAIMABLE);<br><br><span class="hljs-comment">//6、考虑系统运行的基本需求，也要占用一部分内存，因此free肯定不能小于该值</span><br><span class="hljs-comment">// totalreserve_pages大致等于high water</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">free</span> &lt;= totalreserve_pages)<br><span class="hljs-keyword">goto</span> error;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">free</span> -= totalreserve_pages;<br><br><span class="hljs-comment">//7、根据admin_reserve_kbytes的设置</span><br>        <span class="hljs-comment">//留一部分内存给root用户保证紧急情况下能登录系统，并恢复系统</span><br>        <span class="hljs-comment">//比如需要启动sshd/login, bash, and top/kill</span><br><span class="hljs-keyword">if</span> (!cap_sys_admin)<br><span class="hljs-built_in">free</span> -= sysctl_admin_reserve_kbytes &gt;&gt; (PAGE_SHIFT - <span class="hljs-number">10</span>);<br>        <span class="hljs-comment">//到最后了，free大于要分配的内存，这就是真能分配了</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">free</span> &gt; pages)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">goto</span> error;<br>&#125;<br>    <span class="hljs-comment">//这里就是完全不允许overcommit的情况了</span><br>    <span class="hljs-comment">//allowed用于统计系统vm上限，这个是就是/proc/meminfo里CommitLimit的值</span><br>    <span class="hljs-comment">//计算公式:CommitLimit = (Physical RAM * vm.overcommit_ratio / 100) + Swap</span><br>allowed = vm_commit_limit();<br><span class="hljs-comment">//同上，留一部分内存给root用户</span><br><span class="hljs-keyword">if</span> (!cap_sys_admin)<br>allowed -= sysctl_admin_reserve_kbytes &gt;&gt; (PAGE_SHIFT - <span class="hljs-number">10</span>);<br><br>    <span class="hljs-comment">//保证单进程不要使用完所有vm空间，至少保证自己能恢复</span><br>    <span class="hljs-comment">//和admin_reserve_kbytes类似，也要给自己留点退路，不然只能让root用户来恢复系统了</span><br><span class="hljs-keyword">if</span> (mm) &#123;<br>        <span class="hljs-comment">//给普通用户保留的空间为min(当前进程vm的32分之一，将近3%，user_reserve_kbytes)</span><br>reserve = sysctl_user_reserve_kbytes &gt;&gt; (PAGE_SHIFT - <span class="hljs-number">10</span>);<br>allowed -= <span class="hljs-type">min_t</span>(<span class="hljs-type">long</span>, mm-&gt;total_vm / <span class="hljs-number">32</span>, reserve);<br>&#125;<br>    <span class="hljs-comment">//vm_committed_as保存当前系统中已申请(包含本次)的vm数量</span><br>    <span class="hljs-comment">//如果已分配数量小于系统允许分配上限，那就是此次内存申请ok</span><br><span class="hljs-keyword">if</span> (percpu_counter_read_positive(&amp;vm_committed_as) &lt; allowed)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>error:<br>vm_unacct_memory(pages);<br>    <span class="hljs-comment">//内存不足</span><br><span class="hljs-keyword">return</span> -ENOMEM;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Committed memory limit enforced when OVERCOMMIT_NEVER policy is used</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">vm_commit_limit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> allowed;<br>    <span class="hljs-comment">//如果设置了overcommit_kbytes参数，那么commit就不能超过该值</span><br><span class="hljs-keyword">if</span> (sysctl_overcommit_kbytes)<br>allowed = sysctl_overcommit_kbytes &gt;&gt; (PAGE_SHIFT - <span class="hljs-number">10</span>);<br><span class="hljs-keyword">else</span><br>        <span class="hljs-comment">//如果没设置overcommit_kbytes参数，将读取overcommit_ratio参数的值</span><br>        <span class="hljs-comment">//既然是百分比，那么就需要有基数(总内存页面减去大页使用的内存)</span><br>allowed = ((totalram_pages - hugetlb_total_pages())<br>   * sysctl_overcommit_ratio / <span class="hljs-number">100</span>);<br>    <span class="hljs-comment">//同样别忘了还有swap页面数量</span><br>allowed += total_swap_pages;<br><br><span class="hljs-keyword">return</span> allowed;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="malloc失败发生过吗"><a href="#malloc失败发生过吗" class="headerlink" title="malloc失败发生过吗"></a>malloc失败发生过吗</h1><p>在嵌入式编程里面，很少遇到malloc失败的情况。因为内存不足时，还有缓存回收机制。<br>当程序的代码段都需要释放掉，用时才从flash上读出来时，系统此时已经很卡了。</p><p><strong>所以大多数情况下检查malloc返回值都没有意义。</strong><br>真正的大内存（至少大于128KB）分配检查才是有意义的：比如升级时。</p><p>但上面的描述仅限于linux，可能随着内核得更新实现也有区别。所以编写可移植，长久可靠的还是检查一下比较好。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/u010039418/article/details/104663831">vm内核参数之虚拟内存申请overcommit</a><br><a href="https://www.cnblogs.com/zhaoyl/p/3820852.html">malloc原理和内存碎片</a><br><a href="">知其然知其所以然，&#x2F;PROC&#x2F;MEMINFO之谜</a><br>[[meminfo详解]]</p>]]></content>
    
    
    
    <tags>
      
      <tag>内存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gcc选项跟踪函数调用</title>
    <link href="/2023/08/28/gcc%E9%80%89%E9%A1%B9%E8%B7%9F%E8%B8%AA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/"/>
    <url>/2023/08/28/gcc%E9%80%89%E9%A1%B9%E8%B7%9F%E8%B8%AA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>关键字：trace</p><blockquote><p>有时需要追踪函数究竟挂在了哪儿，gdb是一个不错的调试工具，但遇到栈被破坏的情况，并不能打印出调用栈，这时下面的方法就排上用处了。</p></blockquote><p><strong>增加gcc编译选项 -finstrument-functions</strong><br>gcc会自动在函数的入口和出口增加一个函数调用，函数原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __cyg_profile_func_exit(<span class="hljs-type">void</span>* callee, <span class="hljs-type">void</span>* callsite) __attribute__((no_instrument_function));<br><span class="hljs-type">void</span> __cyg_profile_func_enter(<span class="hljs-type">void</span>* callee, <span class="hljs-type">void</span>* callsite) __attribute__((no_instrument_function));<br></code></pre></td></tr></table></figure><p>以下为自定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;execinfo.h&gt;</span></span><br><br><span class="hljs-type">void</span> __cyg_profile_func_exit(<span class="hljs-type">void</span>* callee, <span class="hljs-type">void</span>* callsite) __attribute__((no_instrument_function));<br><span class="hljs-type">void</span> __cyg_profile_func_enter(<span class="hljs-type">void</span>* callee, <span class="hljs-type">void</span>* callsite) __attribute__((no_instrument_function));<br><br><span class="hljs-type">void</span> __cyg_profile_func_enter(<span class="hljs-type">void</span>* callee, <span class="hljs-type">void</span>* callsite) &#123;<br>    <span class="hljs-type">void</span>    *funptr = callee;<br>    <span class="hljs-type">char</span> **p = backtrace_symbols(&amp;funptr, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[;31m Entering: %s \033[0m\n&quot;</span>, *p);<br>    <span class="hljs-built_in">free</span>(p);<br>&#125;<br><br><span class="hljs-type">void</span> __cyg_profile_func_exit(<span class="hljs-type">void</span>* callee, <span class="hljs-type">void</span>* callsite) &#123;<br>    <span class="hljs-type">void</span>    *funptr = callee;<br>    <span class="hljs-type">char</span> **p = backtrace_symbols(&amp;funptr, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[;31m Exiting: %s \033[0m\n&quot;</span>, *p);<br>    <span class="hljs-built_in">free</span>(p);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行时就会打印出来函数调用来了，如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Entering: ./<span class="hljs-built_in">blink</span>() <span class="hljs-selector-attr">[0x1bb2c]</span> <br>Entering: ./<span class="hljs-built_in">blink</span>() <span class="hljs-selector-attr">[0x2028c]</span> <br>Entering: ./<span class="hljs-built_in">blink</span>() <span class="hljs-selector-attr">[0x1ffe4]</span> <br>Entering: ./<span class="hljs-built_in">blink</span>() <span class="hljs-selector-attr">[0x1f400]</span> <br>Exiting: ./<span class="hljs-built_in">blink</span>() <span class="hljs-selector-attr">[0x1f400]</span> <br></code></pre></td></tr></table></figure><p>再用addr2line(进程加了-g编译)来解析地址：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/opt/</span>toolchains<span class="hljs-regexp">/crosstools-arm-gcc-9.2-linux-4.19-glibc-2.30-binutils-2.32/u</span>sr<span class="hljs-regexp">/bin/</span>arm-buildroot-linux-gnueabi-addr2line -e tmp/blink -f <span class="hljs-number">0</span>x1f400<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">hgdpi_is_debug<br><span class="hljs-regexp">/home/</span>leon<span class="hljs-regexp">/code/</span>bcm-ax3000-cmcc<span class="hljs-regexp">/userspace/</span><span class="hljs-keyword">private</span><span class="hljs-regexp">/apps/</span>blink-sdk-publish<span class="hljs-regexp">/adapt/</span>public_adapt/blink_msg.cpp:<span class="hljs-number">57</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>obsidian插件使用</title>
    <link href="/2023/06/08/obsidian%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/06/08/obsidian%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="高级表格"><a href="#高级表格" class="headerlink" title="高级表格"></a>高级表格</h1><p>使用tab和enter，自动对齐，比较方便，还可以排序等</p><table><thead><tr><th>fdsf</th><th>fdsf</th><th>sdfsdf</th></tr></thead><tbody><tr><td>ss</td><td>sssssssssssssss</td><td>dddddddddddddd</td></tr><tr><td>fdsffdsfdsfdsfs</td><td>fdsfds</td><td>s</td></tr></tbody></table><h1 id="admonition"><a href="#admonition" class="headerlink" title="admonition"></a>admonition</h1><p>更美观的东西</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs ad-bug">不清楚为啥有问题<br></code></pre></td></tr></table></figure><p>自定义标题和默认折叠（折叠这个功能很有用，可以折叠大段代码）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ad-error">title: 代码<br>collapse: close<br><br>```c<br>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;string.h&gt;<br><br>int main(int argc, char *argv[])<br>&#123;<br>    /* code */<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ad-note">污染问题，和其他markdown解析器不兼容，肯定会存在一点点。不要用太高级的就行。<br>比方说通过hexo发布，就不会支持这些语法。<br></code></pre></td></tr></table></figure><h1 id="Number-headings"><a href="#Number-headings" class="headerlink" title="Number headings"></a>Number headings</h1><p>自动编号的插件。<br>它和以前用过的修改CSS的原理不一样，这个是修改源文件，添加了编号。<br>可通过ctrl+p， number移除编号和添加编号。建议不开自动编号，内容多的文章，ctrl+p打开自动编号。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu xfce桌面升级后锁屏无法输入登录问题</title>
    <link href="/2023/03/30/ubuntu%20xfce%E6%A1%8C%E9%9D%A2%E5%8D%87%E7%BA%A7%E5%90%8E%E9%94%81%E5%B1%8F%E6%97%A0%E6%B3%95%E8%BE%93%E5%85%A5%E7%99%BB%E5%BD%95%E9%97%AE%E9%A2%98/"/>
    <url>/2023/03/30/ubuntu%20xfce%E6%A1%8C%E9%9D%A2%E5%8D%87%E7%BA%A7%E5%90%8E%E9%94%81%E5%B1%8F%E6%97%A0%E6%B3%95%E8%BE%93%E5%85%A5%E7%99%BB%E5%BD%95%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>系统更新后，发现xfce桌面超时锁屏后，密码处无法输入字符。无法登录。只能重启。重启后桌面超时锁屏后又无法登录。</p><p>网上看到一篇文章 <a href="https://bugzilla.redhat.com/show_bug.cgi?id=1955993">https://bugzilla.redhat.com/show_bug.cgi?id=1955993</a> ，说是有两个锁屏在运行，导致出现问题。<br>xfce4-screensaver<br>xscreensaver</p><p>可以ps查看一下这两个进程是否存在，如果存在那么可能就是同一个问题。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>卸载掉xscreensaver，然后重启一下lightdm</p><figure class="highlight routeros"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs routeros">sudo apt <span class="hljs-built_in">remove</span> xscreensaver<br>sudo<span class="hljs-built_in"> service </span>lightdm restart <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>生成树协议STP算法</title>
    <link href="/2022/09/09/%E7%94%9F%E6%88%90%E6%A0%91%E5%8D%8F%E8%AE%AESTP%E7%AE%97%E6%B3%95/"/>
    <url>/2022/09/09/%E7%94%9F%E6%88%90%E6%A0%91%E5%8D%8F%E8%AE%AESTP%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="生成树协议STP算法"><a href="#生成树协议STP算法" class="headerlink" title="生成树协议STP算法"></a>生成树协议STP算法</h1><blockquote><p>以太网网桥使用生成树协议STP(Spanning Tree Protocol)，可以在提高网络可靠性的同时，又避免环路带来的各种问题。</p></blockquote><p>生成树算法STA(Spanning Tree Algorithm)是生成树协议的核心。它的目的是：在包含有物理环路的网络中，构建出一个能够连通全网各个节点的树形无环路逻辑拓扑。</p><p><strong>生成树算法三步骤</strong><br>（1）选举根网桥<br>（2）选举根端口<br>（3）选举指定端口并阻塞备用端口</p><h2 id="选举根网桥"><a href="#选举根网桥" class="headerlink" title="选举根网桥"></a>选举根网桥</h2><p>选举规则为：<strong>网桥ID（BID）最小者为根网桥。</strong></p><p>网桥ID由两部分组成：优先级，网桥的mac地址。<br>优先级范围为：0-61440，默认为32768，步长4096(优先级用一个字节高4bit表示，1表示的优先级为4096)。</p><p>网桥ID的比较方法为：<br>（1）优先级小的，则网桥ID越小。<br>（2）优先级相同，则比较MAC地址。MAC地址从左至右比较，数值小的，则网桥ID越小。</p><h2 id="选举根端口RP（Root-Port）"><a href="#选举根端口RP（Root-Port）" class="headerlink" title="选举根端口RP（Root Port）"></a>选举根端口RP（Root Port）</h2><p>每个非根网桥上都有一个根端口RP ，并且只有一个。<br>根端口RP用于接收根交换机发来的BPDU，也用于转发普通流量。</p><h3 id="根端口的选举条件为"><a href="#根端口的选举条件为" class="headerlink" title="根端口的选举条件为"></a>根端口的选举条件为</h3><p>（1）BPDU接收端口到根交换机的路径成本最小。<br>　　链路带宽　　成本值<br>　　 10Mbs&#x2F;s 　　100<br>　　 100Mb&#x2F;s 　　19<br>　　 1Gb&#x2F;s　　　　4<br>　　 10Gb&#x2F;s 　　　2<br>（2）对端的网桥ID最小。<br>（3）对端的端口ID（PID）最小。<br>　　端口ID由优先级和端口序号组成。<br>　　优先级范围为0-240，默认128，步长16。</p><h2 id="选举指定端口DP（Designated-Port）"><a href="#选举指定端口DP（Designated-Port）" class="headerlink" title="选举指定端口DP（Designated Port）"></a>选举指定端口DP（Designated Port）</h2><p>在每个网段选出指定端口，并且只有一个。<br>（前面说的网段，又有称LAN的，可以理解为：连接两个网桥的每条物理链路，每条物理链路上都有且一个指定端口）</p><p>指定端口用于转发根交换机发出来的BPDU，也用于转发普通流量。</p><h3 id="指定端口的选举条件"><a href="#指定端口的选举条件" class="headerlink" title="指定端口的选举条件"></a>指定端口的选举条件</h3><p>（1）根网桥的所有端口都是指定端口。<br>（2）根端口对端的端口一定是指定端口。<br>（3）BPDU转发端口到根交换机的路径成本最小的端口。<br>（4）本端的网桥ID最小者。</p><p>指定端口选举完成后，剩余端口便是备用端口AP(Alternate Port)，将他们阻塞。</p><h2 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h2><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/2022-09/09-152649-a99a-leon.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>popen里面使用&amp;把进程放后台问题</title>
    <link href="/2022/09/07/popen%E9%87%8C%E9%9D%A2%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/09/07/popen%E9%87%8C%E9%9D%A2%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="popen里面使用-amp-后台进程问题"><a href="#popen里面使用-amp-后台进程问题" class="headerlink" title="popen里面使用&amp;后台进程问题"></a>popen里面使用&amp;后台进程问题</h1><blockquote><p>这个例子可以加深对linux下fork,文件等的理解</p></blockquote><p>直接进入主题，如下代码</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br><span class="hljs-type">char</span> line[<span class="hljs-number">128</span>];<br>FILE *fp = popen(<span class="hljs-string">&quot;ping 127.0.0.1 &amp;&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br><span class="hljs-keyword">if</span>(!fp)&#123;<br>perror(<span class="hljs-string">&quot;popen&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br># 参数个数控制是否获取输出<br><span class="hljs-keyword">if</span>(argc == <span class="hljs-number">2</span>)&#123;<br><span class="hljs-keyword">while</span>(fgets(line, <span class="hljs-keyword">sizeof</span>(line), fp))&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;== %s\n&quot;</span>, line);<br>&#125;<br>&#125;<br>pclose(fp);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>分别以<code>./a.out</code>和<code>./a.out get</code>运行结果是怎样? </p><ul><li>ping能在后台运行吗？</li><li>a.out会立即退出吗？</li><li>a.out能捕获到ping输出吗？</li></ul><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><p>（1）以 .&#x2F;a.out 运行，<strong>ping不能再后台运行</strong>，a.out也会立即退出。<br>（2）以 .&#x2F;a.out get运行，ping能在后台运行，a.out可以捕获到ping输出，a.out不会立即退出。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>通过strace跟踪系统调用，分析如下：<br><strong>popen原理</strong><br>（1） 创建管道<br>（2）fork<br>（3）（子进程）将管道描述符dup到标准输入输出上<br>（4）（子进程）exec程序<br>（5）（父进程）（这是pclose调用）wait子进程</p><p><strong>命令行程序后加&amp;</strong><br>fork两次，然后子进程退出，孙子进程运行命令行程序。<br><strong>注意：fork的过程中，并没有去操作描述符</strong></p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><blockquote><p>先分析这个过程：以 .&#x2F;a.out 运行，<strong>ping不能再后台运行</strong>，a.out也会立即退出。</p></blockquote><p>（1）由于是后台运行ping，所以pclose会很快收到子进程退出，然后返回，a.out便退出了。注意：这是popen创建的管道读端便关闭了。<br>（2）ping程序运行时，标准输出为a.out的管道写端描述符。当ping程序输出时，会失败，因为a.out已经退出，管道的读已经关闭，会收到SIGPIPE信号，默认动作就是退出。所以ping并不能在后台一直运行。</p><blockquote><p>再分析这个过程：以 .&#x2F;a.out get运行，ping能在后台运行，a.out可以捕获到ping输出，a.out不会立即退出。</p></blockquote><p>和前面类似，子进程虽然已经退出，但孙子进程ping也随着fork复制了这个管道，子进程关闭管道读只是把引用计数-1，并不会真正关闭读管道，所以a.out进程可以一直读。a.out不退出，ping自然可以向管道输出，持续执行，不会遇到SIGPIPE信号。</p>]]></content>
    
    
    
    <tags>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cut命令使用</title>
    <link href="/2022/09/04/cut%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/09/04/cut%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="cut命令使用"><a href="#cut命令使用" class="headerlink" title="cut命令使用"></a>cut命令使用</h1><blockquote><p>cut的作用主要是对每一行进行剪切，然后输出。可以按三种方式剪切：-b 以字节的形式，-c 以字符的形式，-f 通过分隔符按域。<br>分隔符按域的功能比较弱，可用awk替代。</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1，3-7字符</span><br>leon@home-ubuntu22:~$ echo 12345678 | cut -c 1,3-7<br>134567<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">第4个字符到结束</span><br>leon@home-ubuntu22:~$ echo 12345678 | cut -c 4-<br>45678<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从开始到第6个字符</span><br>leon@home-ubuntu22:~$ echo 12345678 | cut -c -6<br>123456<br></code></pre></td></tr></table></figure><p><strong>-c字符和-b字节区别</strong><br>对于英文字符，没有区别，对于中文，一个中文字符可能游多个字节就有区别了。（但我实测中文按字符剪切还是乱码，可能和编码也存在关系）</p><p>去掉第一个和最后倒数第一个字符</p><blockquote><p>cut本身并不支持倒数这种语法，需要借助其他工具。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">leon@home-ubuntu22:~$ <span class="hljs-built_in">echo</span> 12345678 | <span class="hljs-built_in">cut</span> -c 2- | rev | <span class="hljs-built_in">cut</span> -c 2- | rev<br>234567<br></code></pre></td></tr></table></figure><p>rev: 倒置一串字符。上面倒置切割再倒置。</p>]]></content>
    
    
    
    <tags>
      
      <tag>命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sed使用</title>
    <link href="/2022/09/03/sed%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/09/03/sed%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>关键字：用法</p><h1 id="sed使用"><a href="#sed使用" class="headerlink" title="sed使用"></a>sed使用</h1><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cmake"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs cmake">sed [<span class="hljs-keyword">option</span>] [address]<span class="hljs-keyword">command</span> [input <span class="hljs-keyword">file</span>]<br></code></pre></td></tr></table></figure><p>如果没有输入文件，那么从标准输入中读取。</p><h4 id="option"><a href="#option" class="headerlink" title="option"></a>option</h4><table><thead><tr><th>option</th><th>作用</th></tr></thead><tbody><tr><td>-n</td><td>阻止输入行的自动输出(如需打印得需要p命令)</td></tr><tr><td>-f</td><td>使用脚本文件而不是命令行输入命令</td></tr><tr><td>-e</td><td>说明后面跟命令，命令行输入多个命令时使用。也可以使用大括号来实现</td></tr><tr><td>-E</td><td>使用扩展的正则</td></tr></tbody></table><p>sed默认使用的正则元字符较少（如不支持+？()|），所以<strong>建议加<code>-E</code>选项使用扩展的正则</strong>。这样和<code>egrep</code>, <code>grep -E</code>,<code>awk</code>正则表达式才相一致。</p><h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p>默认情况下，sed对每一个输入行都会执行command命令，如果只想对特定的行操作，那么需要address参数。</p><p>sed可以指定一个或两个地址。<br>如果只有一个地址，那么命令应用于这个地址匹配的行。<br>如果有两个地址，那么命令应用于第一个地址行和第二个地址行区间的所有行。</p><p>地址可以是一个数字，也可以是一个正则表达式。</p><p>如果地址后面跟有感叹号<code>!</code>，那么表示不匹配这些地址的行才应用命令。</p><p><strong>以删除命令d举例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">删除每一行</span><br>sed &#x27;d&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除第二行</span><br>sed &#x27;2d&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除最后一行</span><br>sed &#x27;$d&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除空行</span><br>sed &#x27;/^$/d&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除带有hello的行，地址和<span class="hljs-built_in">command</span>之间可以加一个空格</span><br>sed &#x27;/hello/ d&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除从第一行到以<span class="hljs-built_in">id</span>:开始的行</span><br>sed &#x27;1,/^id:/ d&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除start开头，end结束之外的行</span><br>sed &#x27;/start/,/end/! d&#x27;<br></code></pre></td></tr></table></figure><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>d</td><td>删除</td></tr><tr><td>p</td><td>打印</td></tr><tr><td>s</td><td>替换</td></tr><tr><td>a</td><td>在处理行后面追加新行</td></tr><tr><td>i</td><td>在处理行之前插入</td></tr><tr><td>c</td><td>以内容替换当前行</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">打印匹配的行</span><br>sed -n &#x27;/aaa/p&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果aaa匹配，那么把这一行替换为bbb</span><br>sed &#x27;/aaa/ cbbbb&#x27;<br></code></pre></td></tr></table></figure><h2 id="替换-s"><a href="#替换-s" class="headerlink" title="替换(s)"></a>替换(s)</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">[address] s<span class="hljs-regexp">/pattern/</span>replacement/flags<br></code></pre></td></tr></table></figure><p>模式使用正则表达式，可以用任意字符分割，如果模式里面游<code>/</code>字符，那么使用其他字符分割更清晰，如替换网站协议(使用@分割)：<code>s@https://@http://@</code></p><h3 id="flags"><a href="#flags" class="headerlink" title="flags"></a>flags</h3><table><thead><tr><th>标志</th><th>作用</th></tr></thead><tbody><tr><td>n</td><td>1-512的一个数字，表示对第n次出现进行替换</td></tr><tr><td>g</td><td>对模式的所有次出现都做替换，默认第替换第一次出现</td></tr><tr><td>p</td><td>打印行,如果sed指定了-n不输出参数，这个参数有用</td></tr></tbody></table><h2 id="多重命令与地址嵌套"><a href="#多重命令与地址嵌套" class="headerlink" title="多重命令与地址嵌套"></a>多重命令与地址嵌套</h2><p>多重命令通过大括号包起来，分号分割。<br>地址嵌套就是通过大括号在命令前面再加地址即可。<br>举例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">把每一行的br0替换为br1, up替换为down</span><br>sed -E &#x27;&#123;s/br0/br1/; s/up/down/&#125;&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">对1-5行内，删除以<span class="hljs-comment">#开头的行</span></span><br>sed -E &#x27;1,5 &#123;/^#/ d&#125;&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">对1-6行内，删除包含stp的行，行内包含eth0则进行替换</span><br>sed -E &#x27;1,6 &#123;/stp/ d; /eth0/ s/addif/delif/&#125;&#x27;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu server安装xfce4桌面</title>
    <link href="/2022/04/20/ubuntu%20server%E5%AE%89%E8%A3%85xfce4%E6%A1%8C%E9%9D%A2/"/>
    <url>/2022/04/20/ubuntu%20server%E5%AE%89%E8%A3%85xfce4%E6%A1%8C%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="ubuntu-server安装xfce4桌面"><a href="#ubuntu-server安装xfce4桌面" class="headerlink" title="ubuntu server安装xfce4桌面"></a>ubuntu server安装xfce4桌面</h1><blockquote><p>一般而言不需要使用桌面环境，只是为了使用gitk看log，通过smaba共享，在windows上看log比较慢。</p><p>xfce桌面环境据说比较轻量，快捷，linus大神都是用这个</p></blockquote><h2 id="安装xfce4桌面"><a href="#安装xfce4桌面" class="headerlink" title="安装xfce4桌面"></a>安装xfce4桌面</h2><p>使用如下命令安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">sudo apt install xfce4 xfce4-terminal<br></code></pre></td></tr></table></figure><p>xfce4-terminal一并装上，不然桌面终端会使用xterm，xterm实在太简陋了（主要是字体太小，还不好调（ctrl+右键可以临时调一下））。</p><p>装完之后登录时需要选择xfce4桌面</p><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/image/2022-04/20-234459-7894-leon.png" alt="image-20220420234456899"></p><p>登录之后就可以看到桌面了<br><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/image/2022-04/20-234948-fbdd-leon.png"></p><h2 id="安装xrdp"><a href="#安装xrdp" class="headerlink" title="安装xrdp"></a>安装xrdp</h2><blockquote><p>如果图形化不方便，还可以使用远程桌面</p></blockquote><p>安装xrdp</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> xrdp<br></code></pre></td></tr></table></figure><p>配置默认会话使用xfce4（不然登录上自动断开了）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> xfce4-session &gt;~/.xsession<br></code></pre></td></tr></table></figure><p>如果不是用的xfce桌面，可以执行下面命令看下有那些session管理器</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">update</span>-alternatives <span class="hljs-comment">--display x-session-manager</span><br></code></pre></td></tr></table></figure><p>然后使用windows自带的远程桌面软件远程。</p><p><strong>只支持同一用户拥有一个会话，即本地用户登录后，远程用户便无法登录，必须要logout一个后才能登录。</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客使用</title>
    <link href="/2022/04/04/%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/04/04/%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="博客使用"><a href="#博客使用" class="headerlink" title="博客使用"></a>博客使用</h1><h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><p>略，这种东西搭一次要用好久，下一次再搭时，方法已经过时了，找官方搭建方法即可(<strong>官方的过时很久了，有坑</strong>)</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span>hexo-cli -g<br>hexo init <span class="hljs-keyword">blog</span><br><span class="hljs-keyword"></span>cd <span class="hljs-keyword">blog</span><br><span class="hljs-keyword"></span>npm <span class="hljs-keyword">install</span><br><span class="hljs-keyword"></span>hexo server<br></code></pre></td></tr></table></figure><p>hexo安装后，安装了fluid主题。然后配置了一下。</p><p><a href="https://hexo.io/zh-cn/docs/index.html">hexo官方文档</a><br><a href="https://fluid-dev.github.io/hexo-fluid-docs/start/">fluid官方文档</a></p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-comment">-- 这是生成的静态页面，hexo g命令生成，hexo clean会删除这个目录</span><br>source <span class="hljs-comment">-- 保存的文章</span><br></code></pre></td></tr></table></figure><h2 id="hexo命令"><a href="#hexo命令" class="headerlink" title="hexo命令"></a>hexo命令</h2><ul><li><p><code>hexo init name</code><br>初始化一个博客</p></li><li><p><code>hexo new title</code>, 简写<code>hexo n</code><br>新建一个文章，也可以不用这命令，直接去source&#x2F;_posts目录建md文件，差不太多</p></li><li><p><code>hexo generate</code>, 简写<code>hexo g</code><br>生成静态文件，可加<code>-d</code>选项，表示生成后部署</p></li><li><p><code>hexo server</code>，简写<code>hexo s</code><br>启动本地服务器</p></li><li><p><code>hexo deploy</code>，简写<code>hexo d</code><br>将静态页面部署出去</p></li><li><p><code>hexo clean</code><br>清理生成的静态文件<br>如果已经发布的文章，无法删除，需要删掉<code>.deploy_git</code>目录</p></li></ul><h2 id="分类，标签"><a href="#分类，标签" class="headerlink" title="分类，标签"></a>分类，标签</h2><p>markdown文件中添加如下内容</p><p>date–创建时间<br>updated–更新时间</p><p>如果不指定时间，将会根据文件的创建修改时间决定</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章名</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2017-05-26 12:12:57</span><br><span class="hljs-attr">updated:</span> <span class="hljs-number">2022-4</span><span class="hljs-number">-3</span> <span class="hljs-number">17</span><span class="hljs-string">:11:27</span><br><span class="hljs-attr">categories:</span> <br><span class="hljs-bullet">-</span> <span class="hljs-string">分类名只能有一个</span><br><span class="hljs-attr">tags:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">标签</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">表格</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">表单验证</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p> 如果是部署到github page，那么<code>hexo g -d</code>提交代码后，大约隔一分钟访问才会刷新，这是gitbub page的编译机制吧。</p><p>配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:leon0625/leon0625.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br></code></pre></td></tr></table></figure><p>然后在git仓库里面加开发者秘钥。</p><h2 id="自动部署"><a href="#自动部署" class="headerlink" title="自动部署"></a>自动部署</h2><p>要在每台电脑上写博客，那么需要在每台电脑上安装hexo。通过nextcloud同步博客数据虽说也不是太麻烦。但笔记本身会在obsidian存一份，需要发布的笔记又要复制一份到blog目录，更新的时候也需要复制，不是很方便。</p><p>构想如下：</p><pre><code class=" mermaid">sequenceDiagramautonumberparticipant J as obsidianparticipant N as nextcloud服务器participant G as github.ioN -&gt;&gt; N: 检查是否有md文件修改J-&gt;&gt;N: 编辑保存后同步过来N -&gt;&gt; G:检查到有posthex标志&lt;br/&gt;有的话自动构建部署</code></pre><p><strong>nextcloud上的处理流程</strong></p><pre><code class=" mermaid">flowchart a1((启动)) --&gt; a2(遍历obsidian目录) --&gt; a3(有postHexo标志) --&gt;|是| a4(分析文本)a3 --&gt; |否|a2a2 --&gt; |遍历结束| b1(监控文件变化)a4 --&gt; c2(&quot;复制到hexo blog目录(重命名文件，更新updated字段)&quot;) b1 --&gt; |文件变化| d1(有postHexo标志) --&gt; |否|b1 c1(&quot;提取updated字段，提取title&quot;) d1 --&gt; |是|c1 --&gt; c2 --&gt; e1(hexo g -d部署)</code></pre><p>updated字段使用nextcloud上文件的修改时间。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ros ipv6配置</title>
    <link href="/2022/03/22/ros%20ipv6%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/03/22/ros%20ipv6%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="ros-ipv6配置"><a href="#ros-ipv6配置" class="headerlink" title="ros ipv6配置"></a>ros ipv6配置</h1><p>官方文档：<a href="https://wiki.mikrotik.com/wiki/Manual:TOC">https://wiki.mikrotik.com/wiki/Manual:TOC</a></p><h2 id="拓扑图"><a href="#拓扑图" class="headerlink" title="拓扑图"></a>拓扑图</h2><pre><code class=" mermaid">flowchart TBgm(&quot;光猫(桥模式)&quot;)ROS((&quot;ROS&quot;))R1(&quot;Router1&quot;)R2(&quot;Router2&quot;)R3(&quot;Router3...&quot;)R4(&quot;Router4&quot;)gm ---|pppoe拨号| ROSROS ---|&quot;pppoe或者dhcp&quot;|R1ROS ---|&quot;pppoe或者dhcp&quot;| R2ROS ---|&quot;pppoe或者dhcp&quot;| R3R1---PC(&quot;电脑&quot;)R1 -.- phone(&quot;手机&quot;)R2 x--x |不能再连路由器,R2无法提供前缀|R4</code></pre><h2 id="安装ipv6包"><a href="#安装ipv6包" class="headerlink" title="安装ipv6包"></a>安装ipv6包</h2><p>默认没有安装，需要手动点击安装</p><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/image/2022-03/22-162110-d8a8-leon.png" alt="image-20220322162110532"></p><h2 id="操作原理"><a href="#操作原理" class="headerlink" title="操作原理"></a>操作原理</h2><p>IPV6不同于IPV4最大的一点在于IPV6的地址是全局的。这就需要上级路由器在路由时能够准确把各个地址路由到不同的设备。</p><p>ROS拨号运营商时，可以通过dhcp获取到一个60位长度的代理前缀。ipv6前缀长度至多64位。所以给ROS的操作空间还有4位（<strong>共16个前缀可用</strong>）。</p><p>ROS bridge自身使用一个前缀，一个pppoe客户端会使用两个前缀。一个dhcp客户端使用一个前缀。</p><p>所以理论上可以供15个dhcp客户端（或者7个pppoe客户端）获取代理前缀。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>先把光猫拨号这边配置好，拿到运营商给的代理前缀。</p><h3 id="pppoe-client拨号配置"><a href="#pppoe-client拨号配置" class="headerlink" title="pppoe client拨号配置"></a>pppoe client拨号配置</h3><p>主要是选好拨号接口（ether1），profile创建一个新的（配置默认即可）避免和后面的pppoe 服务器冲突</p><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/image/2022-03/23-184217-1954-leon.png" alt="image-20220323184217839"></p><h3 id="dhcp-v6-client配置"><a href="#dhcp-v6-client配置" class="headerlink" title="dhcp v6 client配置"></a>dhcp v6 client配置</h3><p>配置dhcp v6 client去获取代理前缀。</p><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/image/2022-03/23-184433-3d47-leon.png" alt="image-20220323184433626"></p><p>勾选前缀代理之后，获取到前缀后会自动生成一条pool配置，如下：</p><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/image/2022-03/23-184458-8914-leon.png" alt="image-20220323184458077"></p><p><code>prefix</code>是上级通过dhcpv6下发下来，<code>prefix length</code>是上面自己配置的，即这个pd_auto_pool地址池下发前缀的活动空间有4bit位。如果配置的Pool Prefix Length小于下发的长度，那么prefix length默认会在代理前缀长度的基础上加8。</p><h3 id="dhcp-v6-server配置"><a href="#dhcp-v6-server配置" class="headerlink" title="dhcp v6 server配置"></a>dhcp v6 server配置</h3><p>这个配置比较简单，只需要选中前面自动生成的pool即可。</p><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/image/2022-03/22-163801-e5df-leon.png" alt="image-20220322163801321"></p><p><strong>注意：我实测有状态从ros拿地址拿不到，不清楚原因。看了mikrotik的wiki，没找到有状态配置的相关信息，直接不支持有状态获取地址了？</strong></p><h3 id="桥接口地址配置"><a href="#桥接口地址配置" class="headerlink" title="桥接口地址配置"></a>桥接口地址配置</h3><p>给桥接口配置ipv6地址，地址为pool前缀::1&#x2F;64，advertise勾上，会自动在ND配置prefix（radvd的前缀）</p><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/image/2022-03/22-164033-967b-leon.png" alt="image-20220322164033783"></p><p>配置完这一步，会在ND配置哪儿自动生成prefix，如下：</p><p>这下面有三个prefix，都是自动生成的。</p><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/image/2022-03/23-184650-a1b8-leon.png" alt="image-20220323184650839"></p><h3 id="RADVD配置"><a href="#RADVD配置" class="headerlink" title="RADVD配置"></a>RADVD配置</h3><p>就是上面的ND interfaces里面，基本不用配置，默认配置即可。</p><p><strong>配置前缀和有效期</strong></p><blockquote><p>配置有效期，避免ROS上的前缀已经过期了，设备还一直使用</p></blockquote><p>ND –&gt; prefixes –&gt; default</p><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/image/2022-03/30-190111-31c2-leon.png" alt="image-20220330190111202"></p><h3 id="pppoe服务器配置"><a href="#pppoe服务器配置" class="headerlink" title="pppoe服务器配置"></a>pppoe服务器配置</h3><p>重点配置为如下勾选的三个。</p><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/image/2022-03/23-185233-c8cc-leon.png" alt="image-20220323185233891"></p><p>当勾选Remote Ipv6 prefix pool后，会自动给ROS的ppp接口添加ipv6前缀广播RA，这样下级路由器的ppp接口就能拿到全局地址</p><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/image/2022-03/23-185438-38ba-leon.png" alt="image-20220323185438395"></p><p>当勾选DHCPv6 PD Pool时，会自动生成dhcpv6的配置</p><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/image/2022-03/23-185607-4d96-leon.png" alt="image-20220323185607047"></p><p><code>Interface List</code>配置为LAN，确保路由器pppoe客户端拨号后，能够拿到代理前缀。以及拨号的情况下，确保PC可以进ROS管理页面。</p><p>（不是LAN上来的数据包会在filter里面被过滤掉）</p><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/image/2022-03/23-185817-0b2b-leon.png" alt="image-20220323185817403"></p><p>配置为LAN后，会自动添加如下配置</p><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/image/2022-03/23-185942-ea98-leon.png" alt="image-20220323185942930"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>ROS貌似不支持有状态获取地址。它的文档里面也没有提及有状态获取地址的部分。</li><li>如上的配置不支持路由器下面再接路由器，因为没有可供使用的前缀了。</li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="路由器DHCP切换PPPOE接入，无法拿到代理前缀问题"><a href="#路由器DHCP切换PPPOE接入，无法拿到代理前缀问题" class="headerlink" title="路由器DHCP切换PPPOE接入，无法拿到代理前缀问题"></a>路由器DHCP切换PPPOE接入，无法拿到代理前缀问题</h3><p>抓包看，ROS下发的dhcpv6里面的代理前缀的合法时间为0，导致路由器反复请求。</p><p><strong>解决办法：</strong></p><p>在ROS的DHCP Server里面删掉这个设备之前DHCP的Bindings条目即可。</p><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/2022-04/22-181049-a72a-leon.png"></p><p><strong>可能原因分析：</strong></p><p>dhcp和pppoe接入时，路由器使用的DUID是一样的，可能导致ROS出现问题。而且路由器在断开DHCP前是发了RELEASE的。</p><p>如果设置路由器的DUID为mac+时间类型，则没有问题。</p><p><strong>ROS v7.7版本解决了这个问题</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>perl语言入门第六版读书笔记</title>
    <link href="/2022/02/20/perl%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E7%AC%AC%E5%85%AD%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/02/20/perl%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E7%AC%AC%E5%85%AD%E7%89%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="perl语言入门第六版"><a href="#perl语言入门第六版" class="headerlink" title="perl语言入门第六版"></a>perl语言入门第六版</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>本书涵盖的最低版本5.8</li><li>CPAN,perl综合典藏网，里面包含扩展，文档等</li><li>perl解析器能一次完成编译和运行这两个动作。（注意是有先编译，即运行前就可以检查到整个代码的语法错误）</li></ul><h2 id="标量数据"><a href="#标量数据" class="headerlink" title="标量数据"></a>标量数据</h2><ul><li>perl每个语句必须以分号；结束</li><li>perl的数字可以通过下划线分割，方便理解<code>0x1234_2222_ffff</code></li><li>perl虽然都是浮点数，但是支持取模运算（%）</li><li>如果源代码中有ascii之外的字符，那么加上一行<code>use utf8;</code>，让编译器正确解释你的代码。</li><li>单引号内除了反斜杠和自身，所有字符都代表它们自己，包块换行符</li><li>字符串的连接操作使用的<code>.</code>号</li><li>字符串的重复操作使用的小写字母<code>x</code>，<code>&quot;aaa&quot; x 3</code>重复aaa 3次。</li><li>perl里面包含大量的默认行为，当发现程序不对时，可以打开警告<code>use warnings;</code>，也可在命令行中添加<code>-w</code>选项。<code>use warnings;</code>说的更灵活，可以指定某几行代码警告。</li><li>标量的变量前缀为<code>$</code></li><li>字符串比较运算符使用的<code>eq</code>,<code>ne</code>不等，<code>lt</code>小于操作符</li><li>字符串’0’非空，但是代表条件假。它是唯一的非空字符串假</li><li><code>&lt;STDIN&gt;</code>获取用户输入</li><li><code>chomp($text)</code>去掉结尾的换行符，<code>chomp($text=&lt;STDIN&gt;)</code></li><li>要判断某个字符串是undef而不是空字符串，可使用defined函数，如果是undef,那么返回假</li><li>print函数中内插变量时，如果变量后面紧跟字符，那么变量应使用形式<code>print &quot;$&#123;var&#125;a&quot;</code>形式，避免perl认为变量名包含后面紧跟的字符a</li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul><li>截取字符串函数substr<br><code>my $part = substr($string, $pos, $length);</code><figure class="highlight perl"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># 截取开头4个字符，末尾两个字符，用..拼接起来。</span><br><span class="hljs-keyword">print</span> <span class="hljs-keyword">substr</span>($_, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>) . <span class="hljs-string">&quot;..&quot;</span> . <span class="hljs-keyword">substr</span>($_, -<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure></li></ul><h2 id="列表和数组"><a href="#列表和数组" class="headerlink" title="列表和数组"></a>列表和数组</h2><ul><li>引用整个数组时，数组名前面添加<code>@</code>符号。</li><li>数组下标从0开始，最后一个索引值为<code>$#array</code>，取最后一个元素，可直接用<code>$array[-1]</code></li><li>可用两个点<code>..</code>操作符产生一个整数列表，如<code>1..100</code>，只能递增。</li><li>可用<code>qw</code>操作符，产生一个字符串列表，perl发明人可真懒</li><li>pop读出数组最后一个元素并返回，push添加元素到最后</li><li>shift,unshift操作最左边的元素，和pop,push类似</li><li><code>@removed = splice @array,idx,del_num,@insert_array</code>, 移除idx开始的n个元素，并插入一个数组，返回移除的数组。后两个参数可选，默认移除从idx到最后的所有元素。</li><li><code>print @array</code>会将数组元素一个个打印出来，<code>print &quot;@array&quot;</code>，会在数组元素中间加一个空格打印出来。<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">foreach</span> $i (<span class="hljs-keyword">qw</span> / aa bb cc /)&#123;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;$i&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>foreach的控制变量并没有复制数组里面的值，相当于引用。修改控制变量会直接修改到数组本身。</li><li>foreach可以省略控制变量，会使用默认变量<code>$_</code></li><li><code>reverse</code>返回一个持续相反的列表，并不改变原列表</li><li><code>sort</code>返回ascii序的列表，也不会改变原列表</li><li>数组的名称在列表上下文，返回元素的列表。在标量的上下文，返回数组元素个数。</li><li><code>chomp(@lines = &lt;STDIN&gt;)</code> 读所有行，并移除换行符</li></ul><h2 id="子程序"><a href="#子程序" class="headerlink" title="子程序"></a>子程序</h2><ul><li>不需要子程序事先声明，如果有两个同名子程序，后面的会覆盖前面的</li><li>所有子程序都有返回值，没有明确指定return的话，返回值就是最后一次运算结果的值</li><li>perl自动将参数列表存在名为<code>@_</code>的数组变量中，那么第一个参数为<code>$_[0]</code></li><li>默认perl的所有变量都是全局变量，创建私有变量要使用<code>my</code>。</li><li>my操作符后面不加括号，只能声明单个局部变量，加括号才能声明多个，实际上是声明的一个列表。</li><li><code>use strict</code>让perl严格约束代码</li><li>如果编译器在调用子程序时看到过子程序的定义，那么调用子程序的时候可以省略<code>&amp;</code>号，添加<code>&amp;</code>也可以避免和perl内置函数同名的问题，<code>&amp;</code>总是会调用自定义的子程序。</li><li>单写一个return不给任何参数，表明返回的空。对于标量上下文，就是undef，列表上下文就是空列表。</li><li>持久私有变量。类似于静态变量。state操作符声明，需要使用<code>use feature &#39;state&#39;</code>语句</li></ul><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">while</span>(&lt;&gt;)&#123;<br><span class="hljs-keyword">chomp</span>;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;get line: $_\n&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">print</span> &lt;&gt;; <span class="hljs-comment">#相当于cat命令</span><br><span class="hljs-keyword">print</span> <span class="hljs-keyword">sort</span> &lt;&gt;; <span class="hljs-comment">#相当于sort命令</span><br></code></pre></td></tr></table></figure><ul><li>建议用大写字母命名文件句柄</li><li>有6个特殊的文件句柄是perl保留的：STDIN,STDOUT,STDERR,DATA,ARGV,ARGVOUT</li><li>可通过如下命令打开文件句柄</li></ul><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">open</span> FH, <span class="hljs-string">&#x27;filename&#x27;</span>; <span class="hljs-regexp">//</span>默认读打开<br><span class="hljs-keyword">open</span> FH, <span class="hljs-string">&#x27;&lt;filename&#x27;</span>;<span class="hljs-regexp">//</span>读<br><span class="hljs-keyword">open</span> FH, <span class="hljs-string">&#x27;&gt;filename&#x27;</span>;<span class="hljs-regexp">//</span>写<br><span class="hljs-keyword">open</span> FH, <span class="hljs-string">&#x27;&gt;&gt;filename&#x27;</span>;<span class="hljs-regexp">//</span>追加<br><br><span class="hljs-comment"># 也可以用三个参数的写法</span><br><span class="hljs-keyword">open</span> FH, <span class="hljs-string">&#x27;&gt;&#x27;</span>,<span class="hljs-string">&#x27;filename&#x27;</span>;<br><span class="hljs-comment"># 可以指定编码</span><br><span class="hljs-keyword">open</span> FH, <span class="hljs-string">&#x27;&lt;:encoding(UTF-8)&#x27;</span>, <span class="hljs-string">&#x27;filaname&#x27;</span>;<br><br><span class="hljs-comment">#关闭</span><br><span class="hljs-keyword">close</span> FH;<br><br><span class="hljs-comment"># 从5.6开始，句柄可以存放到变量中，方便作为参数传递，控制作用域</span><br><span class="hljs-keyword">my</span> $fh;<br><span class="hljs-keyword">open</span> $fh, <span class="hljs-string">&quot;&gt;&quot;</span>, <span class="hljs-string">&quot;filename&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li>二进制方式读写<code>binmode</code></li><li><code>die &quot;some error: $!&quot;;</code>结束程序并打印东西，<code>$!</code>表示系统错误信息，类似strerror。</li><li>die会自动打印行号和文件名，如果不需要打印这个，那么只需在后面加一个换行符。</li><li>warn函数差不多，只是不会终止程序运行。</li><li>5.10开始，可以用<code>use autodie;</code>。它如果检查到系统调用级别的错误，就会自动die。相当于不用检查文件打开是否成功这类错误了。</li><li>$0中保存了程序的名字</li><li>文件句柄的使用和之前用得STDIN差不多。<code>print LOG &quot;xxxx&quot;</code>，将字符串输出到LOG这个句柄里。</li><li>重新打开已经打开的句柄时，perl会自动关闭原来的句柄，比如可通过如下语句重定向错误输出到文件<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">open STDERR, <span class="hljs-string">&quot;&gt;&gt;error.log&quot;</span>;<br></code></pre></td></tr></table></figure></li><li>5.10开始有一个say函数，和print差不多，只是自动加一个换行符。</li></ul><p><strong>ARGV相关</strong></p><ul><li><p><code>$ARGV</code> 表示参数命令行的文件中，当前正在处理的文件名</p></li><li><p><code>@ARGV</code> 里面保存了命令行的参数列表，一般就是输入的文件名，在<code>&lt;&gt;</code>操作中，列表的元素会一个个移除</p></li><li><p><code>ARGV</code>表示<code>&lt;&gt;</code>当前正在处理的文件句柄。</p></li></ul><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><ul><li><p>键必须是唯一的字符串</p></li><li><p>访问hash的语法为<code>$hash&#123;$key&#125;</code>，大括号</p></li><li><p>访问整个哈希，可以使用%作为前缀。哈希可以转换为列表。列表也可以赋值给hash。</p></li><li><p><code>%reverse_hash = reverse %any_hash</code> 可以建立一个反序的哈希，即key-value变为value-key。</p></li><li><p>给hash赋值可以使用列表的形式：<code>%some_hash = (&#39;key1&#39;, 22, &#39;key2&#39;, &quot;333&quot;)</code>。这种形式不方便看。可以使用胖箭头 <code>=&gt;</code> ，对perl而言，它只是逗号的另一种写法，唯一的区别在于胖箭头左边的裸字都会加上引号。于是可以这样初始化hash：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> %some_hash = (<br><span class="hljs-string">key1 =&gt;</span> <span class="hljs-string">&quot;1231&quot;</span>,<br><span class="hljs-string">key2 =&gt;</span><span class="hljs-number">123</span>,<br><span class="hljs-string">key3 =&gt;</span> &#123; <span class="hljs-comment"># hash嵌套</span><br><span class="hljs-string">aaa =&gt;</span> <span class="hljs-number">222</span>,<br><span class="hljs-string">bbb=&gt;</span> <span class="hljs-number">233</span>,<br>&#125;<br>);<br></code></pre></td></tr></table></figure></li><li><p><strong>注意hash初始化使用的圆括号,嵌套时用大括号</strong></p></li><li><p>访问hash元素的时候可以省略key的引号，<code>$hash&#123;&quot;aaa&quot;&#125;</code> 和<code>$hash&#123;aaa&#125;</code>同义。</p></li><li><p><code>my @k = keys %hash</code>， <code>my @v = values %hash</code> 两个函数可用于提取所有key和value</p></li><li><p>each函数变量hash</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">while</span> (($key, $value) = <span class="hljs-keyword">each</span> %hash)&#123;<br>;<br>&#125;<br></code></pre></td></tr></table></figure><p>echo会从hash中返回键值对，这是一个两个元素的列表。而赋值后得到的列表在标量上下文就是元素个数，为2。所以一直循环，知道取不出来值。</p></li><li><p><code>exists</code>函数用户检查hash中是否存在某个键：<code>if(exists $books&#123;leon&#125;)</code></p></li><li><p><code>delete $books&#123;leon&#125;</code> 函数用于删除某个键值对。</p></li><li><p>hash元素可以内插，但是不支持内插整个hash。如果想要打印整个hash，可以先把hash赋值给列表，然后内插整个列表。</p></li><li><p><code>%ENV</code>这个内置的hash存储了环境变量</p></li></ul><h2 id="漫游正则表达式王国"><a href="#漫游正则表达式王国" class="headerlink" title="漫游正则表达式王国"></a>漫游正则表达式王国</h2><ul><li>正则表达式和glob（shell的文件名匹配模式）不是同一个东西</li><li>捕获分组时，反向应用的方法是<code>\1</code>,<code>\2</code>。如何知道是第一个还是第二个，从左到右数括号的序号即可。从perl 5.10开始支持<code>\g&#123;N&#125;</code>来表示是第几组，可以更方便，可以指定负数</li><li>perl 5.10开始引入<code>\R</code>能匹配任意一种换行符</li><li>反义简写，<code>\D</code>非数字，<code>\W</code>非单词, <code>\S</code>非空白符</li></ul><h2 id="用正则表达式进行匹配"><a href="#用正则表达式进行匹配" class="headerlink" title="用正则表达式进行匹配"></a>用正则表达式进行匹配</h2><ul><li><p><code>m/xxx/flag</code> ，如果以<code>//</code>作为定界符，那么m可以省略。当然为了方便可以用其他的定界符。flag有：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">i <span class="hljs-comment">-- 忽略大小写</span><br>m <span class="hljs-comment">-- 多行匹配</span><br>s <span class="hljs-comment">-- 匹配任意字符，默认情况下点号 . 无法匹配换行符，如果指定了这个就可以匹配了。</span><br>x <span class="hljs-comment">-- 忽略正则表达式中的空白符，这样方便分割正则表达式，让正则表达式看起来更清晰(可以分行写，每行写注释)</span><br>p <span class="hljs-comment">-- ^PREMATCH, ^MATCH, ^POSTMATCH变量使用</span><br><br>perl <span class="hljs-number">5.14</span>开始可以指定如果解释字符：<br><span class="hljs-keyword">a</span> <span class="hljs-comment">-- ascii</span><br>u <span class="hljs-comment">-- unicode</span><br>l <span class="hljs-comment">-- 使用本地化的语言设置</span><br></code></pre></td></tr></table></figure></li><li><p>锚位，不匹配任何字符，但可以指定位置</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ada">^ <span class="hljs-comment">-- 行首</span><br>$ <span class="hljs-comment">-- 行尾</span><br>\A <span class="hljs-comment">-- 字符串的绝对开头，多行的情况下和^有一点区别，单行和^同义</span><br>\Z <span class="hljs-comment">-- 字符串的绝对末尾</span><br>\b <span class="hljs-comment">-- 单词边界</span><br>\B <span class="hljs-comment">-- 非单词边界</span><br></code></pre></td></tr></table></figure></li><li><p>绑定操作符<code>=~</code>，默认情况下，正则匹配<code>$_</code>变量，<code>$var =~ /reg/</code>可以使其匹配<code>$var</code>变量。</p></li><li><p>正则表达式中可以内插变量。</p></li><li><p>如果正则表达式有括号，表示要捕获这个分组，但有时不想捕获，可以使用<code>(?:xxx)</code>，表示不捕获这个分组。</p></li><li><p>命名捕获。perl 5.10开始，可以直接把捕获的分组存入内置的<code>%+</code>这个hash变量中， <code>(?&lt;name&gt;regex)</code>。使用这个变量的方法为<code>$+&#123;name&#125;</code></p></li><li><p>使用命名捕获后，反向引用的语法也随之改变为<code>\g&#123;label&#125;</code></p></li><li><p>自动捕获变量。perl会自动把匹配前，匹配，匹配后的三串字符串存入如下三个变量，perl 5.10后，使用<code>/p</code> flags会将结果存入更容易记忆的几个变量。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$`</span>  --- <span class="hljs-variable">$&#123;</span>^PREMATCH&#125;<br><span class="hljs-variable">$&amp;</span>  --- <span class="hljs-variable">$&#123;</span>^MATCH&#125;<br><span class="hljs-variable">$&#x27;</span>  --- <span class="hljs-variable">$&#123;</span>^POSTMATCH&#125;<br><span class="hljs-comment"># 后面的三个变量也好理解，外面的花括号围住表示其中是完整的变量名，变量名前面加^避免重复。</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="用正则表达式处理文本"><a href="#用正则表达式处理文本" class="headerlink" title="用正则表达式处理文本"></a>用正则表达式处理文本</h2><ul><li><p><code>s///</code>进行替换，返回bool值，成功为真，否则为假</p></li><li><p><code>/g</code>全局替换</p></li><li><p>同<code>m//</code>一样，替换也可以使用不同的定界符，对于没有左右之分的字符，写三个就行，如果不是就需要成对写，如下几种意思一样：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">s</span>/<span class="hljs-number">123</span>/<span class="hljs-number">456</span>/<br><span class="hljs-attribute">s</span>|<span class="hljs-number">123</span>|<span class="hljs-number">456</span>|<br><span class="hljs-attribute">s</span>&#123;<span class="hljs-number">123</span>&#125;&#123;<span class="hljs-number">456</span>&#125;<br><span class="hljs-attribute">s</span>[<span class="hljs-number">123</span>](<span class="hljs-number">456</span>)<br></code></pre></td></tr></table></figure></li><li><p>和<code>m//</code>一样，替换也可以使用绑定操作符<code>$aa =~ s/123/456/</code></p></li><li><p><code>/r</code>不直接操作源字符串，而是返回一个新的。<code>my $copy = $orig =~ s/111/222/</code></p></li><li><p>大小写转换</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\U</span> -- 把之后的所有字符转为大写， s<span class="hljs-regexp">/aaa/</span><span class="hljs-string">\U$var/</span><br><span class="hljs-string">\L</span> -- 把后面的所有字符转为小写<br><span class="hljs-string">\E</span> -- 停止后面的字符转换<br><span class="hljs-string">\u,</span> <span class="hljs-string">\l</span> -- 只转换一个字符<br></code></pre></td></tr></table></figure><p>上面的转换在print里面也是可以用得。</p></li><li><p><code>split /separator/, &#39;$string&#39;</code>操作符。分割字符串，返回列表。默认以空白字符分割，默认操作<code>$_</code>变量。</p></li><li><p>如果要在split的模式中使用分组，那么要使用分组不捕获写法<code>(?:)</code></p></li><li><p><code>join aaa, @array</code>，在字符串中加入粘合剂</p></li><li><p>在列表上下文，使用<code>m//</code>，匹配成功返回所有捕获分组的列表，失败返回空列表</p></li><li><p><code>$^I = &quot;.bak&quot;</code>变量，设置后，钻石操作符<code>s///</code>时，会直接写原文件，但会有一个备份文件生成。如果设置这个字符串为空串，那么不会生成备份文件。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">$^I = <span class="hljs-string">&quot;.bak&quot;</span>;<br><span class="hljs-keyword">while</span> (&lt;&gt;)&#123;<br><span class="hljs-regexp">s/aaa/bbb/g</span>;<br><span class="hljs-keyword">print</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>有时替换可以先使用占位符<code>\0</code>，或者chomp后使用<code>\n</code>。</p></li></ul><h2 id="其他控制结构"><a href="#其他控制结构" class="headerlink" title="其他控制结构"></a>其他控制结构</h2><ul><li><p>表达式修饰符，即可以在一行里面写上if , foreach这种。使用foreach修饰符的时候无法自选控制变量，必须使用<code>$_</code></p><p><code>print &quot;ok&quot; if $ok;</code></p></li><li><p>foreach和for其实等价，如果括号内没有分号，那么是foreach循环，如果有分号那么是for循环。</p></li><li><p>last操作符等价于break</p></li><li><p>next操作符等价于continue</p></li><li><p>redo操作符合next相似，区别在于，next会继续下一次迭代，而redo会重新执行这次迭代</p></li><li><p>带标签的块，可以让里层直接跳到外层的某个循环点</p></li><li><p>定义或操作符<code>//</code>，看着跟着注释符一样…。如果左侧的值未定义（undef），那么使用右侧的值，常用于赋默认值</p><p><code>my $last_name = $last_name&#123;$someone&#125; // &#39;(no last name)&#39;;</code></p></li></ul><h2 id="perl模块"><a href="#perl模块" class="headerlink" title="perl模块"></a>perl模块</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> File::Basename; <span class="hljs-comment"># 导入模块</span><br><span class="hljs-keyword">use</span> File::Basename <span class="hljs-keyword">qw</span>/basename/; <span class="hljs-comment"># 导入模块的特定函数</span><br>basename $name; <span class="hljs-comment">#只是使用模块内函数名</span><br>File::Basename::dirname $name; <span class="hljs-comment"># 全称使用模块函数</span><br></code></pre></td></tr></table></figure><ul><li>还有中面向对象的模块，使用的使用需要使用瘦箭头<code>-&gt;</code></li></ul><h3 id="DateTime模块"><a href="#DateTime模块" class="headerlink" title="DateTime模块"></a>DateTime模块</h3><p><a href="https://metacpan.org/release/DROLSKY/DateTime-0.31/view/lib/DateTime.pm">文档</a></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> DateTime; <br><span class="hljs-keyword">my</span> $dt = DateTime-&gt;now;<br>$ymd    = $dt-&gt;ymd;           <span class="hljs-comment"># 2002-12-06</span><br>$ymd    = $dt-&gt;ymd(<span class="hljs-string">&#x27;/&#x27;</span>);      <span class="hljs-comment"># 2002/12/06 - also date</span><br> <br>$mdy    = $dt-&gt;mdy;           <span class="hljs-comment"># 12-06-2002</span><br>$mdy    = $dt-&gt;mdy(<span class="hljs-string">&#x27;/&#x27;</span>);      <span class="hljs-comment"># 12/06/2002</span><br> <br>$dmy    = $dt-&gt;dmy;           <span class="hljs-comment"># 06-12-2002</span><br>$dmy    = $dt-&gt;dmy(<span class="hljs-string">&#x27;/&#x27;</span>);      <span class="hljs-comment"># 06/12/2002</span><br> <br>$hms    = $dt-&gt;hms;           <span class="hljs-comment"># 14:02:29</span><br></code></pre></td></tr></table></figure><h3 id="Time-Piece模块"><a href="#Time-Piece模块" class="headerlink" title="Time::Piece模块"></a>Time::Piece模块</h3><p>（5.10内置）</p><p><a href="https://metacpan.org/pod/Time::Piece">文档</a></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> Time::Piece;<br> <br><span class="hljs-keyword">my</span> $t = <span class="hljs-keyword">localtime</span>; <span class="hljs-comment"># 得到一个当前时间的对象，里面可以便捷的访问时间</span><br>$t-&gt;sec                 <span class="hljs-comment"># also available as $t-&gt;second</span><br>$t-&gt;min                 <span class="hljs-comment"># also available as $t-&gt;minute</span><br>$t-&gt;hour                <span class="hljs-comment"># 24 hour</span><br>$t-&gt;hms                 <span class="hljs-comment"># 12:34:56</span><br>$t-&gt;hms(<span class="hljs-string">&quot;.&quot;</span>)            <span class="hljs-comment"># 12.34.56</span><br></code></pre></td></tr></table></figure><h3 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h3><p>先在cpan网搜索自己需要什么模块，然后通过命令安装,<br>示例如下，第一次可能需要配置，自动即可</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">$ sudo cpan<br>cpan[<span class="hljs-number">1</span>]&gt; <span class="hljs-keyword">install </span><span class="hljs-keyword">JSON</span><br><span class="hljs-keyword"></span>cpan[<span class="hljs-number">2</span>]&gt; <span class="hljs-keyword">install </span>Text::CSV<br></code></pre></td></tr></table></figure><h2 id="文件测试"><a href="#文件测试" class="headerlink" title="文件测试"></a>文件测试</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">if</span>(-e $filename)&#123;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;xxxxxx\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/image/2022-02/27-095920-cbb6-leon.png" alt="image-20220227095918759"></p><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/image/2022-02/27-100000-d0fb-leon.png" alt="image-20220227095959828"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>git用法总结</title>
    <link href="/2020/10/14/git%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2020/10/14/git%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="git使用"><a href="#git使用" class="headerlink" title="git使用"></a>git使用</h1><blockquote><p>git 2.23之后，多了switch和restore命令，git –help已看不到checkout的踪影（还是支持）。因为checkout用法太多，语义的歧义太大了。</p><p>但是很多商业公司一直用着老旧的系统，老旧的软件，所以下面基本只会涉及checkout命令。</p></blockquote><p>[toc]</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>（1）初次配置用户名邮箱</p><figure class="highlight stylus"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;leon&quot;</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> xxx@xxx<br></code></pre></td></tr></table></figure><p>（2）解决git status中文文件名乱码</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">git config --global core.quotepath <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>（3）关闭git自动转换换行符</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">git config --global core.<span class="hljs-built_in">auto</span>crlf <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>（4）git status时忽略权限改变</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">git config core.filemode <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>（5）配置默认编辑器</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global core.editor vim</span><br>git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global merge.tool vimdiff</span><br></code></pre></td></tr></table></figure><p>（6）配置别名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global alias.st status<br>git config --global alias.co checkout<br>git config --global alias.br branch<br><span class="hljs-comment"># 简短的查看日志</span><br>git config --global alias.slog <span class="hljs-string">&#x27;log --pretty=format:&quot;%h %aN %ad %s&quot; --date=format:&quot;%Y-%m-%d %H:%M:%S&quot;&#x27;</span><br><span class="hljs-comment"># 彩色查看log</span><br>git config --global alias.clog <span class="hljs-string">&#x27;log --pretty=format:&quot;%Cred%h%Creset %Cgreen%cr%Creset %s %Cblue%aN%Creset&quot;&#x27;</span><br><span class="hljs-comment"># 图形化log</span><br>git config --global alias.cglog <span class="hljs-string">&#x27;log --graph --pretty=format:&quot;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset%n&quot; --abbrev-commit --date=relative --branches&#x27;</span><br><br>alias.calog=<span class="hljs-built_in">log</span> --graph --pretty=format:<span class="hljs-string">&quot;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset%n&quot;</span> --abbrev-commit --<span class="hljs-built_in">date</span>=relative --branches<br></code></pre></td></tr></table></figure><p>（7）配置提交注释模版</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">vi ~<span class="hljs-string">/.gitCommitTemplate</span><br>git config <span class="hljs-params">--global</span> commit.template ~<span class="hljs-string">/.gitCommitTemplate</span><br></code></pre></td></tr></table></figure><p>（8）查看现有配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --list<br><span class="hljs-comment"># 同时显示来源</span><br>git config --list --show-origin<br></code></pre></td></tr></table></figure><h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><p>创建<code>.gitignore</code>文件即可，忽略遵从如下规则</p><ul><li><code>#</code>开头的行表示注释</li><li>可以使用标准的 glob 模式匹配，它会<strong>递归</strong>地应用在整个工作区中</li><li>匹配模式可以以（&#x2F;）开头防止递归</li><li>匹配模式可以以（&#x2F;）结尾指定目录</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 忽略所有的 .a 文件</span><br>*<span class="hljs-string">.a</span><br><br><span class="hljs-comment"># 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件</span><br>!lib.a<br><br><span class="hljs-comment"># 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO</span><br><span class="hljs-string">/TODO</span><br><br><span class="hljs-comment"># 忽略任何目录下名为 build 的文件夹</span><br>build/<br><br><span class="hljs-comment"># 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt</span><br>doc/*<span class="hljs-string">.txt</span><br><br><span class="hljs-comment"># 忽略 doc/ 目录及其所有子目录下的 .pdf 文件</span><br>doc/**/*<span class="hljs-string">.pdf</span><br></code></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="git中的重要概念"><a href="#git中的重要概念" class="headerlink" title="git中的重要概念"></a>git中的重要概念</h3><h4 id="工作区、暂存区、仓库"><a href="#工作区、暂存区、仓库" class="headerlink" title="工作区、暂存区、仓库"></a>工作区、暂存区、仓库</h4><p>这是经常用到的概念，关系图如下：</p><pre><code class=" mermaid">sequenceDiagramparticipant ws as 工作区participant staged as 暂存区(staged)&lt;br/&gt;git里叫indexparticipant .git as .git目录(仓库)participant remote as 远程仓库ws -&gt;&gt; staged: git addstaged-&gt;&gt;ws: git reset &lt;file&gt;staged-&gt;&gt;.git: git commit.git-&gt;&gt;ws: git checkout.git-&gt;&gt;remote: git pushremote-&gt;&gt;.git: git fetchremote-&gt;&gt;ws: git pull</code></pre><h3 id="查看修改diff"><a href="#查看修改diff" class="headerlink" title="查看修改diff"></a>查看修改diff</h3><ul><li><p>查看当前工作区的修改(修改后还未暂存)<br><code>git diff </code></p></li><li><p>查看暂存区中的修改(已暂存，下一次commit的修改)<br><code>git diff --staged</code></p></li><li><p>查看某几个版本间修改文件列表<br><code>git diff --stat 38bb22e88660..HEAD -- . :^userspace/public/apps/lighttpd/web</code><br><code>:^</code>表示排除这个目录</p></li></ul><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看远程仓库</span><br>git remote -v<br><span class="hljs-comment"># 添加远程仓库</span><br>git remote add shortName https://github.com/paulboone/ticgit<br><span class="hljs-comment"># 从远程仓库拉取(原厂仓库的所有内容会获取下来)</span><br>git fetch<br><span class="hljs-comment"># 将提交推送到远程仓库</span><br>git push origin master<br></code></pre></td></tr></table></figure><h3 id="日志查看"><a href="#日志查看" class="headerlink" title="日志查看"></a>日志查看</h3><p><code>-p</code> 显示修改内容</p><p><code>-2</code> 显示最近两次修改</p><p><code>git log -p -2</code></p><p><code>git log --stat</code> 查看提交修改的文件统计</p><p><code>git log --since=&quot;2023-06-16 00:00:00&quot;</code> 查看从某天起迄今的日志。</p><p><strong>查看某个函数的修改记录</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">git log -L <span class="hljs-symbol">:FunctionName</span><span class="hljs-symbol">:FilePath</span><br>git log -L <span class="hljs-symbol">:lan_connect</span><span class="hljs-symbol">:users/tianyi/tylib/ty_common/system/set_bridge</span>.c<br></code></pre></td></tr></table></figure><p><strong>查看某行的修改记录</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> blame -L <span class="hljs-number">58</span>,<span class="hljs-number">100</span> file_name # <span class="hljs-number">58</span>~<span class="hljs-number">100</span> 行代码<br></code></pre></td></tr></table></figure><h4 id="双点和三点"><a href="#双点和三点" class="headerlink" title="双点和三点"></a>双点和三点</h4><p>分支多了，merge，cherry-pick混合使用，有时不清楚一个分支上究竟有哪些提交是独有的，可以通过如下命令来办。</p><p><strong>双点</strong></p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss">git <span class="hljs-built_in">log</span> foo..<span class="hljs-built_in">bar</span><br>等价于： git <span class="hljs-built_in">log</span> ^foo <span class="hljs-built_in">bar</span>, 包含<span class="hljs-built_in">bar</span>不包含foo的部分，即<span class="hljs-built_in">bar</span>特有的<br></code></pre></td></tr></table></figure><p><strong>三点</strong></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">git</span></span> <span class="hljs-built_in">log</span> foo...bar<br>等价于：包含 foo bar，但不包含二者公共部分<br></code></pre></td></tr></table></figure><p>可以通过下图看懂命令的不同</p><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/2023-12/20-155858-1f30-leon.png?x-image-process=image/quality,q_65"></p><h4 id="忽略cherry-pick，merge的提交"><a href="#忽略cherry-pick，merge的提交" class="headerlink" title="忽略cherry-pick，merge的提交"></a>忽略cherry-pick，merge的提交</h4><p>每次merge和cherry-pick都会产生新的提交，默认在使用双点，3点命令时，这些提交也会显示出来。但实际上并不希望看到这些。可通过如下参数控制。（实测双点没有效果，3点效果较好）<br><code>git log foo...bar</code>，只是打印二者所有的不同提交，看不出来谁是谁的，使用<code>--left-right</code>可以看出来哪边是哪边的</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs node-repl">git log --left-right master...experiment<br>&lt; F <br>&lt; E<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">D</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">C</span><br></code></pre></td></tr></table></figure><p><code>--no-merges</code>将不显示merge的提交<br><code>--cherry-pick</code>将会把cherry-pick的视为相同的提交<br><code>--left-only</code> <code>--right-only</code>将只显示一边的提交<br><code>--cherry-mark</code>将相同的提交用”&#x3D;”号表示，不同的用”+”号标记</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 显示foo特有的</span><br>git log <span class="hljs-params">--cherry-pick</span> <span class="hljs-params">--left-only</span> <span class="hljs-params">--no-merges</span>  foo.<span class="hljs-string">..bar</span> <br><span class="hljs-comment"># 显示bar特有的</span><br>git log <span class="hljs-params">--cherry-pick</span> <span class="hljs-params">--right-only</span> <span class="hljs-params">--no-merges</span>  foo.<span class="hljs-string">..bar</span> <br></code></pre></td></tr></table></figure><h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><p>(1) 修改刚提交的日志信息</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">git</span> <span class="hljs-string">commit</span> <span class="hljs-built_in">--amend</span> -<span class="hljs-string">m</span> <span class="hljs-string">&quot;刚修改错了&quot;</span><br></code></pre></td></tr></table></figure><p>(2) 提交时漏了文件</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">add</span> forget_file<br>git <span class="hljs-keyword">commit</span> <span class="hljs-comment">--amend -m &quot;漏了文件，重新提交&quot;</span><br></code></pre></td></tr></table></figure><p>(3) 撤销暂存区的文件（不会修改文件，只是取消文件暂存）</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">git <span class="hljs-keyword">reset</span> HEAD xxx.<span class="hljs-keyword">file</span><br></code></pre></td></tr></table></figure><p>(4) 撤销对文件的修改，会拷贝最新版本的文件覆盖当前文件</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">git checkout <span class="hljs-comment">-- xxx.file</span><br></code></pre></td></tr></table></figure><p>(5) git commit之后撤销，只撤销commit，代码修改仍在</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--soft HEAD^</span><br></code></pre></td></tr></table></figure><p><code>--soft</code> 不删除工作空间改动代码</p><p><code>--hard</code> 删除工作空间改动</p><p><code>HEAD^</code> 上一个版本，也可以写成<code>HEAD~1</code></p><p>(6) 撤销中间某次commit</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">git <span class="hljs-built_in">revert</span> commit_id<br></code></pre></td></tr></table></figure><p>执行之后会自动提交。</p><h3 id="status"><a href="#status" class="headerlink" title="status"></a>status</h3><p>（1）git status不显示Untracked的文件</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git status -uno</span><br></code></pre></td></tr></table></figure><p>（2）取消某个文件的跟踪</p><p>如下命令会删除对这个文件的跟踪，即从版本库中删除，但本地还存在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">rm</span> --cached -r <span class="hljs-built_in">dir</span><br>git commit -m <span class="hljs-string">&quot;untrack some dir&quot;</span><br></code></pre></td></tr></table></figure><p><a href="evernote:///view/11143895/s57/cf393bae-cbbf-4e33-90e5-b251cf729bbe/cf393bae-cbbf-4e33-90e5-b251cf729bbe/">git忽略已经被提交的文件 - SegmentFault 思否</a></p><p>（3）对于已经跟踪的文件，使用.gitignore文件无效，可以使用</p><p>这个命令只对本地生效，只是设置了文件未修改的标记。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">update</span>-<span class="hljs-keyword">index</span> <span class="hljs-comment">--assume-unchanged file命令</span><br></code></pre></td></tr></table></figure><p>显示哪些文件做了标记</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">git <span class="hljs-keyword">ls</span>-<span class="hljs-keyword">files</span> -v | <span class="hljs-keyword">grep</span> <span class="hljs-string">&#x27;^[[:lower:]]&#x27;</span><br>git <span class="hljs-keyword">ls</span>-<span class="hljs-keyword">files</span> -v | <span class="hljs-keyword">grep</span> <span class="hljs-string">&#x27;^h&#x27;</span><br></code></pre></td></tr></table></figure><p>撤销对这些文件的忽略</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">git <span class="hljs-keyword">update</span>-<span class="hljs-built_in">index</span> --<span class="hljs-keyword">no</span>-assume-unchanged <span class="hljs-keyword">file</span><br></code></pre></td></tr></table></figure><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 新建分支</span><br>git branch iss90<br><span class="hljs-comment"># 切换到分支</span><br>git checkout iss90<br><span class="hljs-comment"># 两个命令可以合并</span><br>git checkout -b iss90<br><br><span class="hljs-comment"># 查看分支</span><br>git branch<br><span class="hljs-comment"># 查看已合并过的分支</span><br>git branch --merged<br><br><span class="hljs-comment"># 合并分支到主线,先切换到master分支，然后合并</span><br>git checkout master<br>git merge iss90<br><br><span class="hljs-comment"># 删除分支</span><br>git branch -d iss90<br></code></pre></td></tr></table></figure><h3 id="查看未合并的分支"><a href="#查看未合并的分支" class="headerlink" title="查看未合并的分支"></a>查看未合并的分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看已合并的分支</span><br>git br --merged<br><span class="hljs-comment"># 查看未合并的分支</span><br>git br --no-merged<br><br><span class="hljs-comment"># 查看分支ft上有哪些提交没有合并到master分支上</span><br>git <span class="hljs-built_in">log</span> master..ft<br><br><span class="hljs-comment"># 忽略merge的提交，因为merge是一条单独的提交</span><br>git <span class="hljs-built_in">log</span> master..ft --no-merges<br></code></pre></td></tr></table></figure><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><h4 id="合并单条提交"><a href="#合并单条提交" class="headerlink" title="合并单条提交"></a>合并单条提交</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> cherry-pick <span class="hljs-number">62</span>ecb3<br></code></pre></td></tr></table></figure><h3 id="变基rebase"><a href="#变基rebase" class="headerlink" title="变基rebase"></a>变基rebase</h3><p>变基：修改当前分支的基底。</p><p>如果可以直接快进合并，那么不需要变基。此时变基会提示：<br><code>Current branch mesh_bug is up to date.</code></p><p>如果两边分支都有提交，那么可以变基，如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将experiment分支上的修改变基到master分支上</span><br>$ git checkout experiment<br>$ git rebase master<br>First, rewinding <span class="hljs-built_in">head</span> to replay your work on top of it...<br>Applying: added staged <span class="hljs-built_in">command</span><br><span class="hljs-comment"># 然后进行一次快进合并</span><br>$ git checkout master<br>$ git merge experiment<br></code></pre></td></tr></table></figure><p>如果要线性修改提交记录，那么可以一直使用rebase，pull代码时也是用rebase:  <code>git pull -r</code></p><h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">git remote show <span class="hljs-tag">&lt;<span class="hljs-name">remote</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="贮藏-stash"><a href="#贮藏-stash" class="headerlink" title="贮藏 stash"></a>贮藏 stash</h2><p>有时需要切换分支，但本地工作区已经很乱了，改了很多东西。想临时储存一下当前混乱的工作区。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 贮藏当前修改（只会贮藏已修改和已暂存的，未跟踪的不会贮藏）</span><br>git stash push<br><span class="hljs-comment"># 贮藏所有内容（未跟踪的也会贮藏，.gitignore忽略的文件也会贮藏，贮藏之后工作区完全干干净净）</span><br>git stash push -a -m <span class="hljs-string">&quot;msg&quot;</span><br><br><span class="hljs-comment"># 查看贮藏列表</span><br>git stash list<br><br><span class="hljs-comment"># 恢复上一次贮藏</span><br>git stash apply<br><span class="hljs-comment"># 贮藏很多次后，恢复指定贮藏</span><br>git stash apply stash@&#123;1&#125;<br><br><span class="hljs-comment"># 丢弃贮藏</span><br>git stash drop stash@&#123;1&#125;<br><br><span class="hljs-comment"># 恢复上一次贮藏并丢弃它</span><br>git stash pop<br><br><span class="hljs-comment"># 查看贮藏区的修改</span><br>git stash show stash@&#123;0&#125;<br><span class="hljs-comment"># 查看修改内容</span><br>git stash show -p stash@&#123;0&#125;<br></code></pre></td></tr></table></figure><h2 id="交互式暂存"><a href="#交互式暂存" class="headerlink" title="交互式暂存"></a>交互式暂存</h2><p>有时我们修改了一个文件的两个地方，但是想分开提交，一次只提交文件中某几处差异。这时就可以使用交互式暂存。<code>git add -i</code></p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add -i</span><br>           staged     unstaged path<br>  1:    unchanged        +0/-1 TODO<br>  2:    unchanged        +1/-1 index.html<br>  3:    unchanged        +5/-1 lib/simplegit.rb<br><br>*** Commands ***<br>  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked<br>  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp<br>What now&gt;<br></code></pre></td></tr></table></figure><p>s查看状态，p就是我们需要的命令。<br><code>p</code>后，会让你选择要操作那个文件，选择文件后，<strong>什么也不输入回车</strong>，进入下一个选择页面，这个页面会一次次的出现差异，让你选择是否暂存，输入y或者n即可。</p><h2 id="三棵树"><a href="#三棵树" class="headerlink" title="三棵树"></a>三棵树</h2><p>HEAD: 上一次提交的快照，下一次提交的父节点，相当于该分支的最后一次提交。</p><p>Index：预期的下一次提交的快照，就是暂存区</p><p>work目录：就是自己的工作区。前两个都是抽象的.git目录下的一些东西。</p><p>每一次git操作，都会有一个快照产生，三棵树都指向各自的快照。</p><p>当work和index快照指向不同，那么git status就会显示“文件已修改，但未暂存”</p><p>当index和HEAD指向不同，那么git status就会显示“文件已暂存”</p><p>当三棵树的指向全部相同，那么git status就是干净的。</p><h2 id="reset命令"><a href="#reset命令" class="headerlink" title="reset命令"></a>reset命令</h2><p>对三棵树的操作根据选项不同，区别如下(默认是mixed选项)</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-comment">--mixed               reset HEAD and index</span><br><span class="hljs-comment">--soft                reset only HEAD</span><br><span class="hljs-comment">--hard                reset HEAD, index and working tree</span><br></code></pre></td></tr></table></figure><p><strong>–soft</strong></p><p>只是修改HEAD指向，相当于撤回了commit动作。所有修改的文件都是已暂存状态。</p><p>所以可以用–soft合并之前的多个提交（压缩提交，有时在一个bug分支上修改bug，修改完后又发现引入新问题，还要修改，提交了几次，最后验收通过，为了让分支上的日志就更容易看出来具体修改，而不是几次不完善的修改，可以压缩提交）。</p><p><strong>–mixed</strong></p><p>修改HEAD和index指向，相当于撤回了commit和add动作。所有撤回的修改都存在工作区中。</p><p><strong>–hard</strong></p><p>三棵树同时修改，相当于撤回了commit,add,和本地修改。（因为之前的已经提交了，还可以通过reflog救回来）</p><p><strong>git reset [版本aa] 路径</strong></p><p>git reset 跟路径的情况下，会把index更改为reset的版本状态，把work中的文件改为HEAD中的状态（即修改撤回到work了）。如果此时直接commit，那么commit后仓库中的文件跟版本aa是一样。</p><p><strong>例子</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 回退到当前版本</span><br>git reset HEAD <br><span class="hljs-comment"># 回退到上一个版本</span><br>git reset HEAD~ <br><span class="hljs-comment"># 回退到指定版本</span><br>git reset 3f51 <br><br><span class="hljs-comment"># 撤销暂存区的文件（不会修改文件，只是取消文件暂存）</span><br>git reset HEAD xxx.file<br><br><span class="hljs-comment"># git commit之后撤销，只撤销commit，代码修改仍在</span><br>git reset --soft HEAD^<br></code></pre></td></tr></table></figure><h2 id="git-svn"><a href="#git-svn" class="headerlink" title="git-svn"></a>git-svn</h2><blockquote><p>使用git本地管理，修改推送到svn</p></blockquote><p><strong>注意：</strong></p><p>git-svn并不能使用完整的git功能，为了避免遇到麻烦，保持线性提交，不能有merge产生的提交。把master分支外的修改全部变基到master分支。</p><p>（1）clone分支，-T表示trunk目录的名字，-b表示分支的名字，这样才会把分支这些一起clone下来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git svn <span class="hljs-built_in">clone</span> file:///tmp/test-svn -T trunk -b branches -t tags<br><br><span class="hljs-comment"># 不clone所有版本，有的svn仓库提交非常多，使用-r只clone部分提交下来</span><br>git svn <span class="hljs-built_in">clone</span> http://192.168.21.225/svn/rtl-ax1800-umc/trunk rtl-ax1800-umc-git-code -r 1400:HEAD<br></code></pre></td></tr></table></figure><p>svn上分支管理有可能比较乱，没有统一命名和目录管理，所以可以不用弄这些，直接clone一个分支</p><p>（2）日常修改，然后把修改推送到svn</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add<br>git commit<br><span class="hljs-comment"># stash一下，保持本地干净，不然svn dcommit不上去</span><br>git stash push<br><span class="hljs-comment"># 默认dcommit后会拉取远程修改合并到本地</span><br>git svn dcommit<br><span class="hljs-comment"># 贮藏的修改再拉下来</span><br>git stash pop<br></code></pre></td></tr></table></figure><p>（3）如果本地在git分支上修改，需要先变基到跟踪的分支，再dcommit</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git rebase master<br>git checkout master<br>git svn dcommit<br></code></pre></td></tr></table></figure><p>（4）拉取远程修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git svn fetch<br>git rebase<br><span class="hljs-comment"># 以上两个命令也可以合成以下一个命令</span><br>git svn rebase<br></code></pre></td></tr></table></figure><p>（5）其他svn操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git svn <span class="hljs-built_in">log</span><br>git svn info<br></code></pre></td></tr></table></figure><p>（6）添加svn分支（针对不规则命名情况）<br>参考 <a href="https://www.cnblogs.com/h2zZhou/p/6136948.html">git-svn：通过git来管理svn代码</a><br>通过如下命令来添加分支<br><code>git config --add svn-remote.&lt;远程分支名称&gt;.url &lt;svn地址，要包含具体分支路径&gt;</code><br><code>git config --add svn-remote.&lt;远程分支名称&gt;.fetch :refs/remotes/&lt;远程分支名称&gt;</code><br>实例如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">git config --add svn-remote.svn<span class="hljs-regexp">/AX5410.url http:/</span><span class="hljs-regexp">/172.20.1.217/</span>svn<span class="hljs-regexp">/bcm-ax3000-ctcc/</span>branches<span class="hljs-regexp">/products/</span>FY-AX5410<br>git config --add svn-remote.svn<span class="hljs-regexp">/AX5410.fetch :refs/</span>remotes<span class="hljs-regexp">/svn/</span>AX5410<br></code></pre></td></tr></table></figure><p>然后下载分支代码</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">git svn fetch <span class="hljs-variable">&lt;远程分支名称&gt;</span>   <span class="hljs-comment">#如 git svn fetch svn/AX5410</span><br></code></pre></td></tr></table></figure><p>（7）如何同时在两个svn分支上开发</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 基于远程分支创建本地分支</span><br>git br feiyi_ui remotes/origin/feiyi_ui <br>git co feiyi_ui<br></code></pre></td></tr></table></figure><p>注意：<code>git br -vv</code>并不能看到当前分支的跟踪分支是哪个svn分支，这和git远程分支不太一样。当git svn dcommit时，它会自动去找这个本地分支是从哪个svn分支来的，自动提交到对应的svn分支。</p><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>当dcommit有冲突时，需要<code>git svn rebase</code>拉取远程修改合入本地，解决冲突后再dcommit</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># dcommit发现冲突</span><br>git svn dcommit<br><span class="hljs-comment"># 拉取svn新代码合入本地，会有冲突的文件</span><br>git svn rebase<br><span class="hljs-comment"># 查看那些文件冲突</span><br>git st<br><span class="hljs-comment"># 修改文件，解决冲突</span><br>vi xxx<br><span class="hljs-comment"># 标记冲突已解决</span><br>git add xxx<br><span class="hljs-comment"># 继续变基</span><br>git rebase --<span class="hljs-built_in">continue</span><br><span class="hljs-comment"># 提交代码</span><br>git svn dcommit<br></code></pre></td></tr></table></figure><h3 id="空目录问题"><a href="#空目录问题" class="headerlink" title="空目录问题"></a>空目录问题</h3><p>git不支持空目录权限管理，无法git add空目录，所以如果svn服务器上有空目录。使用会有一些注意点：<br>（1）git svn clone的最后一步，git会主动建立空目录，保持代码一致<br>（2）<strong>如果rm所有代码，然后git reset –hard，这时空目录会丢失</strong>。<br>（3）<strong>如果git stash -a暂存所有文件，空目录也会丢失。</strong><br>（4）<strong>恢复办法为：git svn rebase</strong>，这时空目录会重新创建。</p><p><strong>解决办法</strong><br>（1）先通过svn下载代码，然后查找空文件夹 <code>find -type d -empty</code><br>（2）在空文件夹下建一个.gitkeep（约定俗成），并提交这个空目录（视情况）</p><p><strong>删除空目录问题</strong><br>git 删除空目录传了之后，git svn dcommit并没有删除空目录。</p><h3 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h3><p>2个固定分支<br>master主分支：不做任何修改，用于merge要提交的代码，从原厂仓库拉最新代码<br>工作空间分支：提交本地化的管理型代码（gitignore,.vscode,.gitkeep），同步最新的master分支</p><p>其他特性分支：从工作空间创建，修改bug，特性开发的分支。修改完后，将修改点rebase或者merge到master。从master提交代码，</p><p>（1）git svn clone代码<br>（2）创建工作空间分支，编译<br>（3）在工作空间分支创建特性分支<br>（4）将特性分支的修改merge到master<br>（5）在master上提交，拉取远程仓库代码<br>（6）把master分支合并到特性分支</p><h3 id="修改url"><a href="#修改url" class="headerlink" title="修改url"></a>修改url</h3><p>(1)  <code>vi .git/config </code>修改url为新的url<br>(2) <code>git svn fetch</code><br>(3) <code>vi .git/config</code> 修改url为老的url<br>(4) <code>git svn rebase -l</code><br>(5)  <code>vi .git/config</code> 修改url为新的url<br>(6) <code>git svn rebase</code></p><h2 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h2><p>clean用于清理未暂存的文件，保持干净的工作区，可以代替make clean<br><code>git clean -xfd</code></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">-f, <span class="hljs-comment">--force           force</span><br>-d                    remove <span class="hljs-keyword">whole</span> <span class="hljs-built_in">directories</span><br>-x                    remove ignored <span class="hljs-built_in">files</span>, too 默认忽略的文件不会清理，-x会一并清理<br></code></pre></td></tr></table></figure><p><strong>会删除空目录，记得git svn rebase</strong></p><h2 id="github"><a href="#github" class="headerlink" title="github"></a>github</h2><h3 id="如何在github上下载某个项目的单独某个目录？"><a href="#如何在github上下载某个项目的单独某个目录？" class="headerlink" title="如何在github上下载某个项目的单独某个目录？"></a>如何在github上下载某个项目的单独某个目录？</h3><p>使用svn来下载，例如我想下载我的practice项目的hash_table目录</p><p>（1）在github上点开这个目录，浏览器地址栏可以得到这个地址</p><p><a href="https://github.com/leon0625/practice/tree/master/hash_table">https://github.com/leon0625/practice</a><a href="https://github.com/leon0625/practice/tree/master/hash_table">&#x2F;tree&#x2F;master</a>&#x2F;hash_table</p><p>（2）将地址里的tree&#x2F;master换成trunk</p><p><a href="https://github.com/leon0625/practice/trunk/hash_table">https://github.com/leon0625/practice</a><a href="https://github.com/leon0625/practice/trunk/hash_table">&#x2F;trunk</a>&#x2F;hash_table</p><p>（3）使用svn下载上面的地址</p><p>svn co <a href="https://github.com/leon0625/practice/trunk/hash_table">https://github.com/leon0625/practice</a><a href="https://github.com/leon0625/practice/trunk/hash_table">&#x2F;trunk</a>&#x2F;hash_table</p>]]></content>
    
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>valgrind使用</title>
    <link href="/2020/08/21/valgrind%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/08/21/valgrind%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="valgrind使用"><a href="#valgrind使用" class="headerlink" title="valgrind使用"></a>valgrind使用</h1><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>如下是编译armv7的版本</p><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/configure --prefix=`pwd`/</span>llm CC=<span class="hljs-regexp">/projects/</span>hnd<span class="hljs-regexp">/tools/</span>bcm<span class="hljs-regexp">/crosstools-arm-gcc-5.5-linux-4.1-glibc-2.26-binutils-2.28.1/u</span>sr<span class="hljs-regexp">/bin/</span>arm-buildroot-linux-gnueabi-gcc --host=armv7-linux<br>mkdir llm<br>make -j6<br>make install<br></code></pre></td></tr></table></figure><h3 id="打包使用"><a href="#打包使用" class="headerlink" title="打包使用"></a>打包使用</h3><p>编译出来的install目录有100多M，全部拷到设备里面内存没那么大。所以只拷贝关键的<br>bin&#x2F;valgrind 文件<br>Libexec下所有文件，然后删掉里面最大的一些可执行文件（删掉不需要用的，检查内存泄漏的话，只保留memcheck-arm-linux这个可执行文件即可，其他的库文件，xml都要保留）</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><strong>注意需要设置环境变量</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /tmp<br><span class="hljs-built_in">mkdir</span> 123<br><span class="hljs-built_in">cd</span> 123<br>tftp -gr valgrind 192.168.10.123<br>tftp -gr test_arm 192.168.10.123<br>tftp -gr libexec.tar 192.168.10.123<br>tar -xf libexec.tar <br><span class="hljs-built_in">rm</span> libexec.tar<br><span class="hljs-comment"># 下面这个目录根据实际情况修改</span><br><span class="hljs-built_in">export</span> VALGRIND_LIB=/tmp/123/libexec/valgrind<br><span class="hljs-built_in">chmod</span> +x -R ./<br>./valgrind --leak-check=full ./test_arm<br></code></pre></td></tr></table></figure><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">fun1()<br>&#123;<br><span class="hljs-type">char</span> *p=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span>);<br><span class="hljs-built_in">memset</span>(p,<span class="hljs-number">0x2</span>,<span class="hljs-number">100</span>);<br>&#125;<br><br>fun2()<br>&#123;<br><span class="hljs-type">char</span> *p=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span>);<br><span class="hljs-built_in">memset</span>(p,<span class="hljs-number">0x2</span>,<span class="hljs-number">100</span>);<br><br>fun1();<br>&#125;<br><br>main()<br>&#123;<br>fun2();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>打印如下：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs 1c">==<span class="hljs-number">1199</span>== Memcheck, a memory error detector<br>==<span class="hljs-number">1199</span>== Copyright (C) <span class="hljs-number">2002</span>-<span class="hljs-number">2017</span>, and GNU GPL&#x27;d, by Julian Seward et al.<br>==<span class="hljs-number">1199</span>== Using Valgrind-3.17.0 and LibVEX; rerun with -h for copyright info<br>==<span class="hljs-number">1199</span>== Command: ./test_arm<br>==<span class="hljs-number">1199</span>== <br>==<span class="hljs-number">1199</span>== <br>==<span class="hljs-number">1199</span>== HEAP SUMMARY:<br>==<span class="hljs-number">1199</span>==     in use at exit: 200 bytes in 2 blocks<br>==<span class="hljs-number">1199</span>==   total heap usage: 2 allocs, 0 frees, 200 bytes allocated<br>==<span class="hljs-number">1199</span>== <br>==<span class="hljs-number">1199</span>== 100 bytes in 1 blocks are definitely lost in loss record 1 of 2<br>==<span class="hljs-number">1199</span>==    at 0x<span class="hljs-number">484876</span>C: malloc (vg_replace_malloc.c:380)<br>==<span class="hljs-number">1199</span>==    by 0x<span class="hljs-number">1048</span>B: fun2 (test.c:9)<br>==<span class="hljs-number">1199</span>==    by 0x104C3: main (test.c:17)<br>==<span class="hljs-number">1199</span>== <br>==<span class="hljs-number">1199</span>== 100 bytes in 1 blocks are definitely lost in loss record 2 of 2<br>==<span class="hljs-number">1199</span>==    at 0x<span class="hljs-number">484876</span>C: malloc (vg_replace_malloc.c:380)<br>==<span class="hljs-number">1199</span>==    by 0x<span class="hljs-number">1044</span>F: fun1 (test.c:3)<br>==<span class="hljs-number">1199</span>==    by 0x104A7: fun2 (test.c:12)<br>==<span class="hljs-number">1199</span>==    by 0x104C3: main (test.c:17)<br>==<span class="hljs-number">1199</span>== <br>==<span class="hljs-number">1199</span>== LEAK SUMMARY:<br>==<span class="hljs-number">1199</span>==    definitely lost: 200 bytes in 2 blocks<br>==<span class="hljs-number">1199</span>==    indirectly lost: 0 bytes in 0 blocks<br>==<span class="hljs-number">1199</span>==      possibly lost: 0 bytes in 0 blocks<br>==<span class="hljs-number">1199</span>==    still reachable: 0 bytes in 0 blocks<br>==<span class="hljs-number">1199</span>==         suppressed: 0 bytes in 0 blocks<br>==<span class="hljs-number">1199</span>== <br>==<span class="hljs-number">1199</span>== For lists of detected and suppressed errors, rerun with: -s<br>==<span class="hljs-number">1199</span>== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)<br></code></pre></td></tr></table></figure><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>运行报错，错误如下：<br><code>valgrind setrlimit(RLIMIT_NOFILE) error: Operation not permitted</code><br>根据查资料来看貌似是valgrind的限制，如下<a href="https://stackoverflow.com/questions/52070477/setrlimit-fails-with-operation-not-permitted-when-run-under-valgrind">https://stackoverflow.com/questions/52070477/setrlimit-fails-with-operation-not-permitted-when-run-under-valgrind</a><br>不支持进程调用这个，需要在代码里面去掉这个setrlimit，我调试的进程是cm_init调用的。去掉相关代码即可。</p><h3 id="因strip运行报错"><a href="#因strip运行报错" class="headerlink" title="因strip运行报错"></a>因strip运行报错</h3><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">valgrind:</span>  Fatal <span class="hljs-keyword">error</span> at startup: a <span class="hljs-keyword">function</span> redirection<br><span class="hljs-symbol">valgrind:</span>  which <span class="hljs-built_in">is</span> mandatory <span class="hljs-keyword">for</span> this platform-tool combination<br><span class="hljs-symbol">valgrind:</span>  cannot be <span class="hljs-keyword">set</span> up.  Details <span class="hljs-keyword">of</span> the redirection are:<br><span class="hljs-symbol">valgrind:</span>  <br><span class="hljs-symbol">valgrind:</span>  A must-be-redirected <span class="hljs-keyword">function</span><br><span class="hljs-symbol">valgrind:</span>  whose name matches the pattern:      index<br><span class="hljs-symbol">valgrind:</span>  <span class="hljs-keyword">in</span> an <span class="hljs-type">object</span> <span class="hljs-keyword">with</span> soname matching:   ld-linux.so.<span class="hljs-number">3</span><br><span class="hljs-symbol">valgrind:</span>  was <span class="hljs-built_in">not</span> found whilst processing<br><span class="hljs-symbol">valgrind:</span>  symbols <span class="hljs-keyword">from</span> the <span class="hljs-type">object</span> <span class="hljs-keyword">with</span> soname: ld-linux.so.<span class="hljs-number">3</span><br><span class="hljs-symbol">valgrind:</span>  <br><span class="hljs-symbol">valgrind:</span>  Possible fixes: (<span class="hljs-number">1</span>, <span class="hljs-type">short</span> term): install glibc<span class="hljs-comment">&#x27;s debuginfo</span><br><span class="hljs-symbol">valgrind:</span>  package <span class="hljs-keyword">on</span> this machine.  (<span class="hljs-number">2</span>, longer term): ask the packagers<br><span class="hljs-symbol">valgrind:</span>  <span class="hljs-keyword">for</span> your Linux distribution <span class="hljs-keyword">to</span> please <span class="hljs-keyword">in</span> future ship a non-<br><span class="hljs-symbol">valgrind:</span>  stripped ld.so (<span class="hljs-built_in">or</span> whatever the dynamic linker .so <span class="hljs-built_in">is</span> called)<br><span class="hljs-symbol">valgrind:</span>  that exports the above-named <span class="hljs-keyword">function</span> <span class="hljs-keyword">using</span> the standard<br><span class="hljs-symbol">valgrind:</span>  calling conventions <span class="hljs-keyword">for</span> this platform.  The package you need<br><span class="hljs-symbol">valgrind:</span>  <span class="hljs-keyword">to</span> install <span class="hljs-keyword">for</span> fix (<span class="hljs-number">1</span>) <span class="hljs-built_in">is</span> called<br><span class="hljs-symbol">valgrind:</span>  <br><span class="hljs-symbol">valgrind:</span>    <span class="hljs-keyword">On</span> Debian, Ubuntu:                 libc6-dbg<br><span class="hljs-symbol">valgrind:</span>    <span class="hljs-keyword">On</span> SuSE, openSuSE, Fedora, RHEL:   glibc-debuginfo<br><span class="hljs-symbol">valgrind:</span>  <br><span class="hljs-symbol">valgrind:</span>  Note that <span class="hljs-keyword">if</span> you are debugging a <span class="hljs-number">32</span> bit process <span class="hljs-keyword">on</span> a<br><span class="hljs-symbol">valgrind:</span>  <span class="hljs-number">64</span> bit system, you will need a corresponding <span class="hljs-number">32</span> bit debuginfo<br><span class="hljs-symbol">valgrind:</span>  package (e.g. libc6-dbg:i386).<br></code></pre></td></tr></table></figure><p>这是由于ld-linux.so.3这个库被strip了，编译一个不strip的软件。<br>博通的改法是：<br>targets&#x2F;buildFS文件, 最后几行代码前添加如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># leon add, vagraind使用</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;##leon cp <span class="hljs-variable">$INSTALL_DIR</span>/lib/ld-linux.so.3 <span class="hljs-variable">$TARGETS_DIR</span>/<span class="hljs-variable">$ROOTFS</span>/lib/&quot;</span><br><span class="hljs-built_in">cp</span> <span class="hljs-variable">$INSTALL_DIR</span>/lib/ld-linux.so.3 <span class="hljs-variable">$TARGETS_DIR</span>/<span class="hljs-variable">$ROOTFS</span>/lib/<br></code></pre></td></tr></table></figure><h3 id="共享内存运行报错"><a href="#共享内存运行报错" class="headerlink" title="共享内存运行报错"></a>共享内存运行报错</h3><p>cms框架使用mdm的会共享内存，shmat报错如下</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros">[0216 19:19:32] ==<span class="hljs-attribute">15363</span>== Either way, Valgrind will now raise a SIGILL signal which will<br>[0216 19:19:32] ==<span class="hljs-attribute">15363</span>== probably kill your program.<br>[0216 19:19:33] ==<span class="hljs-attribute">15363</span>== Warning:<span class="hljs-built_in"> client </span>syscall shmat tried <span class="hljs-keyword">to</span> modify addresses 0x58800000-0x5890ffff<br>[0216 19:19:33] hgcmif::730.543<span class="hljs-keyword">:error</span>:oalShm_init:209:Could <span class="hljs-keyword">not</span> attach <span class="hljs-keyword">to</span> <span class="hljs-attribute">shmId</span>=0 at 0x58800000, <span class="hljs-attribute">error</span>=Invalid argument<br>[0216 19:19:33] <span class="hljs-built_in">Error</span> at:InitCms,77  cmsMdm_init ret[9002]<br>[0216 19:19:33] Start hgcmif ipc thread<br>[0216 19:19:35] ==<span class="hljs-attribute">15363</span>== Invalid read of size 4<br>[0216 19:19:35] ==<span class="hljs-attribute">15363</span>==    at 0x4D5832C: mdm_getObjectNodeFlags (<span class="hljs-keyword">in</span> /lib/libmdm_db.so)<br>[0216 19:19:35] ==<span class="hljs-attribute">15363</span>== <span class="hljs-built_in"> Address </span>0x0 is <span class="hljs-keyword">not</span> stack<span class="hljs-string">&#x27;d, malloc&#x27;</span>d <span class="hljs-keyword">or</span> (recently) free<span class="hljs-string">&#x27;d</span><br></code></pre></td></tr></table></figure><p>共享内存的地址是写死的，据说和valgrind的重叠了，所以不行。修改这个地址才行（改成0x58d00000就行）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MDM_SHM_ATTACH_ADDR  0x58d00000  <span class="hljs-comment">//0x58800000</span></span><br></code></pre></td></tr></table></figure><p>如果不是用的MDM_SHM_ATTACH_ADDR这个地址，同理也应当修改其他宏即可。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>只显示确认的泄漏 <code>--show-leak-kinds=definite</code>参数</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">./valgrind</span> <span class="hljs-params">--leak-check=full</span> <span class="hljs-params">--show-leak-kinds=definite</span> <span class="hljs-string">./test</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
