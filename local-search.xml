<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>reboot命令的执行过程</title>
    <link href="/2025/04/16/556b72b699c2/"/>
    <url>/2025/04/16/556b72b699c2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>reboot命令大家很熟，但是究竟是怎么reboot的，为何reboot会reboot出bug来。本文以busybox的reboot版本分析。</p></blockquote><h1 id="问题起源"><a href="#问题起源" class="headerlink" title="问题起源"></a>问题起源</h1><p>今天碰到一个问题，代码内reboot后系统有bug。命令行reboot后又没有问题。<br>追溯代码发现二者的差异，代码内实际运行的<code>reboot -f</code>命令。多了一个-f参数。这参数的区别是什么呢？</p><h1 id="busybox内的reboot流程"><a href="#busybox内的reboot流程" class="headerlink" title="busybox内的reboot流程"></a>busybox内的reboot流程</h1><h2 id="reboot命令处理"><a href="#reboot命令处理" class="headerlink" title="reboot命令处理"></a>reboot命令处理</h2><p>init&#x2F;halt.c内包含了reboot命令的实现，根据参数不同分为两种reboot。</p><ul><li><code>reboot</code><br>  给init进程或者pid 1的进程发送SIGTERM信号。如果是调用halt,poweroff命令，那么发送的SIGUSR1,SIGUSR2信号。</li><li><code>reboot -f</code><br>  直接调用c库的reboot函数。</li></ul><h2 id="init进程处理"><a href="#init进程处理" class="headerlink" title="init进程处理"></a>init进程处理</h2><p>代码在init&#x2F;init.c。SIGTERM信号的回调函数为<code>halt_reboot_pwoff</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">halt_reboot_pwoff</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *m;<br><span class="hljs-type">unsigned</span> rb;<br><br><span class="hljs-comment">/* We may call run() and it unmasks signals,</span><br><span class="hljs-comment"> * including the one masked inside this signal handler.</span><br><span class="hljs-comment"> * Testcase which would start multiple reboot scripts:</span><br><span class="hljs-comment"> *  while true; do reboot; done</span><br><span class="hljs-comment"> * Preventing it:</span><br><span class="hljs-comment"> */</span><br>reset_sighandlers_and_unblock_sigs();<br><br>run_shutdown_and_kill_processes();<br><br>m = <span class="hljs-string">&quot;halt&quot;</span>;<br>rb = RB_HALT_SYSTEM;<br><span class="hljs-keyword">if</span> (sig == SIGTERM) &#123;<br>m = <span class="hljs-string">&quot;reboot&quot;</span>;<br>rb = RB_AUTOBOOT;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sig == SIGUSR2) &#123;<br>m = <span class="hljs-string">&quot;poweroff&quot;</span>;<br>rb = RB_POWER_OFF;<br>&#125;<br>message(L_CONSOLE, <span class="hljs-string">&quot;Requesting system %s&quot;</span>, m);<br>pause_and_low_level_reboot(rb);<br><span class="hljs-comment">/* not reached */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>init进程会调用run_shutdown_and_kill_processes，这个函数如下<br>（1）运行&#x2F;etc&#x2F;inittab里面shutdown标记的程序<br>（2）给所有进程发SIGTERM信号，sync, sleep 1s<br>（3）然后给所有进程发SIGILL信号，强行杀死，再sync<br>从这儿可以看出，busybox的reboot，进程杀不死，最多等待1s。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">run_shutdown_and_kill_processes</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">/* Run everything to be run at &quot;shutdown&quot;.  This is done _prior_</span><br><span class="hljs-comment"> * to killing everything, in case people wish to use scripts to</span><br><span class="hljs-comment"> * shut things down gracefully... */</span><br>run_actions(SHUTDOWN);<br><br>message(L_CONSOLE | L_LOG, <span class="hljs-string">&quot;The system is going down NOW!&quot;</span>);<br><br><span class="hljs-comment">/* Send signals to every process _except_ pid 1 */</span><br>kill(<span class="hljs-number">-1</span>, SIGTERM);<br>message(L_CONSOLE, <span class="hljs-string">&quot;Sent SIG%s to all processes&quot;</span>, <span class="hljs-string">&quot;TERM&quot;</span>);<br>sync();<br>sleep(<span class="hljs-number">1</span>);<br><br>kill(<span class="hljs-number">-1</span>, SIGKILL);<br>message(L_CONSOLE, <span class="hljs-string">&quot;Sent SIG%s to all processes&quot;</span>, <span class="hljs-string">&quot;KILL&quot;</span>);<br>sync();<br><span class="hljs-comment">/*sleep(1); - callers take care about making a pause */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后回到halt_reboot_pwoff，里面会调用pause_and_low_level_reboot，里面就是简单的fork调用c库reboot。<br>c库的reboot实际是一个系统调用。</p><h1 id="内核的reboot系统调用"><a href="#内核的reboot系统调用" class="headerlink" title="内核的reboot系统调用"></a>内核的reboot系统调用</h1><p>代码实现在kernel&#x2F;reboot.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c">SYSCALL_DEFINE4(reboot, <span class="hljs-type">int</span>, magic1, <span class="hljs-type">int</span>, magic2, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, cmd,<br><span class="hljs-type">void</span> __user *, arg)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid_namespace</span> *<span class="hljs-title">pid_ns</span> =</span> task_active_pid_ns(current);<br><span class="hljs-type">char</span> buffer[<span class="hljs-number">256</span>];<br><span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/* We only trust the superuser with rebooting the system. */</span><br><span class="hljs-keyword">if</span> (!ns_capable(pid_ns-&gt;user_ns, CAP_SYS_BOOT))<br><span class="hljs-keyword">return</span> -EPERM;<br><br><span class="hljs-comment">/* For safety, we require &quot;magic&quot; arguments. */</span><br><span class="hljs-keyword">if</span> (magic1 != LINUX_REBOOT_MAGIC1 ||<br>(magic2 != LINUX_REBOOT_MAGIC2 &amp;&amp;<br>magic2 != LINUX_REBOOT_MAGIC2A &amp;&amp;<br>magic2 != LINUX_REBOOT_MAGIC2B &amp;&amp;<br>magic2 != LINUX_REBOOT_MAGIC2C))<br><span class="hljs-keyword">return</span> -EINVAL;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If pid namespaces are enabled and the current task is in a child</span><br><span class="hljs-comment"> * pid_namespace, the command is handled by reboot_pid_ns() which will</span><br><span class="hljs-comment"> * call do_exit().</span><br><span class="hljs-comment"> */</span><br>ret = reboot_pid_ns(pid_ns, cmd);<br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">return</span> ret;<br><br><span class="hljs-comment">/* Instead of trying to make the power_off code look like</span><br><span class="hljs-comment"> * halt when pm_power_off is not set do it the easy way.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> ((cmd == LINUX_REBOOT_CMD_POWER_OFF) &amp;&amp; !pm_power_off)<br>cmd = LINUX_REBOOT_CMD_HALT;<br><br>mutex_lock(&amp;system_transition_mutex);<br><span class="hljs-keyword">switch</span> (cmd) &#123;<br><span class="hljs-keyword">case</span> LINUX_REBOOT_CMD_RESTART:<br>kernel_restart(<span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>reboot_pid_ns函数是判断执行reboot的pid命名空间和init的pid命名空间是否一致，如果命名空间不一致（比如docker容器内reboot），那么系统层面是不会reboot的。<br>kernel_restart为核心实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">kernel_restart</span><span class="hljs-params">(<span class="hljs-type">char</span> *cmd)</span><br>&#123;<br>kernel_restart_prepare(cmd);<br>migrate_to_reboot_cpu();<br>syscore_shutdown();<br><span class="hljs-keyword">if</span> (!cmd)<br>pr_emerg(<span class="hljs-string">&quot;Restarting system\n&quot;</span>);<br><span class="hljs-keyword">else</span><br>pr_emerg(<span class="hljs-string">&quot;Restarting system with command &#x27;%s&#x27;\n&quot;</span>, cmd);<br>kmsg_dump(KMSG_DUMP_SHUTDOWN);<br>machine_restart(cmd);<br>&#125;<br>EXPORT_SYMBOL_GPL(kernel_restart);<br></code></pre></td></tr></table></figure><p>里面是一些通知链，shutdown设备等的处理。<br>然后打印出经常看到的<code>reboot: Restarting system</code></p><h2 id="疑问：为何我在其他的pid命名空间中调用reboot把整个系统重启了"><a href="#疑问：为何我在其他的pid命名空间中调用reboot把整个系统重启了" class="headerlink" title="疑问：为何我在其他的pid命名空间中调用reboot把整个系统重启了"></a>疑问：为何我在其他的pid命名空间中调用reboot把整个系统重启了</h2><blockquote><p>实验环境ubuntu 24.04</p></blockquote><p>命令如下，然后整个系统重启了</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">sudo unshare -<span class="hljs-selector-tag">p</span> <span class="hljs-attr">--mount-proc</span> -f bash<br>reboot<br></code></pre></td></tr></table></figure><p><strong>原因：</strong><br>ubuntu的reboot，实际是调用的systemctl reboot。它是通过通信的方式给systemd发的消息。systemd是我们外面的宿主机，所以整个重启了。</p><p><strong>观察：</strong><br>（1）使用busybox的reboot，系统不重启，也不杀其他进程，只有reboot进程死掉。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">sudo unshare -<span class="hljs-selector-tag">p</span> <span class="hljs-attr">--mount-proc</span> -f bash<br>busybox reboot<br></code></pre></td></tr></table></figure><p>（2）隔离mount，umount掉所有挂载，用意为阻断systemctl和systemd他们的通信。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">unshare -<span class="hljs-selector-tag">p</span> <span class="hljs-attr">--mount-proc</span> -m -f bash<br>umount -<span class="hljs-selector-tag">a</span><br>reboot<br></code></pre></td></tr></table></figure><p>发现系统不重启了，而是connect报错。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>reboot</code>是标准的重启动作。<br><code>reboot -f</code>不经过init处理，直接调用内核reboot系统调用。可能会跳过一些应用层必要的善后动作。</p><hr><div style="text-align:center;width:100%;">  <span>人生苦短，远离bug</span>  <span style="float: right;">Leon, 2025-05-06</span></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>linux命名空间简介</title>
    <link href="/2025/03/28/4ffd7d75fdff/"/>
    <url>/2025/03/28/4ffd7d75fdff/</url>
    
    <content type="html"><![CDATA[<blockquote><p>linux namespace提供了一种进程资源隔离的方法。是docker背后的技术原理。</p></blockquote><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/2025-03/28-153510-3dcb-leon.png?x-image-process=image/quality,q_65" alt="image.png"></p><ul><li>Mount Namespace - 挂载点隔离，一个空间的挂载卸载不影响另一个空间</li><li>UTS Namespace - 隔离nodename和domainname两个系统标识</li><li>IPC Namespace - 信号量，消息队列等IPC隔离</li><li>PID Namespace - pid 隔离</li><li>Network Namespace - 网络空间隔离</li><li>User Namespace - 用户、用户组隔离</li></ul><p>从下面的输出也可以看到，现在的内核还执行time，cgroup等的隔离了。</p><h1 id="查看进程的命名空间"><a href="#查看进程的命名空间" class="headerlink" title="查看进程的命名空间"></a>查看进程的命名空间</h1><p>ls -l &#x2F;proc&#x2F;{pid}&#x2F;ns</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs tcl">$ ls -l /<span class="hljs-keyword">proc</span>/self/ns<span class="hljs-title">        </span><br><span class="hljs-title">Permissions</span> Size<span class="hljs-title"> User</span> Group<span class="hljs-title"> Date</span> Modified<span class="hljs-title">    Name</span><br>lrwxrwxrwx     -<span class="hljs-title"> leon</span> leon  2025-03-28 15:39 <span class="hljs-title"> cgroup</span> -&gt;<span class="hljs-title"> cgroup:[4026531835]</span><br>lrwxrwxrwx     -<span class="hljs-title"> leon</span> leon  2025-03-28 15:39 <span class="hljs-title"> ipc</span> -&gt;<span class="hljs-title"> ipc:[4026531839]</span><br>lrwxrwxrwx     -<span class="hljs-title"> leon</span> leon  2025-03-28 15:39 <span class="hljs-title"> mnt</span> -&gt;<span class="hljs-title"> mnt:[4026531841]</span><br>lrwxrwxrwx     -<span class="hljs-title"> leon</span> leon  2025-03-28 15:39 <span class="hljs-title"> net</span> -&gt;<span class="hljs-title"> net:[4026531840]</span><br>lrwxrwxrwx     -<span class="hljs-title"> leon</span> leon  2025-03-28 15:39 <span class="hljs-title"> pid</span> -&gt;<span class="hljs-title"> pid:[4026531836]</span><br>lrwxrwxrwx     -<span class="hljs-title"> leon</span> leon  2025-03-28 15:39 <span class="hljs-title"> pid_for_children</span> -&gt;<span class="hljs-title"> pid:[4026531836]</span><br>lrwxrwxrwx     -<span class="hljs-title"> leon</span> leon  2025-03-28 15:39 <span class="hljs-title"> time</span> -&gt;<span class="hljs-title"> time:[4026531834]</span><br>lrwxrwxrwx     -<span class="hljs-title"> leon</span> leon  2025-03-28 15:39 <span class="hljs-title"> time_for_children</span> -&gt;<span class="hljs-title"> time:[4026531834]</span><br>lrwxrwxrwx     -<span class="hljs-title"> leon</span> leon  2025-03-28 15:39 <span class="hljs-title"> user</span> -&gt;<span class="hljs-title"> user:[4026531837]</span><br>lrwxrwxrwx     -<span class="hljs-title"> leon</span> leon  2025-03-28 15:39 <span class="hljs-title"> uts</span> -&gt;<span class="hljs-title"> uts:[4026531838]</span><br></code></pre></td></tr></table></figure><p>想判断两个进程是否在同一命令空间，比较上面的输出即可。<br>比较mininet（网络模拟工具）创建的进程和普通进程，发现mininet只在mnt和net上做了隔离。</p><h1 id="创建不同命名空间的进程方法"><a href="#创建不同命名空间的进程方法" class="headerlink" title="创建不同命名空间的进程方法"></a>创建不同命名空间的进程方法</h1><p><strong>函数</strong><br>clone()函数，setns()函数，unshare()函数</p><p><strong>命令</strong><br>unshare</p><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="pid隔离观察"><a href="#pid隔离观察" class="headerlink" title="pid隔离观察"></a>pid隔离观察</h2><blockquote><p>观察隔离后的ps状态</p></blockquote><p>(1) 创建一个pid，uts，mount隔离的bash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">unshare -f -p -u -m /bin/bash<br></code></pre></td></tr></table></figure><p><strong>注意：需要-f（隔离后先fork）参数，不然起bash有异常</strong>，原因可参考 <a href="https://stackoverflow.com/questions/44666700/unshare-pid-bin-bash-fork-cannot-allocate-memory">unshare –pid &#x2F;bin&#x2F;bash - fork cannot allocate memory</a></p><p>(2) 修改hostname，然后再拉一个bash，观察host变化为test了。但是外部主机的host却不会变化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@ubuntusrv:~# hostname -b <span class="hljs-built_in">test</span><br>root@ubuntusrv:~# /bin/bash<br>root@<span class="hljs-built_in">test</span>:~#<br></code></pre></td></tr></table></figure><p>此时使用ps -ef观察pid，却还是能看到和外部相同的输出，看不出隔离效果？<br>因为ps，top等命令是读的&#x2F;proc来获取的pid。目前的挂载沿用的外部主机的，所以看不出来效果。</p><p>（3）再次挂载&#x2F;proc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@<span class="hljs-built_in">test</span>:~# mount -t proc proc /proc<br></code></pre></td></tr></table></figure><p>这一步也可以通过命令行添加<code>--mount-proc</code>参数省略</p><p>（4）观察ps输出，此时看不到外面了。但是不影响外面的ps。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@<span class="hljs-built_in">test</span>:~# ps -ef<br>UID          PID    PPID  C STIME TTY          TIME CMD<br>root           1       0  0 08:29 pts/0    00:00:00 /bin/bash<br>root           9       1  0 08:29 pts/0    00:00:00 /bin/bash<br>root          20       9  0 08:30 pts/0    00:00:00 ps -ef<br></code></pre></td></tr></table></figure><h2 id="网络隔离"><a href="#网络隔离" class="headerlink" title="网络隔离"></a>网络隔离</h2><blockquote><p>隔离网络，并让隔离的进程也能上外网。</p></blockquote><p>(1) 创建一个pid,mount,uts,net隔离的bash运行环境，然后修改hostname</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@ubuntusrv:~# unshare -f -p -m -u -n --mount-proc /bin/bash<br>root@ubuntusrv:~# hostname -b test2<br>root@ubuntusrv:~# /bin/bash<br>root@test2:~# <br></code></pre></td></tr></table></figure><p>(2) 观察网络接口，路由。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@test2:~# ip addr<br>1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000<br>    <span class="hljs-built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>root@test2:~# ip r<br>root@test2:~# <br></code></pre></td></tr></table></figure><p>网络接口只有lo，路由表为空</p><p>（3）在宿主机运行，添加一对网络接口，并配置宿主机这边的桥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@ubuntusrv:~# ip <span class="hljs-built_in">link</span> add veth0 <span class="hljs-built_in">type</span> veth peer name veth1<br>root@ubuntusrv:~# ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth0 up<br><br>root@ubuntusrv:~# brctl addbr br0<br>root@ubuntusrv:~# brctl addif br0 ens33<br>root@ubuntusrv:~# brctl addif br0 veth0<br>root@ubuntusrv:~# ifconfig br0 up<br></code></pre></td></tr></table></figure><p>ens33是连接外部的物理网卡</p><p>（4）在宿主机运行 ps -ef | grep unshare，找到我们运行的unshare的pid</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">root</span>        <span class="hljs-number">1452</span>    <span class="hljs-number">1284</span>  <span class="hljs-number">0</span> <span class="hljs-number">08</span>:<span class="hljs-number">55</span> pts/<span class="hljs-number">0</span>    <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> unshare -f -p -m -u -n --mount-proc /bin/bash<br></code></pre></td></tr></table></figure><p>（5）宿主机上运行，把veth1放到隔离的网络空间中并up起来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@ubuntusrv:~# ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth1 netns 1452 up<br></code></pre></td></tr></table></figure><p>上面使用了pid</p><p>（6）隔离进程中运行，添加IP，路由</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@test2:~# ip addr add 192.168.10.99/24 dev veth1<br>root@test2:~# ip r add default via 192.168.10.1<br><br>root@test2:~# ping 223.5.5.5<br>PING 223.5.5.5 (223.5.5.5) 56(84) bytes of data.<br>64 bytes from 223.5.5.5: icmp_seq=1 ttl=115 time=7.56 ms<br></code></pre></td></tr></table></figure><p>到这里就能够ping通了。但是ping域名ping不通。因为ubuntu24.04的resolv.conf指向自己127.0.0.1:53，网络隔离后，没有人监听53了。</p><p>（7）隔离进程中修改resolv.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@test2:~# <span class="hljs-built_in">cp</span> /etc/resolv.conf /tmp/<br>root@test2:~# mount --<span class="hljs-built_in">bind</span> /tmp/resolv.conf /etc/resolv.conf <br>root@test2:~# vi /etc/resolv.conf <br>root@test2:~# <span class="hljs-built_in">cat</span> /etc/resolv.conf <br>nameserver 223.5.5.5<br>options edns0 trust-ad<br>search localdomain<br><br>root@test2:~# ping www.qq.com<br>PING ins-r23tsuuf.ias.tencent-cloud.net (112.53.42.114) 56(84) bytes of data.<br>64 bytes from 112.53.42.114: icmp_seq=1 ttl=47 time=44.4 ms<br></code></pre></td></tr></table></figure><p>我们先mount，避免修改到外部主机的内容。nameserver 改为223.5.5.5。然后就能够ping域名了。</p><h2 id="cgroup隔离"><a href="#cgroup隔离" class="headerlink" title="cgroup隔离"></a>cgroup隔离</h2><blockquote><p>内存限制实验，待完善</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@test2:~# mount -t cgroup2 none /sys/fs/cgroup<br>root@test2:~# <span class="hljs-built_in">mkdir</span> /sys/fs/cgroup/limited<br>root@test2:~# <span class="hljs-built_in">echo</span> $$ &gt; /sys/fs/cgroup/limited/cgroup.procs<br><span class="hljs-comment"># 限制20M,单位字节</span><br>root@test2:~# <span class="hljs-built_in">echo</span> 20000000 &gt; /sys/fs/cgroup/limited/memory.max<br><span class="hljs-comment"># swap限制0</span><br>root@test2:~# <span class="hljs-built_in">echo</span> 0 &gt; /sys/fs/cgroup/limited/memory.swap.max<br><span class="hljs-comment"># 使用100M内存</span><br>root@test2:~# python3 -c <span class="hljs-string">&#x27;a = &quot; &quot; * 100 * 1024 * 1024&#x27;</span><br>Killed<br></code></pre></td></tr></table></figure><hr><div style="text-align:center;width:100%;">  <span>人生苦短，远离bug</span>  <span style="float: right;">Leon, 2025-03-28</span></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mininet模拟128个客户端</title>
    <link href="/2025/03/25/4aecf8606759/"/>
    <url>/2025/03/25/4aecf8606759/</url>
    
    <content type="html"><![CDATA[<h1 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install mininet<br><span class="hljs-built_in">sudo</span> apt install openvswitch-testcontroller<br><span class="hljs-comment"># 安装dhclient，新版ubuntu已经没有dhclient了</span><br><span class="hljs-built_in">sudo</span> apt install isc-dhcp-client<br></code></pre></td></tr></table></figure><h1 id="基础命令使用"><a href="#基础命令使用" class="headerlink" title="基础命令使用"></a>基础命令使用</h1><p>先运行如下命令，创建一个两个主机连在一个交换机s1下的拓扑。</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">sudo mn</span> <span class="hljs-literal">--</span><span class="hljs-comment">topo single</span><span class="hljs-string">,</span><span class="hljs-comment">2</span> <span class="hljs-literal">--</span><span class="hljs-comment">mac</span> <span class="hljs-literal">--</span><span class="hljs-comment">switch ovsk</span><br></code></pre></td></tr></table></figure><p>另一个终端，往s1里面添加物理接口eth1u</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">sudo ovs-vsctl<span class="hljs-built_in"> add-port </span>s1 eth1u<br></code></pre></td></tr></table></figure><p>查看交换机状态</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$ sudo ovs-vsctl <span class="hljs-built_in">show</span>             <br><span class="hljs-number">0d592c85</span>-<span class="hljs-number">23b8</span>-476d-92a5-91dc52f61822<br>    Bridge s1<br>        Controller <span class="hljs-string">&quot;ptcp:6654&quot;</span><br>        Controller <span class="hljs-string">&quot;tcp:127.0.0.1:6653&quot;</span><br>            <span class="hljs-built_in">is_connected</span>: <span class="hljs-literal">true</span><br>        fail_mode: secure<br>        Port s1-eth1<br>            Interface s1-eth1<br>        Port s1<br>            Interface s1<br>                type: internal<br>        Port eth1u<br>            Interface eth1u<br>        Port s1-eth2<br>            Interface s1-eth2<br>    ovs_version: <span class="hljs-string">&quot;3.3.0&quot;</span><br></code></pre></td></tr></table></figure><p>测试h1,h2主机联通性：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">mininet&gt; h1<span class="hljs-built_in"> ping </span>h2<span class="hljs-built_in"></span><br><span class="hljs-built_in">PING </span>10.0.0.2 (10.0.0.2) 56(84) bytes of data.<br>64 bytes <span class="hljs-keyword">from</span> 10.0.0.2: <span class="hljs-attribute">icmp_seq</span>=1 <span class="hljs-attribute">ttl</span>=64 <span class="hljs-attribute">time</span>=0.982 ms<br>64 bytes <span class="hljs-keyword">from</span> 10.0.0.2: <span class="hljs-attribute">icmp_seq</span>=2 <span class="hljs-attribute">ttl</span>=64 <span class="hljs-attribute">time</span>=0.258 ms<br></code></pre></td></tr></table></figure><p>dump命令查看虚拟主机接口信息：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mininet</span>&gt; dump<br><span class="hljs-section">&lt;Host h1: h1-eth0<span class="hljs-number">:10</span>.0.0.1 pid=883513&gt;</span> <br><span class="hljs-section">&lt;Host h2: h2-eth0<span class="hljs-number">:10</span>.0.0.2 pid=883515&gt;</span> <br><span class="hljs-section">&lt;OVSSwitch s1: lo<span class="hljs-number">:127</span>.0.0.1,s1-eth1:None,s1-eth2:None pid=883520&gt;</span> <br><span class="hljs-section">&lt;OVSController c0: <span class="hljs-number">127.0.0.1:6653</span> pid=883506&gt;</span> <br></code></pre></td></tr></table></figure><p>给虚拟主机添加ip地址和路由，在mininet命令中运行</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">mininet&gt; h1<span class="hljs-built_in"> ip </span>addr <span class="hljs-built_in">add</span> 192.168.2.2/24 dev h1-eth0<br>mininet&gt; h1<span class="hljs-built_in"> ip </span>r <span class="hljs-built_in">add</span><span class="hljs-built_in"> default </span>via 192.168.2.1<br>mininet&gt; h1<span class="hljs-built_in"> ping </span>223.5.5.5<span class="hljs-built_in"></span><br><span class="hljs-built_in">PING </span>223.5.5.5 (223.5.5.5) 56(84) bytes of data.<br>64 bytes <span class="hljs-keyword">from</span> 223.5.5.5: <span class="hljs-attribute">icmp_seq</span>=1 <span class="hljs-attribute">ttl</span>=115 <span class="hljs-attribute">time</span>=9.10 ms<br>64 bytes <span class="hljs-keyword">from</span> 223.5.5.5: <span class="hljs-attribute">icmp_seq</span>=2 <span class="hljs-attribute">ttl</span>=115 <span class="hljs-attribute">time</span>=7.31 ms<br></code></pre></td></tr></table></figure><p>除了可以在mininet命令行运行程序，还可以通过xterm直接跑某个虚拟主机</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mininet&gt; xterm <span class="hljs-selector-tag">h1</span><br></code></pre></td></tr></table></figure><p>在宿主机上可以通过dump得到的pid信息，在某个host上运行程序</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">$ mnexec -a &#123;pid&#125; <span class="hljs-built_in">ip</span> a<br></code></pre></td></tr></table></figure><h1 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h1><p>有时候mininet非正常退出，会存在非常多的接口，可以执行如下命令进行清理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> mn -c<br></code></pre></td></tr></table></figure><h1 id="模拟128个客户端"><a href="#模拟128个客户端" class="headerlink" title="模拟128个客户端"></a>模拟128个客户端</h1><p>因为客户端数量多，不方便一个个执行命令。使用python脚本创建虚拟环境更方便。github上有官方的很多<a href="https://github.com/mininet/mininet/tree/master/examples">例子程序</a><br>![[client_128_dhclient.py]]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">模拟128个客户端通过dhclient获取地址</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> sys,time<br><span class="hljs-keyword">import</span> subprocess<br><br><span class="hljs-keyword">from</span> sys <span class="hljs-keyword">import</span> exit  <span class="hljs-comment"># pylint: disable=redefined-builtin</span><br><br><span class="hljs-keyword">from</span> mininet.cli <span class="hljs-keyword">import</span> CLI<br><span class="hljs-keyword">from</span> mininet.log <span class="hljs-keyword">import</span> setLogLevel, info, error<br><span class="hljs-keyword">from</span> mininet.net <span class="hljs-keyword">import</span> Mininet<br><span class="hljs-keyword">from</span> mininet.link <span class="hljs-keyword">import</span> Intf<br><span class="hljs-keyword">from</span> mininet.topo <span class="hljs-keyword">import</span> SingleSwitchTopo<br><span class="hljs-keyword">from</span> mininet.node <span class="hljs-keyword">import</span> OVSKernelSwitch<br><span class="hljs-keyword">from</span> mininet.util <span class="hljs-keyword">import</span> quietRun<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">checkIntf</span>(<span class="hljs-params"> intf </span>):<br>    <span class="hljs-string">&quot;Make sure intf exists and is not configured.&quot;</span><br>    config = quietRun( <span class="hljs-string">&#x27;ifconfig %s 2&gt;/dev/null&#x27;</span> % intf, shell=<span class="hljs-literal">True</span> )<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> config:<br>        error( <span class="hljs-string">&#x27;Error:&#x27;</span>, intf, <span class="hljs-string">&#x27;does not exist!\n&#x27;</span> )<br>        exit( <span class="hljs-number">1</span> )<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    setLogLevel( <span class="hljs-string">&#x27;info&#x27;</span> )<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">len</span>(sys.argv) &lt; <span class="hljs-number">3</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;help: <span class="hljs-subst">&#123;sys.argv[<span class="hljs-number">0</span>]&#125;</span> &#123;&#123;interface&#125;&#125; &#123;&#123;client-num&#125;&#125;&quot;</span>)<br>        exit(<span class="hljs-number">1</span>)<br><br>    intfName = sys.argv[<span class="hljs-number">1</span>]<br>    client_num = <span class="hljs-built_in">int</span>(sys.argv[<span class="hljs-number">2</span>])<br>    info( <span class="hljs-string">&#x27;*** Connecting to hw intf: %s&#x27;</span> % intfName )<br><br>    info( <span class="hljs-string">&#x27;*** Checking&#x27;</span>, intfName, <span class="hljs-string">&#x27;\n&#x27;</span> )<br>    checkIntf( intfName )<br><br>    <span class="hljs-comment"># 创建网络</span><br>    info( <span class="hljs-string">&#x27;*** Creating network\n&#x27;</span> )<br>    topo = SingleSwitchTopo(k=client_num)<br>    net =  Mininet(topo=topo, switch=OVSKernelSwitch, build=<span class="hljs-literal">True</span>, autoSetMacs=<span class="hljs-literal">True</span>, waitConnected=<span class="hljs-literal">True</span>)<br><br>    <span class="hljs-comment"># 添加物理接口</span><br>    switch = net.switches[ <span class="hljs-number">0</span> ]<br>    info( <span class="hljs-string">&#x27;*** Adding hardware interface&#x27;</span>, intfName, <span class="hljs-string">&#x27;to switch&#x27;</span>, switch.name, <span class="hljs-string">&#x27;\n&#x27;</span> )<br>    _intf = Intf( intfName, node=switch )<br><br>    net.start()<br><br>    <span class="hljs-keyword">for</span> idx,host <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(net.hosts):<br>        <span class="hljs-comment"># 动态获取IP</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;host&#125;</span> get ip...&#x27;</span>)<br>        output = host.cmd(<span class="hljs-string">&#x27;dhclient 2&gt;&amp;1&#x27;</span>)<br>        <span class="hljs-comment"># 打印两个IP地址</span><br>        <span class="hljs-built_in">print</span>(host.params[<span class="hljs-string">&#x27;ip&#x27;</span>], host.cmd(<span class="hljs-string">&quot;ip a | awk &#x27;/192/&#123;print $2&#125;&#x27;&quot;</span>).strip())<br>        <span class="hljs-comment"># 获取网关地址</span><br>        output = host.cmd(<span class="hljs-string">&quot;ip -4 r | awk &#x27;/default/&#123;print $3&#125;&#x27;&quot;</span>)<br>        gw = output.strip()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;==gw==<span class="hljs-subst">&#123;gw&#125;</span>==&quot;</span>)<br>        <span class="hljs-comment"># 一直ping 网关</span><br>        host.cmd(<span class="hljs-string">f&quot;ping <span class="hljs-subst">&#123;gw&#125;</span> &gt;/dev/null &amp;&quot;</span>)<br><br>    <span class="hljs-comment"># 执行cli命令行</span><br>    CLI( net )<br>    net.stop()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;killall dhclient...&quot;</span>)<br>    subprocess.run(<span class="hljs-string">&#x27;killall dhclient&#x27;</span>,shell=<span class="hljs-literal">True</span>)<br>    <br></code></pre></td></tr></table></figure><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>（1）mininet只是网络空间和mount进行了隔离，文件系统并没有隔离。并且mininet是以root运行的，在mininet内文件系统的修改都会反应到宿主机上。<br>（2）建议在虚拟机内使用，避免影响主机的网络环境。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>kathara应该也可以使用<a href="https://github.com/KatharaFramework/Kathara-Labs/tree/main/tutorials/python-api/getting-started">python脚本</a>来创建实验室，模拟128个客户端。但不如mininet轻量。</p><p>[[vmware 接口混杂模式]]<br><a href="https://mininet.org/walkthrough/#part-3-mininet-command-line-interface-cli-commands">官方文档</a><br><a href="https://github.com/mininet/mininet/tree/master/examples">github例子程序</a></p><hr><div style="text-align:center;width:100%;">  <span>人生苦短，远离bug</span>  <span style="float: right;">Leon, 2025-03-25</span></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>lsof使用&amp;交叉编译</title>
    <link href="/2025/03/20/15e1016500d3/"/>
    <url>/2025/03/20/15e1016500d3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>lsof是一个查看进程打开哪些文件的命令，平常使用<code>ls -l /proc/pid/fd</code>也能看。但不如lsof详细，它帮你解析了socket的连接信息等。不用自己去&#x2F;proc&#x2F;net&#x2F;tcp等里面去找了</p></blockquote><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>我当前的版本为<a href="https://github.com/lsof-org/lsof">github</a>上最新版本，约为4.99.4。<br>因为编译不过（rpc库链接找不到），我需要先做修改Configure，删除这几行，强制定义HASNORPC_H。修改如下<br><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/2025-03/20-171755-f801-leon.png?x-image-process=image/quality,q_65" alt="image.png"></p><p>然后开始配置环境变量，编译。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> LSOF_CC=/home/leon/code/hisilicon-wifi7/tmp/luofu_cu3000_release/tools/cross_toolchain/arm-mix510-linux/arm-mix510-linux/bin/arm-mix510-linux-gcc<br><span class="hljs-built_in">export</span> LSOF_INCLUDE=/home/leon/code/hisilicon-wifi7/tmp/luofu_cu3000_release/tools/cross_toolchain/arm-mix510-linux/arm-mix510-linux/target/usr/include<br>./Configure linux<br>make<br></code></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>我们看下lighttpd的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># -n 不解析主机名 -P 打印端口号数字，-p 指定pid </span><br>./lsof -nPp 3107<br></code></pre></td></tr></table></figure><p>输出如下:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">COMMAND</span>   PID USER  FD      TYPE DEVICE SIZE/<span class="hljs-literal">OFF</span>  NODE NAME<br><span class="hljs-attribute">lighttpd</span> <span class="hljs-number">3107</span> root cwd       DIR  <span class="hljs-number">31</span>,<span class="hljs-number">11</span>        <span class="hljs-number">0</span>     <span class="hljs-number">1</span> /<br><span class="hljs-attribute">lighttpd</span> <span class="hljs-number">3107</span> root rtd       DIR  <span class="hljs-number">31</span>,<span class="hljs-number">11</span>        <span class="hljs-number">0</span>     <span class="hljs-number">1</span> /<br><span class="hljs-attribute">lighttpd</span> <span class="hljs-number">3107</span> root txt       REG  <span class="hljs-number">31</span>,<span class="hljs-number">11</span>   <span class="hljs-number">515360</span>    <span class="hljs-number">79</span> /bin/lighttpd<br><span class="hljs-attribute">lighttpd</span> <span class="hljs-number">3107</span> root mem       REG  <span class="hljs-number">31</span>,<span class="hljs-number">11</span>  <span class="hljs-number">2062520</span>  <span class="hljs-number">1534</span> /usr/lib/libcrypto.so.<span class="hljs-number">1</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">lighttpd</span> <span class="hljs-number">3107</span> root mem       REG  <span class="hljs-number">31</span>,<span class="hljs-number">11</span>   <span class="hljs-number">465192</span>  <span class="hljs-number">1636</span> /usr/lib/libssl.so.<span class="hljs-number">1</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">lighttpd</span> <span class="hljs-number">3107</span> root mem       REG  <span class="hljs-number">31</span>,<span class="hljs-number">11</span>   <span class="hljs-number">366280</span>  <span class="hljs-number">1025</span> /lib/libpcre2-<span class="hljs-number">8</span>.so.<span class="hljs-number">0</span>.<span class="hljs-number">11</span>.<span class="hljs-number">0</span><br><span class="hljs-attribute">lighttpd</span> <span class="hljs-number">3107</span> root mem       REG  <span class="hljs-number">31</span>,<span class="hljs-number">11</span>   <span class="hljs-number">694008</span>   <span class="hljs-number">996</span> /lib/libc.so<br><span class="hljs-attribute">lighttpd</span> <span class="hljs-number">3107</span> root DEL       REG    <span class="hljs-number">0</span>,<span class="hljs-number">1</span>             <span class="hljs-number">18</span> /SYSV661400f7<br><span class="hljs-attribute">lighttpd</span> <span class="hljs-number">3107</span> root mem       REG  <span class="hljs-number">31</span>,<span class="hljs-number">11</span>      <span class="hljs-number">136</span>  <span class="hljs-number">1868</span> /usr/share/zoneinfo/GMT-<span class="hljs-number">8</span><br><span class="hljs-attribute">lighttpd</span> <span class="hljs-number">3107</span> root   <span class="hljs-number">0</span>u      CHR    <span class="hljs-number">1</span>,<span class="hljs-number">3</span>      <span class="hljs-number">0</span>t0    <span class="hljs-number">72</span> /dev/null<br><span class="hljs-attribute">lighttpd</span> <span class="hljs-number">3107</span> root   <span class="hljs-number">1</span>u      CHR    <span class="hljs-number">1</span>,<span class="hljs-number">3</span>      <span class="hljs-number">0</span>t0    <span class="hljs-number">72</span> /dev/null<br><span class="hljs-attribute">lighttpd</span> <span class="hljs-number">3107</span> root   <span class="hljs-number">2</span>w      CHR    <span class="hljs-number">5</span>,<span class="hljs-number">1</span>      <span class="hljs-number">0</span>t0    <span class="hljs-number">21</span> /dev/console<br><span class="hljs-attribute">lighttpd</span> <span class="hljs-number">3107</span> root   <span class="hljs-number">3</span>r      CHR    <span class="hljs-number">1</span>,<span class="hljs-number">9</span>      <span class="hljs-number">0</span>t0    <span class="hljs-number">75</span> /dev/urandom<br><span class="hljs-attribute">lighttpd</span> <span class="hljs-number">3107</span> root   <span class="hljs-number">4</span>w      REG   <span class="hljs-number">0</span>,<span class="hljs-number">21</span>        <span class="hljs-number">5</span>   <span class="hljs-number">471</span> /var/run/lighttpd.pid<br><span class="hljs-attribute">lighttpd</span> <span class="hljs-number">3107</span> root   <span class="hljs-number">5</span>u     IPv6  <span class="hljs-number">12312</span>      <span class="hljs-number">0</span>t0   TCP *:<span class="hljs-number">80</span> (LISTEN)<br><span class="hljs-attribute">lighttpd</span> <span class="hljs-number">3107</span> root   <span class="hljs-number">6</span>u     IPv4  <span class="hljs-number">12313</span>      <span class="hljs-number">0</span>t0   TCP *:<span class="hljs-number">443</span> (LISTEN)<br><span class="hljs-attribute">lighttpd</span> <span class="hljs-number">3107</span> root   <span class="hljs-number">7</span>u     IPv6  <span class="hljs-number">12314</span>      <span class="hljs-number">0</span>t0   TCP *:<span class="hljs-number">443</span> (LISTEN)<br><span class="hljs-attribute">lighttpd</span> <span class="hljs-number">3107</span> root   <span class="hljs-number">8</span>u     IPv4  <span class="hljs-number">12315</span>      <span class="hljs-number">0</span>t0   TCP *:<span class="hljs-number">80</span> (LISTEN)<br><span class="hljs-attribute">lighttpd</span> <span class="hljs-number">3107</span> root   <span class="hljs-number">9</span>w      REG   <span class="hljs-number">0</span>,<span class="hljs-number">21</span>     <span class="hljs-number">6444</span>   <span class="hljs-number">472</span> /var/log/lighttpd_error.log<br><span class="hljs-attribute">lighttpd</span> <span class="hljs-number">3107</span> root  <span class="hljs-number">10</span>u  a_inode   <span class="hljs-number">0</span>,<span class="hljs-number">10</span>        <span class="hljs-number">0</span>  <span class="hljs-number">5679</span><span class="hljs-meta"> [eventpoll:5,6,7,8,13,15,16,17,19,21]</span><br><span class="hljs-attribute">lighttpd</span> <span class="hljs-number">3107</span> root  <span class="hljs-number">11</span>r     FIFO    <span class="hljs-number">0</span>,<span class="hljs-number">9</span>      <span class="hljs-number">0</span>t0 <span class="hljs-number">12317</span> pipe<br><span class="hljs-attribute">lighttpd</span> <span class="hljs-number">3107</span> root  <span class="hljs-number">12</span>w     FIFO    <span class="hljs-number">0</span>,<span class="hljs-number">9</span>      <span class="hljs-number">0</span>t0 <span class="hljs-number">12317</span> pipe<br><span class="hljs-attribute">lighttpd</span> <span class="hljs-number">3107</span> root  <span class="hljs-number">13</span>u     IPv4 <span class="hljs-number">749320</span>      <span class="hljs-number">0</span>t0   TCP <span class="hljs-number">192.168.2.1:80</span>-&gt;<span class="hljs-number">192.168.2.238:50296</span> (ESTABLISHED)<br><span class="hljs-attribute">lighttpd</span> <span class="hljs-number">3107</span> root  <span class="hljs-number">15</span>u     IPv4 <span class="hljs-number">749326</span>      <span class="hljs-number">0</span>t0   TCP <span class="hljs-number">192.168.2.1:80</span>-&gt;<span class="hljs-number">192.168.2.238:50297</span> (ESTABLISHED)<br><span class="hljs-attribute">lighttpd</span> <span class="hljs-number">3107</span> root  <span class="hljs-number">16</span>u     IPv4 <span class="hljs-number">749333</span>      <span class="hljs-number">0</span>t0   TCP <span class="hljs-number">192.168.2.1:80</span>-&gt;<span class="hljs-number">192.168.2.238:50298</span> (ESTABLISHED)<br><span class="hljs-attribute">lighttpd</span> <span class="hljs-number">3107</span> root  <span class="hljs-number">17</span>u     IPv4 <span class="hljs-number">749378</span>      <span class="hljs-number">0</span>t0   TCP <span class="hljs-number">192.168.2.1:80</span>-&gt;<span class="hljs-number">192.168.2.123:52272</span> (ESTABLISHED)<br><span class="hljs-attribute">lighttpd</span> <span class="hljs-number">3107</span> root  <span class="hljs-number">18</span>r      REG  <span class="hljs-number">31</span>,<span class="hljs-number">11</span>   <span class="hljs-number">283176</span>   <span class="hljs-number">982</span> /home/www/static/css/vendor.<span class="hljs-number">01634</span>eab.min.css<br><span class="hljs-attribute">lighttpd</span> <span class="hljs-number">3107</span> root  <span class="hljs-number">19</span>u     IPv4 <span class="hljs-number">749383</span>      <span class="hljs-number">0</span>t0   TCP <span class="hljs-number">192.168.2.1:80</span>-&gt;<span class="hljs-number">192.168.2.123:52288</span> (ESTABLISHED)<br><span class="hljs-attribute">lighttpd</span> <span class="hljs-number">3107</span> root  <span class="hljs-number">20</span>r      REG  <span class="hljs-number">31</span>,<span class="hljs-number">11</span>      <span class="hljs-number">863</span>   <span class="hljs-number">979</span> /home/www/static/css/login.<span class="hljs-number">7</span>f3726e1.min.css<br><span class="hljs-attribute">lighttpd</span> <span class="hljs-number">3107</span> root  <span class="hljs-number">21</span>u     IPv4 <span class="hljs-number">749384</span>      <span class="hljs-number">0</span>t0   TCP <span class="hljs-number">192.168.2.1:80</span>-&gt;<span class="hljs-number">192.168.2.123:52292</span> (ESTABLISHED)<br><span class="hljs-attribute">lighttpd</span> <span class="hljs-number">3107</span> root  <span class="hljs-number">22</span>r      REG   <span class="hljs-number">0</span>,<span class="hljs-number">21</span>     <span class="hljs-number">2834</span>    <span class="hljs-number">19</span> /var/macro.js<br><span class="hljs-attribute">lighttpd</span> <span class="hljs-number">3107</span> root  <span class="hljs-number">23</span>r      REG  <span class="hljs-number">31</span>,<span class="hljs-number">11</span>     <span class="hljs-number">5923</span>   <span class="hljs-number">944</span> /home/www/js/runtime-<span class="hljs-number">08</span>e20d77.bundle.js<br><span class="hljs-attribute">lighttpd</span> <span class="hljs-number">3107</span> root  <span class="hljs-number">24</span>r      REG  <span class="hljs-number">31</span>,<span class="hljs-number">11</span>  <span class="hljs-number">1071469</span>   <span class="hljs-number">952</span> /home/www/js/vendor-c1e9f0ac.bundle.js<br><span class="hljs-attribute">lighttpd</span> <span class="hljs-number">3107</span> root  <span class="hljs-number">25</span>r      REG  <span class="hljs-number">31</span>,<span class="hljs-number">11</span>     <span class="hljs-number">2636</span>   <span class="hljs-number">934</span> /home/www/js/login-<span class="hljs-number">16</span>d40bd8.bundle.js<br><span class="hljs-attribute">lighttpd</span> <span class="hljs-number">3107</span> root  <span class="hljs-number">26</span>r      REG  <span class="hljs-number">31</span>,<span class="hljs-number">11</span>     <span class="hljs-number">3626</span>   <span class="hljs-number">912</span> /home/www/js/<span class="hljs-number">7104</span>-<span class="hljs-number">1763</span>dd2e.chunk.js<br></code></pre></td></tr></table></figure><p>FD这列表示描述符.cwd-工作目录，rtd-进程根目录，mem-映射的内存文件，DEL-已被删除但占用的文件，u-读写，r-读，w-写。<br>SIZE&#x2F;OFF这列表示大小，如果是普通文件，那么表示大小，如果是socket 0t0表示无意义。</p><p>内容非常翔实。排查socket卡住时，可以很方便的知道是哪个socket的问题。</p><hr><div style="text-align:center;width:100%;">  <span>人生苦短，远离bug</span>  <span style="float: right;">Leon, 2025-03-20</span></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>调用tzset依然无法刷新时区问题</title>
    <link href="/2025/01/09/71895efc4d6d/"/>
    <url>/2025/01/09/71895efc4d6d/</url>
    
    <content type="html"><![CDATA[<h1 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h1><p>一个程序运行时，时区信息是固定的。当外部修改时区信息后，程序并不能知道，还是用的缓存的时区。这时程序的时间就是错误的。<br>一般的解决办法是，进程内调用tzset函数，这可以刷新时区信息，使其得到正确的时间。</p><p><strong>问题在于我在程序里面调用了<code>tzset</code>，时间还是没有刷新。</strong></p><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p><strong>结论：c库代码有点问题。</strong></p><p>tzset的glibc实现里面，会先获取环境变量TZ，如果和缓存的没有区别，那么就直接返回了。关键代码（glibc2.3.3）如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br>internal_function<br><span class="hljs-title function_">tzset_internal</span> <span class="hljs-params">(always)</span><br>     <span class="hljs-type">int</span> always;<br>&#123;<br>  <span class="hljs-type">static</span> <span class="hljs-type">int</span> is_initialized;<br>  <span class="hljs-keyword">register</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *tz;<br>  <span class="hljs-keyword">register</span> <span class="hljs-type">size_t</span> l;<br>  <span class="hljs-type">char</span> *tzbuf;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> hh, mm, ss;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> whichrule;<br><br>  <span class="hljs-keyword">if</span> (is_initialized &amp;&amp; !always)<br>    <span class="hljs-keyword">return</span>;<br>  is_initialized = <span class="hljs-number">1</span>;<br><br>  <span class="hljs-comment">/* Examine the TZ environment variable.  */</span><br>  tz = getenv (<span class="hljs-string">&quot;TZ&quot;</span>);<br>  <span class="hljs-keyword">if</span> (tz == <span class="hljs-literal">NULL</span>)<br>    <span class="hljs-comment">/* No user specification; use the site-wide default.  */</span><br>    tz = TZDEFAULT;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (*tz == <span class="hljs-string">&#x27;\0&#x27;</span>)<br>    <span class="hljs-comment">/* User specified the empty string; use UTC explicitly.  */</span><br>    tz = <span class="hljs-string">&quot;Universal&quot;</span>;<br><br>  <span class="hljs-comment">/* A leading colon means &quot;implementation defined syntax&quot;.</span><br><span class="hljs-comment">     We ignore the colon and always use the same algorithm:</span><br><span class="hljs-comment">     try a data file, and if none exists parse the 1003.1 syntax.  */</span><br>  <span class="hljs-keyword">if</span> (tz &amp;&amp; *tz == <span class="hljs-string">&#x27;:&#x27;</span>)<br>    ++tz;<br><br>  <span class="hljs-comment">/* Check whether the value changes since the last run.  */</span><br>  <span class="hljs-keyword">if</span> (old_tz != <span class="hljs-literal">NULL</span> &amp;&amp; tz != <span class="hljs-literal">NULL</span> &amp;&amp; <span class="hljs-built_in">strcmp</span> (tz, old_tz) == <span class="hljs-number">0</span>)<br>    <span class="hljs-comment">/* No change, simply return.  */</span><br>    <span class="hljs-keyword">return</span>;<br>.............<br></code></pre></td></tr></table></figure><p>因为我的进程没有这个TZ环境变量(应该大部分进程都没有，我看我的ubuntu下也没有)，所以总是默认值，老的也是默认值。判断相等。直接返回了。</p><p><strong>新一点的glibc库就没有这个问题了。根据看代码，glibc &gt; 2.3.3就改了这里</strong></p><h1 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h1><p>只能曲线救国。人为设置TZ环境变量。多调用两次tzset，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">setenv(<span class="hljs-string">&quot;TZ&quot;</span>, <span class="hljs-string">&quot;UTC&quot;</span>, <span class="hljs-number">1</span>);<br>tzset();<br>unsetenv(<span class="hljs-string">&quot;TZ&quot;</span>);<br>tzset();<br></code></pre></td></tr></table></figure><p>这样就可以通过tzset里面的TZ环境变量判断。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p> <a href="https://stackoverflow.com/questions/79102501/why-does-my-timezone-not-update-in-embedded-linux">Why does my timezone not update in embedded linux?</a></p><hr><div style="text-align:center;width:100%;">  <span>人生苦短，远离bug</span>  <span style="float: right;">Leon, 2025-01-09</span></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>python虚拟环境</title>
    <link href="/2024/11/13/e7c664ef15e0/"/>
    <url>/2024/11/13/e7c664ef15e0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在升级Ubuntu 24.04之后，python pip安装包就开始报错了（error: externally-managed-environment）。问题的原因在于ubuntu 24.04对python的环境进行了强制管控。不让用户随便搞了。</p></blockquote><h1 id="为什么需要虚拟环境"><a href="#为什么需要虚拟环境" class="headerlink" title="为什么需要虚拟环境"></a>为什么需要虚拟环境</h1><p>解决项目依赖特定版本库的问题。<br>比如项目A依赖库X的1.0版本，但是项目B又是根据X库的2.0版本开发的。两个版本的X库不兼容，项目A运行，项目B就不能运行。<br>要想同时开发这两个项目，要么让他们二者使用相同的版本库，要么使用虚拟环境。</p><p>有了虚拟环境，这些就都不是问题了。</p><h1 id="安装虚拟环境"><a href="#安装虚拟环境" class="headerlink" title="安装虚拟环境"></a>安装虚拟环境</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install python3-venv <br></code></pre></td></tr></table></figure><h1 id="激活虚拟环境"><a href="#激活虚拟环境" class="headerlink" title="激活虚拟环境"></a>激活虚拟环境</h1><p>（1）进入项目目录<br>（2）先创建一个虚拟环境</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">python -m venv <span class="hljs-string">.venv</span><br></code></pre></td></tr></table></figure><p>最后一个参数.venv是虚拟环境的名字，可以随意命名，它会在当前目录创建这么一个文件夹，存放虚拟环境所需的文件<br>（3）激活虚拟环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> .venv/bin/activate<br></code></pre></td></tr></table></figure><p>激活之后看到终端的前面会带这个名字,如：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">(.venv) leon-ssd <span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><p><strong>虚拟环境中一个库也不会安装，你使用pip list可以看到是空的</strong></p><h1 id="虚拟环境中安装库"><a href="#虚拟环境中安装库" class="headerlink" title="虚拟环境中安装库"></a>虚拟环境中安装库</h1><p><strong>直接使用pip命令安装即可</strong>，都会安装到虚拟环境这个目录里面。</p><h1 id="导出当前项目的依赖库"><a href="#导出当前项目的依赖库" class="headerlink" title="导出当前项目的依赖库"></a>导出当前项目的依赖库</h1><p>虚拟环境安装完项目所需的库后，可以使用如下命令，导出项目所依赖的库列表。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">pip <span class="hljs-keyword">freeze</span> &gt; requirements.txt<br></code></pre></td></tr></table></figure><p>我们并不需要在代码库中包含虚拟环境，只需要上传这个库列表文件即可。<br>在另一台电脑上，激活虚拟环境后，可以使用如下命令，很方便的安装</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> -r requirements.txt<br></code></pre></td></tr></table></figure><h1 id="退出当前虚拟环境"><a href="#退出当前虚拟环境" class="headerlink" title="退出当前虚拟环境"></a>退出当前虚拟环境</h1><p>运行如下命令即可。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">deactivate</span><br></code></pre></td></tr></table></figure><h1 id="不想用虚拟环境？"><a href="#不想用虚拟环境？" class="headerlink" title="不想用虚拟环境？"></a>不想用虚拟环境？</h1><p>说了这么多，要是你还是不喜欢使用虚拟环境。你也不开发东西。只是用别人的脚本或者程序。怎么办呢？</p><p><strong>虚拟环境是为了解决库版本冲突和安装管理问题，不想用就得面临这些问题！</strong></p><p>不想破坏系统级的python环境，如下一些做法是稳妥的。<br>（1）使用apt安装python库，如安装requests库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install python3-requests<br></code></pre></td></tr></table></figure><p>如果apt没有这个库，那还是没有版本。<br>（2）使用pipx安装python应用。pipx不需要root权限，它为安装的应用都创建了虚拟环境。<br>第一步想安装pipx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install pipx<br>pipx ensurepath<br></code></pre></td></tr></table></figure><p>退出终端，重新打开使其生效。<br>第二步安装应用,如：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">pipx install ruff <br>ruff <span class="hljs-comment">--help</span><br></code></pre></td></tr></table></figure><p><strong>注意：pipx只是用于安装应用</strong></p><p>参考：<br><a href="https://www.freecodecamp.org/chinese/news/how-to-setup-virtual-environments-in-python/"># 如何在 Python 中创建一个虚拟环境，以及为什么需要它</a></p><hr><div style="text-align:center;width:100%;">  <span>人生苦短，远离bug</span>  <span style="float: right;">Leon, 2024-11-13</span></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>initramfs启动</title>
    <link href="/2024/10/23/709e891d88d8/"/>
    <url>/2024/10/23/709e891d88d8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>下面代码对应的内核版本：6.2</p></blockquote><h1 id="为何需要initrd-initramfs？"><a href="#为何需要initrd-initramfs？" class="headerlink" title="为何需要initrd,initramfs？"></a>为何需要initrd,initramfs？</h1><p>早期的文件系统一般只保存在一两种存储设备上，内核只需要把这些存储设备的驱动编译进内核即可。后面存储设备越来越多，把所有存储设备的驱动都编译进内核不划算。编译为模块后，这些模块怎么加载呢？linux使用udev来实现模块的自动加载。但是udev是一个应用程序，根文件系统挂载前，无法执行应用程序。所以需要一个中间过度用的文件系统。于是出现了initrd，一个小型的文件系统。</p><h1 id="initrd和initramfs区别？"><a href="#initrd和initramfs区别？" class="headerlink" title="initrd和initramfs区别？"></a>initrd和initramfs区别？</h1><p>initrd是init ram disk，initramfs是init ram file system，前者把内存模拟成磁盘，后者直接把内存模拟成文件系统。<br>initrd是linux2.4及以前的用法，早已过时。现在用的话都是initramfs，但是很多时候还在说initrd。实际上大多数情况它说的还是initramfs。</p><p>kernel启动时，处理initramfs是直接解压。处理initrd是把文件写到&#x2F;initrd.image。</p><h1 id="rootfs挂载"><a href="#rootfs挂载" class="headerlink" title="rootfs挂载"></a>rootfs挂载</h1><p><strong>这里rootfs指文件系统的名字就叫rootfs，不是root filesystem的简写。</strong><br>start_kernel–&gt;vfs_caches_init–&gt;mnt_init –&gt; init_mount_tree<br>init_mount_tree会mount rootfs</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">mnt = vfs_kern_mount(&amp;rootfs_fs_type, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;rootfs&quot;</span>, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><p>rootfs_fs_type的定义为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span> <span class="hljs-title">rootfs_fs_type</span> =</span> &#123;<br>.name= <span class="hljs-string">&quot;rootfs&quot;</span>,<br>.init_fs_context = rootfs_init_fs_context,<br>.kill_sb= kill_litter_super,<br>&#125;;<br></code></pre></td></tr></table></figure><p>它只挂载了一个空的根目录’&#x2F;‘。</p><h1 id="initramfs解压"><a href="#initramfs解压" class="headerlink" title="initramfs解压"></a>initramfs解压</h1><p>start_kernel-&gt;arch_call_rest_init–&gt;rest_init–&gt;kernel_init–&gt;kernel_init_freeable–&gt;do_basic_setup–&gt;do_initcalls–&gt;”initcall” –&gt; populate_rootfs –&gt; do_populate_rootfs–&gt;unpack_to_rootfs<br><strong>initcall在kernel_init_freeable里面，有点迷惑</strong>。</p><p>unpack_to_rootfs解压initramfs到前面挂载的根目录。<br>解压时会先判断解压算法，然后使用对应解压算法解压，解压的内容传给flush回调函数。该回调负责把内容写到rootfs文件系统。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __init <span class="hljs-title function_">do_populate_rootfs</span><span class="hljs-params">(<span class="hljs-type">void</span> *unused, <span class="hljs-type">async_cookie_t</span> cookie)</span><br>&#123;<br><span class="hljs-comment">/* Load the built in initramfs */</span> <span class="hljs-comment">//先尝试initramfs文件是否直接编译进了内核，CONFIG_INITRAMFS_SOURCE</span><br><span class="hljs-type">char</span> *err = unpack_to_rootfs(__initramfs_start, __initramfs_size);<br><span class="hljs-keyword">if</span> (err)<br>panic_show_mem(<span class="hljs-string">&quot;%s&quot;</span>, err); <span class="hljs-comment">/* Failed to decompress INTERNAL initramfs */</span><br><br><span class="hljs-keyword">if</span> (!initrd_start || IS_ENABLED(CONFIG_INITRAMFS_FORCE))<br><span class="hljs-keyword">goto</span> done;<br><br><span class="hljs-keyword">if</span> (IS_ENABLED(CONFIG_BLK_DEV_RAM))<br>printk(KERN_INFO <span class="hljs-string">&quot;Trying to unpack rootfs image as initramfs...\n&quot;</span>);<br><span class="hljs-keyword">else</span><br>printk(KERN_INFO <span class="hljs-string">&quot;Unpacking initramfs...\n&quot;</span>);<br><br><span class="hljs-comment">// 虽然入参传递的initrd，实际上内容还是处理initramfs</span><br>err = unpack_to_rootfs((<span class="hljs-type">char</span> *)initrd_start, initrd_end - initrd_start);<br><span class="hljs-keyword">if</span> (err) &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_BLK_DEV_RAM</span><br><span class="hljs-comment">// 这个才是真正的initrd处理</span><br>populate_initrd_image(err);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>printk(KERN_EMERG <span class="hljs-string">&quot;Initramfs unpacking failed: %s\n&quot;</span>, err);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br><br>done:<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If the initrd region is overlapped with crashkernel reserved region,</span><br><span class="hljs-comment"> * free only memory that is not part of crashkernel region.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (!do_retain_initrd &amp;&amp; initrd_start &amp;&amp; !kexec_free_initrd())<br>free_initrd_mem(initrd_start, initrd_end); <span class="hljs-comment">//释放这部分保留内存</span><br>initrd_start = <span class="hljs-number">0</span>;<br>initrd_end = <span class="hljs-number">0</span>;<br><br>flush_delayed_fput();<br>task_work_run();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="initramfs的起始地址哪儿的"><a href="#initramfs的起始地址哪儿的" class="headerlink" title="initramfs的起始地址哪儿的"></a>initramfs的起始地址哪儿的</h2><p>(1) 如果是把initramfs（配置CONFIG_INITRAMFS_SOURCE）编译进了内核，那么__initramfs_start，这种地址通过链接脚本可知。<br>(2) 如果initramfs是编译的单独的文件，那么会通过启动参数知道。有两种：一种是cmdline里面有，一种是引导程序把initramfs加载到内存，然后通过boot_params.hdr.ramdisk_image参数告诉内核地址和长度。</p><p><strong>保存initramfs这块内存，内核会用吗?</strong><br>比如boot阶段，传递initramfs放在0x100,长度1000。担心内核在使用内存时，去写了这片内存。<br>应该不会。boot应该给内核传递了，哪些内存已经被使用了。如我x86的打印：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">BIOS-provided physical RAM map:<br>BIOS-e820: [mem <span class="hljs-number">0x0000000000000000</span>-<span class="hljs-number">0x000000000009fbff</span>] usable<br>BIOS-e820: [mem <span class="hljs-number">0x000000000009fc00</span>-<span class="hljs-number">0x000000000009ffff</span>] reserved<br>BIOS-e820: [mem <span class="hljs-number">0x00000000000f0000</span>-<span class="hljs-number">0x00000000000fffff</span>] reserved<br>BIOS-e820: [mem <span class="hljs-number">0x0000000000100000</span>-<span class="hljs-number">0x0000000007fdffff</span>] usable<br>BIOS-e820: [mem <span class="hljs-number">0x0000000007fe0000</span>-<span class="hljs-number">0x0000000007ffffff</span>] reserved<br>BIOS-e820: [mem <span class="hljs-number">0x00000000fffc0000</span>-<span class="hljs-number">0x00000000ffffffff</span>] reserved<br>.....<br>.....<br><span class="hljs-symbol">RAMDISK:</span> [mem <span class="hljs-number">0x07c7c000</span>-<span class="hljs-number">0x07fdffff</span>]<br>.....<br>.....<br>Freeing initrd memory: 3472K<br></code></pre></td></tr></table></figure><p>bios标记了<code>[mem 0x0000000000100000-0x0000000007fdffff]</code> 为usable，表示已经映射了物理地址，已使用，而ramdisk就处在这块内存上。<br>在initrd初始化完成后（已经解压到rootfs），就会调用free_initrd_mem，标记这块内存内核可以使用了。</p><hr><div style="text-align:center;width:100%;">  <span>人生苦短，远离bug</span>  <span style="float: right;">Leon, 2024-10-23</span></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>linux进程组，会话，控制终端关系</title>
    <link href="/2024/06/09/9f0cd45aea89/"/>
    <url>/2024/06/09/9f0cd45aea89/</url>
    
    <content type="html"><![CDATA[<h1 id="从思考题开始"><a href="#从思考题开始" class="headerlink" title="从思考题开始"></a>从思考题开始</h1><p>先打开一个终端，运行如下命令：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ ping www<span class="hljs-selector-class">.baidu</span><span class="hljs-selector-class">.com</span> &amp;<br>$ (ping www<span class="hljs-selector-class">.qq</span><span class="hljs-selector-class">.com</span> &amp;)<br></code></pre></td></tr></table></figure><p>我们可以看到两个进程都在后台运行，ping结果都打印到当前终端。<br>如果此时我关闭当前终端，这两个ping程序会如何。</p><p><strong>结论：</strong><br>ping baidu会停止。<br>ping qq会持续运行，但是没有输出。</p><h1 id="进程组、会话、控制终端"><a href="#进程组、会话、控制终端" class="headerlink" title="进程组、会话、控制终端"></a>进程组、会话、控制终端</h1><h2 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h2><p>每个进程都属于一个进程组，进程组是一个或多个进程的集合。进程组一般也可理解为作业。<br>进程组有一个组长进程，组长进程的ID也是进程组ID。组长创建该组中的进程后可以退出，进程组中只要有一个进程存在，进程组就存在，和组长进程是否退出无关。</p><h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p>会话由一个或多个进程组组成。进程可以调用setsid函数建立一个新的会话。<br>调用setsid的进程如果不是一个进程组的组长，那么创建会话成功，否则失败。所以创建守护进程前会先fork，然后在子进程中调用setsid。<br>setsid创建新会话成功后，它会做如下的事情：<br>（1）该进程新会话的会话首进程（session leader）<br>（2）该进程成为一个新进程组的组长进程。<br>（3）<strong>该进程脱离控制终端</strong>。</p><h2 id="控制终端"><a href="#控制终端" class="headerlink" title="控制终端"></a>控制终端</h2><p>（1）一个会话可以有一个控制终端，这个控制终端通常是终端设备（终端登录），或者伪终端设备（网络登录）。<br>（2）建立与终端连接的会话首进程成为控制进程<br>（3）一个会话中的进程组分为前台进程组和后台进程组<br>（4）<strong>一个会话如果有控制终端，那么它是一个前台进程组</strong>，其他的为后台进程组<br>（5）终端发出的信号（如ctrl + c， ctrl + z）将送到前台进程组的所有进程</p><h2 id="后台进程组与控制终端"><a href="#后台进程组与控制终端" class="headerlink" title="后台进程组与控制终端"></a>后台进程组与控制终端</h2><p>后台进程组如何与控制终端交互呢？<br>如果<strong>后台进程组要从终端读取输入，那么会产生SIGTTIN信号</strong>，默认动作时暂停该进程。串口会有打印，表明该进程已暂停。我们可通过作业控制把该进程放回前台。<br>如下：（fg是作业控制命令）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">read</span> &amp;      <br>[1] 72715<br>[1]  + 72715 suspended (<span class="hljs-built_in">tty</span> input)  <span class="hljs-built_in">read</span>                                                                                                                                                                            <br>$ <span class="hljs-built_in">fg</span>     <br>[1]  + 72715 continued  <span class="hljs-built_in">read</span><br>fdasfdsf<br></code></pre></td></tr></table></figure><p>如果后台进程要从终端输出，默认会直接输出到会话的控制终端。如果会话禁止了后台作业输出至控制终端（命令：stty tostop），那么进程会收到SIGTTOU信号，默认动作是暂停。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">stty</span> tostop <br>$ <span class="hljs-built_in">echo</span> 123 &amp;<br>[3] 75041<br>[3]  + 75041 suspended (<span class="hljs-built_in">tty</span> output)  <span class="hljs-built_in">echo</span> 123                                                                                                                                                                       <br>$ <span class="hljs-built_in">fg</span><br>[3]    75041 continued  <span class="hljs-built_in">echo</span> 123<br>123<br></code></pre></td></tr></table></figure><p><em>stty  -tostop 可以开启后台作业输出到控制终端，默认就是开启的</em><br>如果**后台进程组要设置控制终端，那么也会遇到SIGTTOU信号(也有可能是SIGSTOP信号)**，默认动作也是暂停该进程。<br>比如top命令就会设置终端。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">$ top -n1 &gt; /dev/<span class="hljs-literal">null</span> &amp;<br><span class="hljs-string">[3]</span> <span class="hljs-number">88773</span><br><span class="hljs-string">[3]</span>  + <span class="hljs-number">88773</span> suspended (signal)  top -n1 &gt; /dev/<span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><h2 id="孤儿进程组"><a href="#孤儿进程组" class="headerlink" title="孤儿进程组"></a>孤儿进程组</h2><p>进程组中的所有进程的父进程都不在所属的会话中，那么这个进程组就是孤儿进程组。<br>因为孤儿进程组的父进程（init进程，ubuntu中为systemd进程）不在它所属的会话中，所以如果孤儿进程暂停后，会导致没有人去唤醒它。所以给孤儿进程发送SIGTTIO，SIGTTOU，SIGSTOP都没有意义。</p><ul><li><strong>如果孤儿进程要读终端、设置终端、关闭后台进程组输出到会话的控制终端后写终端，都会产生EIO错误，而不会产生信号使进程暂停。</strong></li></ul><h2 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h2><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/2024-06/09-111032-e9cc-leon.png?x-image-process=image/quality,q_65"></p><ul><li>写终端产生SIGTTOU这里指：设置终端或者关闭后台进程组输出到会话的控制终端后写终端。</li></ul><h1 id="回到开头"><a href="#回到开头" class="headerlink" title="回到开头"></a>回到开头</h1><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ ping www<span class="hljs-selector-class">.baidu</span><span class="hljs-selector-class">.com</span> &amp;<br>$ (ping www<span class="hljs-selector-class">.qq</span><span class="hljs-selector-class">.com</span> &amp;)<br></code></pre></td></tr></table></figure><p>运行两条ping之后的进程关系如下：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">$ ps -o tty,pid,ppid,pgid,sid,cmd<br>TT           PID    PPID    PGID     SID CMD<br>pts/1     <span class="hljs-number"> 31034 </span> <span class="hljs-number"> 11477 </span> <span class="hljs-number"> 31034 </span> <span class="hljs-number"> 31034 </span>zsh<br>pts/1     <span class="hljs-number"> 74391 </span> <span class="hljs-number"> 31034 </span> <span class="hljs-number"> 74391 </span> <span class="hljs-number"> 31034 </span>zsh<br>pts/1     <span class="hljs-number"> 74479 </span> <span class="hljs-number"> 31034 </span> <span class="hljs-number"> 74479 </span> <span class="hljs-number"> 31034 </span>zsh<br>pts/1     <span class="hljs-number"> 92787 </span> <span class="hljs-number"> 31034 </span> <span class="hljs-number"> 92787 </span> <span class="hljs-number"> 31034 </span>ping www.baidu.com<br>pts/1     <span class="hljs-number"> 92839 </span>  <span class="hljs-number"> 6653 </span> <span class="hljs-number"> 92838 </span> <span class="hljs-number"> 31034 </span>ping www.qq.com<br>pts/1     <span class="hljs-number"> 93025 </span> <span class="hljs-number"> 31034 </span> <span class="hljs-number"> 93025 </span> <span class="hljs-number"> 31034 </span>ps -o tty,pid,ppid,pgid,sid,cmd<br></code></pre></td></tr></table></figure><p>两条ping命令都属于同一个会话31034，都拥有控制终端pts&#x2F;1。两者属于不同的后台进程组。ping qq的父进程是6653（systemd）,它所在的进程组为孤儿进程组。<br><strong>关闭当前终端后，zsh退出产生SIGHUP信号给子进程，子进程链式产生SIGHUP给子子进程，SIGHUP默认动作是退出，所以当前会话内有亲缘关系的进程都会退出。</strong><br><strong>因为ping qq进程的父进程不在当前会话内，所以它不会退出</strong>。<br>另外开一个终端，查看到ping qq进程如下：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tap">TT           PID    PPID    PGID     SID CMD<br>?         <span class="hljs-number"> 92839 </span>  <span class="hljs-number"> 6653 </span> <span class="hljs-number"> 92838 </span> <span class="hljs-number"> 31034 </span>ping www.qq.com<br></code></pre></td></tr></table></figure><p>只有关联的终端没有了，strace跟踪它的话，会发现，它的输出都会产生EIO错误。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">write</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;64 bytes from 240e:97c:2f:2::4c &quot;</span>..., <span class="hljs-number">86</span>) = -<span class="hljs-number">1</span> EIO (输入/输出错误)<br></code></pre></td></tr></table></figure><h1 id="编写守护进程"><a href="#编写守护进程" class="headerlink" title="编写守护进程"></a>编写守护进程</h1><p>守护进程的主要意义在于摆脱控制终端的影响。<br>一般的编写方式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syslog.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br><br>    <span class="hljs-type">pid_t</span> pid, sid;<br>    <span class="hljs-type">int</span> i;<br><br>    openlog(<span class="hljs-string">&quot;daemon_syslog&quot;</span>, LOG_PID, LOG_DAEMON);<br>    syslog(LOG_INFO, <span class="hljs-string">&quot;run...&quot;</span>);<br><br>    pid = fork(); <span class="hljs-comment">// 第1步</span><br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);              <span class="hljs-comment">// 父进程第一次退出</span><br><br>    <span class="hljs-keyword">if</span> ((sid = setsid()) &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 第2步</span><br>    &#123;<br>        syslog(LOG_ERR, <span class="hljs-string">&quot;%s\n&quot;</span>, <span class="hljs-string">&quot;setsid&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 第3步 第二次父进程退出</span><br>    <span class="hljs-keyword">if</span> ((pid = fork()) &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> ((sid = chdir(<span class="hljs-string">&quot;/&quot;</span>)) &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 第4步</span><br>    &#123;<br>        syslog(LOG_ERR, <span class="hljs-string">&quot;%s\n&quot;</span>, <span class="hljs-string">&quot;chdir&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    umask(<span class="hljs-number">0</span>); <span class="hljs-comment">// 第5步</span><br>    <span class="hljs-comment">// 第6步：关闭继承的文件描述符</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; getdtablesize(); i++)<br>    &#123;<br>        close(i);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">// do_something();</span><br>    &#125;<br>    closelog();<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>讲解：</p><ul><li>因为守护进程没有控制终端，标准输入输出都会关闭， 所以一般采用syslog进行输出。</li><li>第一次fork，可以确保进程不是进程组的组长进程。这是调用setsid的前提。</li><li>setsid可以脱离当前的控制终端，创建新的会话，但是当前进程为会话的首进程。</li><li>为防止程序再次手动打开的终端成为控制终端，我们进行了第二次fork。因为会话首进程打开的终端才有可能变为控制终端。这一步也可以省略。</li><li>更改工作目录为’&#x2F;‘，避免当前工作在其他目录上（如usb目录），导致挂载的文件系统无法卸载。</li><li>设置umask，继承的umask可能不是我们想要的。</li><li>关闭所有继承的描述符。</li></ul><p>如上步骤创建守护进程看起来很长，有一个库函数daemon可以简化。</p><h2 id="daemon函数"><a href="#daemon函数" class="headerlink" title="daemon函数"></a>daemon函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">daemon</span><span class="hljs-params">(<span class="hljs-type">int</span> nochdir, <span class="hljs-type">int</span> noclose)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>nochdir如果为0，则将工作目录设置为’&#x2F;‘。否则不会更改。</li><li>noclose如果为0，则将标准输入，标准输出，标准错误输出重定向到&#x2F;dev&#x2F;null。否则不会更改。</li></ul><p><strong>注意：</strong><br>根据MAN文档说明，GNU C库的daemon实现来自BSD，它只fork一次。而不是fork两次。即调用返回后，当前进程是新会话的首进程。在遵循 System V 语义的系统（例如 Linux）上，这意味着如果守护程序打开的终端还不是另一个会话的控制终端，则该终端将无意中成为守护程序的控制终端。</p><hr><div style="text-align:center;width:100%;">  <span>人生苦短，远离bug</span>  <span style="float: right;">Leon, 2024-06-09</span></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>cmake执行命令详解</title>
    <link href="/2024/06/05/70a19a46ac1b/"/>
    <url>/2024/06/05/70a19a46ac1b/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文介绍add_custom_target和add_custom_command和execute_process命令。</p></blockquote><p>cmake构建可粗分为配置、生成阶段和构建阶段。配置、生成阶段。</p><h1 id="配置阶段时执行命令"><a href="#配置阶段时执行命令" class="headerlink" title="配置阶段时执行命令"></a>配置阶段时执行命令</h1><h2 id="execute-process"><a href="#execute-process" class="headerlink" title="execute_process"></a>execute_process</h2><p>原型如下：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs inform7">execute_process(COMMAND &lt;cmd1&gt; <span class="hljs-comment">[&lt;arguments&gt;]</span><br>                <span class="hljs-comment">[COMMAND &lt;cmd2&gt; <span class="hljs-comment">[&lt;arguments&gt;]</span>]</span>...<br>                <span class="hljs-comment">[WORKING_DIRECTORY &lt;directory&gt;]</span>  工作目录<br>                <span class="hljs-comment">[TIMEOUT &lt;seconds&gt;]</span> 超时时间<br>                <span class="hljs-comment">[RESULT_VARIABLE &lt;variable&gt;]</span><br>                <span class="hljs-comment">[RESULTS_VARIABLE &lt;variable&gt;]</span><br>                <span class="hljs-comment">[OUTPUT_VARIABLE &lt;variable&gt;]</span> 标准输出变量<br>                <span class="hljs-comment">[ERROR_VARIABLE &lt;variable&gt;]</span> 错误输出道变量<br>                <span class="hljs-comment">[INPUT_FILE &lt;file&gt;]</span><br>                <span class="hljs-comment">[OUTPUT_FILE &lt;file&gt;]</span><br>                <span class="hljs-comment">[ERROR_FILE &lt;file&gt;]</span><br>                <span class="hljs-comment">[OUTPUT_QUIET]</span><br>                <span class="hljs-comment">[ERROR_QUIET]</span><br>                <span class="hljs-comment">[COMMAND_ECHO &lt;where&gt;]</span><br>                <span class="hljs-comment">[OUTPUT_STRIP_TRAILING_WHITESPACE]</span><br>                <span class="hljs-comment">[ERROR_STRIP_TRAILING_WHITESPACE]</span><br>                <span class="hljs-comment">[ENCODING &lt;name&gt;]</span> 输出编码<br>                <span class="hljs-comment">[ECHO_OUTPUT_VARIABLE]</span><br>                <span class="hljs-comment">[ECHO_ERROR_VARIABLE]</span><br>                <span class="hljs-comment">[COMMAND_ERROR_IS_FATAL &lt;ANY|LAST&gt;]</span>)<br></code></pre></td></tr></table></figure><p><strong>注意</strong><br>（1）当有多个COMMAND时，命令会以管道的形式组合起来<br>（2）虽然多个命令会以管道连接，但是<strong>命令的执行是并性的</strong>。例如写三个sleep 3的命令，配置阶段整个只会睡眠3s，而不是9s。<br>（3）如果要顺序执行多个命令，可多次调用execute_process命令，且每一个命令中仅使用一个COMMAND参数指定一个命令。<br>（4）如果想要命令既能输出到终端中，又可以存入变量中，那么就需要设置下面这两个参数ECHO_OUTPUT_VARIABLE，ECHO_ERROR_VARIABLE<br>（5）要删除命令输出结尾处的空白，可以设置OUTPUT_STRIP_TRAILING_WHITESPACE<br>（6）<strong>命令只在配置时运行</strong>，构建时不会运行。即修改c源代码，make时不会运行命令。但是修改CMakeLists.txt后，会重新配置，它才会运行。<br>（7）执行awk，用双引号包裹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">COMMAND /bin/bash -c <span class="hljs-string">&quot;awk &#x27;/^#/&#123;printf \&quot;-Wl,--wrap=%s \&quot;, <span class="hljs-variable">$2</span>&#125;&#x27; <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/impl_list.txt&quot;</span><br></code></pre></td></tr></table></figure><p><strong>举例：将当前日期存入变量</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 把程序结果输出到一个变量</span><br><span class="hljs-keyword">execute_process</span>(<span class="hljs-keyword">COMMAND</span> date OUTPUT_VARIABLE cur_data)<br><span class="hljs-comment"># 打印这个变量</span><br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;cur_data: $&#123;cur_data&#125;&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="构建阶段执行命令"><a href="#构建阶段执行命令" class="headerlink" title="构建阶段执行命令"></a>构建阶段执行命令</h2><h2 id="add-custom-target"><a href="#add-custom-target" class="headerlink" title="add_custom_target"></a>add_custom_target</h2><p>[官方文档][<a href="https://cmake.org/cmake/help/latest/command/add_custom_target.html#add-custom-target]">https://cmake.org/cmake/help/latest/command/add_custom_target.html#add-custom-target]</a></p><p>add_custom_target用于指定类似makefile里面的伪目标，它不生成文件，而且cmake也认为它一直是过时的，即如果有目标依赖它，它总是会执行。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs inform7">add_custom_target(Name <span class="hljs-comment">[ALL]</span> <span class="hljs-comment">[command1 <span class="hljs-comment">[args1...]</span>]</span><br>                  <span class="hljs-comment">[COMMAND command2 <span class="hljs-comment">[args2...]</span> ...]</span><br>                  <span class="hljs-comment">[DEPENDS depend depend depend ... ]</span><br>                  <span class="hljs-comment">[BYPRODUCTS <span class="hljs-comment">[files...]</span>]</span><br>                  <span class="hljs-comment">[WORKING_DIRECTORY dir]</span><br>                  <span class="hljs-comment">[COMMENT comment]</span><br>                  <span class="hljs-comment">[JOB_POOL job_pool]</span><br>                  <span class="hljs-comment">[JOB_SERVER_AWARE &lt;bool&gt;]</span><br>                  <span class="hljs-comment">[VERBATIM]</span> <span class="hljs-comment">[USES_TERMINAL]</span><br>                  <span class="hljs-comment">[COMMAND_EXPAND_LISTS]</span><br>                  <span class="hljs-comment">[SOURCES src1 <span class="hljs-comment">[src2...]</span>]</span>)<br></code></pre></td></tr></table></figure><p><strong>注意：</strong><br>（1）默认情况下，没有任何目标依赖于自定义目标，换句话说，它不会被触发执行（除非手动指定构建它：cmake –build . –target yourtarget）.<br>因此它一般与add_dependencies，add_custom_command结合起来使用。<br>（2）添加ALL参数后，这个目标会添加到all的依赖里面。<br>（3）<strong>只要有人依赖它，命令就总是执行，不管DEPENDS是否更新</strong><br>（4）指定VERBATIM参数后，CMake会针对不同构建系统将&lt;命令行参数&gt;自动转义，以确保最终调用的命令行参数与该命令参数一致。推荐始终指定VERBATIM参数<br>（5）所有的命令公用一个工作目录，要不同的命令使用不同的目录，要借助<code>$&#123;CMAKE_COMMAND&#125; -E chdir</code>命令来执行</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_custom_target</span>(<span class="hljs-keyword">test</span><br>    <span class="hljs-keyword">COMMAND</span> <span class="hljs-variable">$&#123;CMAKE_COMMAND&#125;</span> -E chdir /etc pwd<br>    <span class="hljs-keyword">COMMAND</span> <span class="hljs-variable">$&#123;CMAKE_COMMAND&#125;</span> -E chdir /tmp pwd<br>)<br></code></pre></td></tr></table></figure><p>（6）设置命令执行的环境变量也可通过<code>$&#123;CMAKE_COMMAND&#125; -E env AA=aa</code>指定</p><p><strong>举例-解压配置代码</strong><br>有时需要在编译前先下载源码</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_custom_target</span>(pre_build<br>    <span class="hljs-keyword">COMMAND</span> tar -xf yourcode.tar.gz<br>    <span class="hljs-keyword">COMMAND</span> &#123;CMAKE_COMMAND&#125; -E chdir yourcode ./configure<br>)<br><span class="hljs-keyword">add_executable</span>(<span class="hljs-keyword">test</span> main.c)<br><span class="hljs-keyword">add_dependencies</span>(<span class="hljs-keyword">test</span> pre_build)<br></code></pre></td></tr></table></figure><h2 id="add-custom-command"><a href="#add-custom-command" class="headerlink" title="add_custom_command"></a>add_custom_command</h2><p><a href="https://cmake.org/cmake/help/latest/command/add_custom_command.html#command:add_custom_command">官方文档</a></p><h3 id="作用1–生成构建所需文件"><a href="#作用1–生成构建所需文件" class="headerlink" title="作用1–生成构建所需文件"></a>作用1–生成构建所需文件</h3><p>生成文件需要指定OUTPUT，它的参数如下</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs inform7">add_custom_command(OUTPUT output1 <span class="hljs-comment">[output2 ...]</span> 生成的文件<br>                   COMMAND command1 <span class="hljs-comment">[ARGS]</span> <span class="hljs-comment">[args1...]</span><br>                   <span class="hljs-comment">[COMMAND command2 <span class="hljs-comment">[ARGS]</span> <span class="hljs-comment">[args2...]</span> ...]</span><br>                   <span class="hljs-comment">[MAIN_DEPENDENCY depend]</span><br>                   <span class="hljs-comment">[DEPENDS <span class="hljs-comment">[depends...]</span>]</span>  依赖<br>                   <span class="hljs-comment">[BYPRODUCTS <span class="hljs-comment">[files...]</span>]</span><br>                   <span class="hljs-comment">[IMPLICIT_DEPENDS &lt;lang1&gt; depend1</span><br><span class="hljs-comment">                                    <span class="hljs-comment">[&lt;lang2&gt; depend2]</span> ...]</span><br>                   <span class="hljs-comment">[WORKING_DIRECTORY dir]</span><br>                   <span class="hljs-comment">[COMMENT comment]</span><br>                   <span class="hljs-comment">[DEPFILE depfile]</span><br>                   <span class="hljs-comment">[JOB_POOL job_pool]</span><br>                   <span class="hljs-comment">[JOB_SERVER_AWARE &lt;bool&gt;]</span><br>                   <span class="hljs-comment">[VERBATIM]</span> <span class="hljs-comment">[APPEND]</span> <span class="hljs-comment">[USES_TERMINAL]</span><br>                   <span class="hljs-comment">[COMMAND_EXPAND_LISTS]</span><br>                   <span class="hljs-comment">[DEPENDS_EXPLICIT_ONLY]</span>)<br></code></pre></td></tr></table></figure><p><strong>注意：</strong><br>（1）该命令仅用于定义如何生成文件，但生成规则对应的命令并不会立即执行，因此文件也不会在命令调用后立即生成。<strong>只有当该命令指定的&lt;生成文件&gt;在构建过程中被引用时</strong>，这些生成规则对应的命令才会执行，文件才会被生成<br>（2）BYPRODUCTS用于指定副生成文件，主生成的文件和副生成的文件在执行make clean时都会被删除</p><p><strong>举例：生成编译所需的c文件：</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_custom_command</span>(<br>  OUTPUT out.c<br>  <span class="hljs-keyword">COMMAND</span> someTool -i <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/in.txt -o out.c<br>  DEPENDS <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/in.txt)<br><span class="hljs-keyword">add_library</span>(myLib out.c)<br></code></pre></td></tr></table></figure><p>out.c由自定义命令生成</p><p><strong>举例：生成编译所需的.h文件</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 添加生成out.h的命令</span><br><span class="hljs-keyword">add_custom_command</span>(<br>  OUTPUT out.h<br>  <span class="hljs-keyword">COMMAND</span> someTool -i <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/in.txt -o out.h<br>  DEPENDS <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/in.txt)<br><span class="hljs-comment"># 添加target</span><br><span class="hljs-keyword">add_custom_target</span>(GenerateHeader DEPENDS out.h)<br><span class="hljs-keyword">add_library</span>(myLib out.c)<br><span class="hljs-comment"># 添加依赖</span><br><span class="hljs-keyword">add_dependencies</span>(myLib GenerateHeader)<br></code></pre></td></tr></table></figure><p>和.c文件不一样的是，.h文件需要手动指定依赖<br>注意：为何不直接在add_custom_target内运行命令来生成？这样的话，每次都会重新生成这个文件了。</p><h3 id="作用2-构建事件发生时，执行命令"><a href="#作用2-构建事件发生时，执行命令" class="headerlink" title="作用2 - 构建事件发生时，执行命令"></a>作用2 - 构建事件发生时，执行命令</h3><p>在target本身构建之前或者之后运行，如果目标已经构建，那么不会运行。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs inform7">add_custom_command(TARGET &lt;target&gt;<br>                   PRE_BUILD | PRE_LINK | POST_BUILD<br>                   COMMAND command1 <span class="hljs-comment">[ARGS]</span> <span class="hljs-comment">[args1...]</span><br>                   <span class="hljs-comment">[COMMAND command2 <span class="hljs-comment">[ARGS]</span> <span class="hljs-comment">[args2...]</span> ...]</span><br>                   <span class="hljs-comment">[BYPRODUCTS <span class="hljs-comment">[files...]</span>]</span><br>                   <span class="hljs-comment">[WORKING_DIRECTORY dir]</span><br>                   <span class="hljs-comment">[COMMENT comment]</span><br>                   <span class="hljs-comment">[VERBATIM]</span><br>                   <span class="hljs-comment">[COMMAND_EXPAND_LISTS]</span>)<br></code></pre></td></tr></table></figure><p>PRE_BUILD对Visual Studio 生成器有独特的语法，其他生成器作用和PRE_LINK一样。<br>PRE_LINK 表示源代码编译之后，但在二进制目标链接前。<br>POST_BUILD 表示构建之后运行，不指定时，默认是这个。</p><p><strong>举例：编译完成后，运行软件</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>.<span class="hljs-number">0</span>)<br><span class="hljs-keyword">project</span>(<span class="hljs-keyword">test</span>)<br><span class="hljs-keyword">add_executable</span>(<span class="hljs-keyword">test</span> main.c)<br><span class="hljs-keyword">add_custom_command</span>(<span class="hljs-keyword">TARGET</span> <span class="hljs-keyword">test</span><br>    <span class="hljs-keyword">COMMAND</span> <span class="hljs-keyword">test</span><br>)<br></code></pre></td></tr></table></figure><hr><div style="text-align:center;width:100%;">  <span>人生苦短，远离bug</span>  <span style="float: right;">Leon, 2024-06-05</span></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Cmake属性的可见性</title>
    <link href="/2024/06/05/4d0c83e66cb5/"/>
    <url>/2024/06/05/4d0c83e66cb5/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Cmake可见性实验</p></blockquote><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>从 modern cmake(&gt;&#x3D;3.0) 开始，使用的范式从 director-oriented 转换到了 target-oriented。 这其中最重要的有三个概念：</p><ul><li>target  </li><li>target相应的properties  </li><li>可见性</li></ul><p>所谓target就是编译的目标，一般就三种：  </p><ul><li>静态库: 使用add_library()</li><li>动态库: 使用add_library() 指定SHARED关键字</li><li>可执行文件: 使用add_executable</li></ul><p>所谓properties就是target的属性，最常见的有以下五种：</p><ul><li>编译标志：使用target_complie_option</li><li>预处理宏标志：使用 target_compile_definitions</li><li>头文件目录：使用 target_include_directories</li><li>链接库：使用 target_link_libraries</li><li>链接标志：使用 target_link_options</li></ul><p>所谓可见性就是上述这些属性在不同target之间的传递性。有三种：</p><ul><li>PRIVATE：只有自己用</li><li>PUBLIC：自己和使用自己的别人都用</li><li>INTERFACE：自己不用，只给使用的人用</li></ul><p><strong>举例：</strong><br>有目标A和目标B，目标B是一个库，目标A需要使用目标B的库和头文件。一般需要设置目标A的 target_include_directories，这样才能找到B的头文件。<br>但是如果再目标B里面设置PUBLIC属性的 target_include_directories，那么目标A就不需要指定头文件了。因为A使用B时，这个属性会传递给A。</p><p>上面的这些都是很好理解。但INTERFACE是不好理解的。我们详细讲解。</p><h1 id="INTERFACE"><a href="#INTERFACE" class="headerlink" title="INTERFACE"></a>INTERFACE</h1><p>说到INTERFACE，我们先来看其他两种可见性：PUBLIC和PRIVATE。</p><p>假设我们有目标A和目标B。目标A编译成可执行文件，是我们最终要运行的目标。而目标B则编译成目标A的一个依赖，比如说，静态库。</p><p>PUBLIC的意思就是 目标B的属性 不仅自己使用，还传递给依赖它的目标A。</p><p>PRIVATE的意思就是 目标B的属性 不会传递，只给目标B自己使用。</p><p>而INTERFACE则极为特殊：它的属性都 不会自己使用，只传递给目标A。</p><h2 id="什么情况下会使用INTERFACE呢"><a href="#什么情况下会使用INTERFACE呢" class="headerlink" title="什么情况下会使用INTERFACE呢"></a>什么情况下会使用INTERFACE呢</h2><p>（1）如纯头文件的库，自己不会生成任何文件。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_library</span>(Eigen INTERFACE)<br><br><span class="hljs-keyword">target_sources</span>(Eigen INTERFACE<br>  FILE_SET HEADERS<br>    BASE_DIRS src<br>    FILES src/eigen.h src/vector.h src/matrix.h<br>)<br><br><span class="hljs-keyword">add_executable</span>(exe1 exe1.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(exe1 Eigen)<br></code></pre></td></tr></table></figure><p>如上，Eigen库只有头文件，target sources也是一种属性，会传递给exe1。exe1链接时，就能使用到这些源文件。</p><p>（2）一些库会导出一些专门给别人用的头文件，而自己不会用。那么应该也是可以通过INTERFACE来指定的。<br>（3）没有任何代码文件的形式上的库，只用于定义公共的编译宏，编译标志。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">add_library</span><span class="hljs-params">(my_build_flag INTERFACE)</span></span><br><span class="hljs-function"><span class="hljs-title">target_link_options</span><span class="hljs-params">(my_build_flag -Wall)</span></span><br></code></pre></td></tr></table></figure><p>如上，这样只要链接了这个库的人，编译都会加上-Wall标志<br>（4）封装一个第三方编译的库<br>比如一个工程里面有一个configure配置编译的库，其他地方要引用它，需要指定库路径和头文件路径。这时就可以定义一个interface，interface配置好相关信息，其他地方只需要调用target_link_libraries就行了。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">add_library</span><span class="hljs-params">(libevent INTERFACE)</span></span><br><span class="hljs-function"><span class="hljs-title">add_dependencies</span><span class="hljs-params">(libevent build_libevent)</span></span>   <br><span class="hljs-function"><span class="hljs-title">target_link_libraries</span><span class="hljs-params">(libevent INTERFACE event)</span></span><br><span class="hljs-function"><span class="hljs-title">target_link_directories</span><span class="hljs-params">(libevent INTERFACE $&#123;CONFIG_BUILD_FS_DIR&#125;/lib)</span></span><br><span class="hljs-function"><span class="hljs-title">target_include_directories</span><span class="hljs-params">(libevent INTERFACE $&#123;CONFIG_BUILD_FS_DIR&#125;/include)</span></span><br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://chunleili.github.io/cmake/understanding-INTERFACE">彻底弄懂cmake中的 INTEFACE 可见性&#x2F;传递性 问题</a></p><hr><div style="text-align:center;width:100%;">  <span>人生苦短，远离bug</span>  <span style="float: right;">Leon, 2024-06-05</span></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>tcpdump抓包实时发送到远程主机解析</title>
    <link href="/2024/05/28/d3264814853a/"/>
    <url>/2024/05/28/d3264814853a/</url>
    
    <content type="html"><![CDATA[<blockquote><p>将tcpdump抓到的包实时发送到另一台主机上，另一台主机通过wireshark实时解析。</p></blockquote><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>嵌入式调试时抓包，有时只能在机内使用tcpdump，如果直接dump到终端，分析不方便。如果直接保存到内存，内存又怕不够。需要一种把抓到的包实时发送到远端保存解析的方法。</p><h1 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h1><p><strong>原理：</strong><br>tcpdump抓包保存到标准输出，通过管道发送到远程主机。远程主机wireshark通过管道从标准输入读取数据解析。</p><h2 id="实现1"><a href="#实现1" class="headerlink" title="实现1"></a>实现1</h2><p>解析的主机上先运行：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">nc <span class="hljs-punctuation">-</span>l <span class="hljs-punctuation">-</span>p <span class="hljs-number">22122</span> <span class="hljs-string">| wireshark -k -i -</span><br></code></pre></td></tr></table></figure><p><code>-k -i - </code>表示立即开始从标准输入抓包</p><p>然后在抓包的主机上运行抓包：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tcpdump</span> -i eth0.<span class="hljs-number">1</span> -U -w - | nc <span class="hljs-number">192.168.10.123</span> <span class="hljs-number">22122</span><br></code></pre></td></tr></table></figure><p><code>-w -</code>表示保存到标准输出<br><code>-U</code>表示使用包缓存，即收到一个包立即写入。而不是等到缓冲区满。</p><h2 id="实现2-–-更简洁（推荐）"><a href="#实现2-–-更简洁（推荐）" class="headerlink" title="实现2 – 更简洁（推荐）"></a>实现2 – 更简洁（推荐）</h2><p>先在抓包的主机上运行：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tcpdump</span> -i eth0.<span class="hljs-number">1</span> -U -w - | ./nc -l -p <span class="hljs-number">22122</span> &amp;<br></code></pre></td></tr></table></figure><p>然后在解析的主机上运行：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">wireshark</span> -i TCP@<span class="hljs-number">192.168.10.1:22122</span> -k<br></code></pre></td></tr></table></figure><h2 id="windows上wireshark处理"><a href="#windows上wireshark处理" class="headerlink" title="windows上wireshark处理"></a>windows上wireshark处理</h2><p>命令行参数是一样的，只是windows的cmd中默认找不到wireshark，需要这样。<br>（1）右键wireshark图标，打开文件夹所在位置<br>（2）在文件夹中右键打开命令行<br>（3）输入命令即可</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">PS C:<span class="hljs-string">\Program</span> Files<span class="hljs-string">\Wireshark&gt;</span> .<span class="hljs-string">\Wireshark.exe</span> -i TCP@<span class="hljs-number">192.168</span>.<span class="hljs-number">2.1</span>:<span class="hljs-number">22122</span> -k<br></code></pre></td></tr></table></figure><h1 id="rpcapd的方式"><a href="#rpcapd的方式" class="headerlink" title="rpcapd的方式"></a>rpcapd的方式</h1><p>windows上的wireshark有一个远程接口选项卡。<br>可以在抓包主机上运行如下程序。然后解析的windows wireshark中添加远程接口，抓包即可。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel"># -d daemon, -<span class="hljs-built_in">n</span> 不认证<br>rpcapd -d -<span class="hljs-built_in">n</span><br></code></pre></td></tr></table></figure><p>rpcapd是libpcap库中的一个程序，可自己编译。<br><strong>接口列表处有些卡，感觉还不如上面的好用。</strong></p><hr><div style="text-align:center;width:100%;">  <span>人生苦短，远离bug</span>  <span style="float: right;">Leon, 2024-05-28</span></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu生成GUI对话框工具zenity</title>
    <link href="/2024/05/03/9515f721ea62/"/>
    <url>/2024/05/03/9515f721ea62/</url>
    
    <content type="html"><![CDATA[<blockquote><p>有时候我们编写的脚本需要弹出GUI对话框提示用户进行下一步操作，或者显示一些信息，或者获取用户的输入。zenity就是这么一个工具，输入一条命令，弹出一个对话框。</p></blockquote><h1 id="支持的对话框类型有如下："><a href="#支持的对话框类型有如下：" class="headerlink" title="支持的对话框类型有如下："></a>支持的对话框类型有如下：</h1><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs stylus">应用程序选项：<br>  <span class="hljs-attr">--calendar</span>                             显示日历对话框<br>  <span class="hljs-attr">--entry</span>                                显示文本输入对话框<br>  <span class="hljs-attr">--error</span>                                显示错误对话框<br>  <span class="hljs-attr">--info</span>                                 显示信息对话框<br>  <span class="hljs-attr">--file-selection</span>                       显示文件选择对话框<br>  <span class="hljs-attr">--list</span>                                 显示列表对话框<br>  <span class="hljs-attr">--notification</span>                         显示通知<br>  <span class="hljs-attr">--progress</span>                             显示进度指示对话框<br>  <span class="hljs-attr">--question</span>                             显示问题对话框<br>  <span class="hljs-attr">--warning</span>                              显示警告对话框<br>  <span class="hljs-attr">--scale</span>                                显示范围对话框<br>  <span class="hljs-attr">--text-info</span>                            显示文本信息对话框<br>  <span class="hljs-attr">--color-selection</span>                      显示颜色选择对话框<br>  <span class="hljs-attr">--password</span>                             显示口令对话框<br>  <span class="hljs-attr">--forms</span>                                显示表单对话框<br>  <span class="hljs-attr">--display</span>=DISPLAY                      X <span class="hljs-attribute">display</span> to use<br></code></pre></td></tr></table></figure><h2 id="帮助信息"><a href="#帮助信息" class="headerlink" title="帮助信息"></a>帮助信息</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment"># 查看通用选项</span><br>zenity <span class="hljs-comment">--help-general</span><br><span class="hljs-comment"># 查看不同类型对话框的选项</span><br>zenity <span class="hljs-comment">--help-entry</span><br></code></pre></td></tr></table></figure><p>下面举一些简单的例子。</p><h1 id="entry-单行文本输入对话框"><a href="#entry-单行文本输入对话框" class="headerlink" title="entry 单行文本输入对话框"></a>entry 单行文本输入对话框</h1><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">zenity</span> <span class="hljs-literal">--</span><span class="hljs-comment">entry</span> <span class="hljs-literal">--</span><span class="hljs-comment">title 输入姓名</span><br></code></pre></td></tr></table></figure><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/2024-05/03-095551-7d95-leon.png?x-image-process=image/quality,q_65"><br>输入名字，点击确认后，zenity会向标准输出输入的内容。所以脚本程序只需要捕获输出即可。</p><h1 id="question-问题"><a href="#question-问题" class="headerlink" title="question 问题"></a>question 问题</h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">zenity --question --text <span class="hljs-string">&quot;喜欢今天的天气吗&quot;</span> <span class="hljs-attribute">--timeout</span>=5 <span class="hljs-attribute">--ok-label</span>=<span class="hljs-string">&quot;喜欢&quot;</span> <span class="hljs-attribute">--cancel-label</span>=<span class="hljs-string">&quot;一般&quot;</span> <span class="hljs-attribute">--title</span>=<span class="hljs-string">&quot;`date`&quot;</span> <span class="hljs-attribute">--width</span>=300 <span class="hljs-attribute">--height</span>=100<br></code></pre></td></tr></table></figure><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/2024-05/03-100036-b247-leon.png?x-image-process=image/quality,q_65"></p><p>这次我们修改了标题，自定义了ok和cancel内容。还添加了超时。问题的肯定还是否定回答，决定应用的返回值。</p><h1 id="list-列表"><a href="#list-列表" class="headerlink" title="list 列表"></a>list 列表</h1><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs livescript">$ zenity --<span class="hljs-keyword">list</span> <span class="hljs-string">\</span><br>  --title=<span class="hljs-string">&quot;电影列表&quot;</span> <span class="hljs-string">\</span><br>  --column=<span class="hljs-string">&quot;ID&quot;</span> --column=<span class="hljs-string">&quot;电影名称&quot;</span> --column=<span class="hljs-string">&quot;发行年份&quot;</span> <span class="hljs-string">\</span><br>  <span class="hljs-number">1</span> <span class="hljs-string">&quot;肖申克的救赎&quot;</span> <span class="hljs-number">1994</span> <span class="hljs-string">\</span><br>  <span class="hljs-number">2</span> <span class="hljs-string">&quot;教父&quot;</span> <span class="hljs-number">1972</span> <span class="hljs-string">\</span><br>  <span class="hljs-number">3</span> <span class="hljs-string">&quot;教父2&quot;</span> <span class="hljs-number">1974</span> <span class="hljs-string">\</span><br>  <span class="hljs-number">4</span> <span class="hljs-string">&quot;黑暗骑士&quot;</span> <span class="hljs-number">2008</span> <span class="hljs-string">\</span><br>  <span class="hljs-number">5</span> <span class="hljs-string">&quot;十二怒汉&quot;</span> <span class="hljs-number">1957</span> <span class="hljs-string">\</span><br>  --width=<span class="hljs-number">400</span> --height=<span class="hljs-number">250</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/2024-05/03-101324-1094-leon.png?x-image-process=image/quality,q_65"><br>返回数据为选中的行。</p><h1 id="text-info-多行文本框"><a href="#text-info-多行文本框" class="headerlink" title="text-info 多行文本框"></a>text-info 多行文本框</h1><p>它从一个文件中读入内容，然后展示出来</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ echo -e <span class="hljs-string">&quot;hello\nworld\n&quot;</span> &gt; /tmp/ttt.txt<br>$ zenity --text-<span class="hljs-built_in">info</span> <span class="hljs-attribute">--title</span>=备注 --editable <span class="hljs-attribute">--width</span>=500 <span class="hljs-attribute">--height</span>=300 <span class="hljs-attribute">--filename</span>=/tmp/ttt.txt<br>hello<br>world<br></code></pre></td></tr></table></figure><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/2024-05/03-101715-f2b7-leon.png?x-image-process=image/quality,q_65"></p><p>编辑之后确认，它向标准输出打印文本框中内容。</p><h1 id="forms-表单"><a href="#forms-表单" class="headerlink" title="forms 表单"></a>forms 表单</h1><p>它可以同时获取多个信息</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">$ zenity <span class="hljs-params">--forms</span> <span class="hljs-params">--title=</span><span class="hljs-string">&quot;注册表单&quot;</span> \<br>        <span class="hljs-params">--text=</span><span class="hljs-string">&quot;请填写以下信息&quot;</span> \<br>        <span class="hljs-params">--separator=</span><span class="hljs-string">&quot;,&quot;</span> \<br>        <span class="hljs-params">--add-entry=</span><span class="hljs-string">&quot;姓名&quot;</span> \<br>        <span class="hljs-params">--add-password=</span><span class="hljs-string">&quot;密码&quot;</span> \<br>        <span class="hljs-params">--add-calendar=</span><span class="hljs-string">&quot;日期&quot;</span><br>leon,123456,2024年05月03日<br></code></pre></td></tr></table></figure><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/2024-05/03-102301-dcfa-leon.png?x-image-process=image/quality,q_65"></p><p>最终的结果也是输出到标准输出中，以–separator指定的分割符分割</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="如何在crontab命令中弹出对话框"><a href="#如何在crontab命令中弹出对话框" class="headerlink" title="如何在crontab命令中弹出对话框"></a>如何在crontab命令中弹出对话框</h2><p>配置如下环境变量</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">DISPLAY</span>=<span class="hljs-string">&quot;:0&quot;</span><br><span class="hljs-built_in">export</span> <span class="hljs-attribute">DBUS_SESSION_BUS_ADDRESS</span>=<span class="hljs-string">&quot;unix:path=/run/user/<span class="hljs-variable">$(id -u)</span>/bus&quot;</span><br>unset GTK_PATH<br></code></pre></td></tr></table></figure><h2 id="在vscode的命令行中遇到symbol-lookup-error"><a href="#在vscode的命令行中遇到symbol-lookup-error" class="headerlink" title="在vscode的命令行中遇到symbol lookup error"></a>在vscode的命令行中遇到symbol lookup error</h2><p>报错如下：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">zenity: symbol <span class="hljs-keyword">lookup</span> <span class="hljs-keyword">error</span>: /snap/core20/current/lib/x86_64-linux-gnu/libpthread.<span class="hljs-keyword">so</span>.0: undefined symbol: __libc_pthread_init, <span class="hljs-keyword">version</span> GLIBC_PRIVATE<br></code></pre></td></tr></table></figure><p>去掉如下环境变量即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">unset</span> GTK_PATH<br></code></pre></td></tr></table></figure><h1 id="替代品"><a href="#替代品" class="headerlink" title="替代品"></a>替代品</h1><p>yad–提供更多的选项</p><hr><div style="text-align:center;width:100%;">  <span>人生苦短，远离bug</span>  <span style="float: right;">Leon, 2024-05-03</span></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>内核运行一个用户程序</title>
    <link href="/2024/04/17/171ada44f455/"/>
    <url>/2024/04/17/171ada44f455/</url>
    
    <content type="html"><![CDATA[<blockquote><p>使用call_usermodehelper即可。</p></blockquote><h1 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * call_usermodehelper() - prepare and start a usermode application</span><br><span class="hljs-comment"> * @path: path to usermode executable</span><br><span class="hljs-comment"> * @argv: arg vector for process</span><br><span class="hljs-comment"> * @envp: environment for process</span><br><span class="hljs-comment"> * @wait: wait for the application to finish and return status.</span><br><span class="hljs-comment"> *        when UMH_NO_WAIT don&#x27;t wait at all, but you get no useful error back</span><br><span class="hljs-comment"> *        when the program couldn&#x27;t be exec&#x27;ed. This makes it safe to call</span><br><span class="hljs-comment"> *        from interrupt context.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This function is the equivalent to use call_usermodehelper_setup() and</span><br><span class="hljs-comment"> * call_usermodehelper_exec().</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">call_usermodehelper</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> **argv, <span class="hljs-type">char</span> **envp, <span class="hljs-type">int</span> wait)</span><br></code></pre></td></tr></table></figure><p>第4个参数wait取值如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> UMH_NO_WAIT0<span class="hljs-comment">/* don&#x27;t wait at all */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UMH_WAIT_EXEC1<span class="hljs-comment">/* wait for the exec, but not the process */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UMH_WAIT_PROC2<span class="hljs-comment">/* wait for the process to complete */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UMH_KILLABLE4<span class="hljs-comment">/* wait for EXEC/PROC killable */</span></span><br></code></pre></td></tr></table></figure><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">run_users_proc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">char</span> *argv[] = &#123;<span class="hljs-string">&quot;/bin/sh&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;/etc/test.sh &gt; /dev/console&quot;</span>, <span class="hljs-literal">NULL</span>&#125;;<br>    <span class="hljs-type">char</span> *envp[] = &#123;<span class="hljs-string">&quot;PATH=/sbin:/bin:/usr/sbin:/usr/bin&quot;</span>, <span class="hljs-string">&quot;HOME=/&quot;</span>, <span class="hljs-literal">NULL</span>&#125;;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><br>    printk(<span class="hljs-string">&quot; run .... \n\n&quot;</span>);<br>    ret = call_usermodehelper(argv[<span class="hljs-number">0</span>], argv, envp, UMH_WAIT_PROC);<br>    printk(<span class="hljs-string">&quot;ret = %d\n&quot;</span>, ret);<br>&#125;<br></code></pre></td></tr></table></figure><p>因为从内核打开的程序，并没有人为其准备标准输入输出，所以上面例子重定向console，才能有输出。</p><hr><div style="text-align:center;width:100%;">  <span>人生苦短，远离bug</span>  <span style="float: right;">Leon, 2024-04-17</span></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>top交互式命令</title>
    <link href="/2024/03/26/26ebe4616e90/"/>
    <url>/2024/03/26/26ebe4616e90/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>f</td><td>上下键移动；显示(不显示)选中列按d；按选中列排序按s；右键表示要移动该列的位置，然后按上下键移动，移动完成后按Enter键</td></tr><tr><td>e</td><td>进程的内存单位调整，多次按e，调整不同的单位</td></tr><tr><td>E</td><td>顶部摘要信息的内存单位</td></tr><tr><td>Enter&#x2F;Spaces</td><td>立即刷新</td></tr><tr><td>H</td><td>摘要区域显示线程数，默认显示进程数</td></tr><tr><td>k</td><td>杀死一个任务，后面可以跟pid号。不跟表示杀死当前提示的进程号</td></tr><tr><td>W</td><td>将当前的配置写入配置文件，下次top就会看到当前一样的效果</td></tr><tr><td>c</td><td>切换显示进程的命令行</td></tr><tr><td>u</td><td>过滤用户的进程</td></tr><tr><td>&lt;&gt;</td><td>左移，右移排序字段</td></tr><tr><td>R</td><td>逆序</td></tr><tr><td>M</td><td>按%MEM(RES内存百分比)内存排序</td></tr><tr><td>P</td><td>按cpu排序</td></tr><tr><td>b,x,y</td><td>b-开启条形图加粗，x-列突出(加粗)显示，排序的列会加粗，y-行突出显示</td></tr><tr><td>L</td><td>搜索字符串</td></tr><tr><td>d</td><td>设置更新时间</td></tr><tr><td>?</td><td>简要的帮助信息</td></tr><tr><td>t</td><td>摘要信息更改cpu占用的显示形式</td></tr><tr><td>m</td><td>摘要更改内存占用的显示形式</td></tr><tr><td>1</td><td>显示所有cpu的占用信息</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>sock_filter之bpf</title>
    <link href="/2024/03/15/098666119136/"/>
    <url>/2024/03/15/098666119136/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在linux上，我们创建socket收包时，默认会把指定协议的所有数据包收上来。<br>如指定的<code>ETH_P_ALL</code>，那么所有包都会收上来，如果指定<code>IPPROTO_ICMPV6</code>,那么只会收icmpv6的报文。<br>有时我们想过滤部分数据包怎么办呢？<br><strong>使用setsockopt的SO_ATTACH_FILTER选项设置过滤器到内核。</strong></p></blockquote><h1 id="SO-ATTACH-FILTER使用"><a href="#SO-ATTACH-FILTER使用" class="headerlink" title="SO_ATTACH_FILTER使用"></a>SO_ATTACH_FILTER使用</h1><p>通过SO_ATTACH_FILTER选项，可以把我们设置的filter发送到内核，内核运行filter之后再决定是否把数据包收到应用层。<br>一般性的代码为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/if_ether.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/filter.h&gt;</span></span><br><span class="hljs-comment">/* ... */</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock_filter</span> <span class="hljs-title">code</span>[] =</span> &#123;<br>....<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock_fprog</span> <span class="hljs-title">bpf</span> =</span> &#123;<br>.len = <span class="hljs-keyword">sizeof</span>(code) / <span class="hljs-keyword">sizeof</span>(code[<span class="hljs-number">0</span>]),<br>.filter = code,<br>&#125;;<br><br>sock = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL));<br><span class="hljs-keyword">if</span> (sock &lt; <span class="hljs-number">0</span>)<br><span class="hljs-comment">/* ... bail out ... */</span><br><br>ret = setsockopt(sock, SOL_SOCKET, SO_ATTACH_FILTER, &amp;bpf, <span class="hljs-keyword">sizeof</span>(bpf));<br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br><span class="hljs-comment">/* ... bail out ... */</span><br><br><span class="hljs-comment">/* ... */</span><br>close(sock);<br></code></pre></td></tr></table></figure><p><strong>重点在于sock_filter这个结构怎么填充，怎么写，语法如何。</strong></p><h2 id="使用tcpdump生成过滤器代码"><a href="#使用tcpdump生成过滤器代码" class="headerlink" title="使用tcpdump生成过滤器代码"></a>使用tcpdump生成过滤器代码</h2><p>使用tcpdump的<code>-dd</code>参数命令，可以直接生成sock_filter的代码，例如过滤icmpv6的NS和NA报文。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"># tcpdump icmp6[0]==135 or icmp6[0]==136 -dd</span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123; 0x28, 0, 0, 0x0000000e &#125;</span><span class="language-xml">,</span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123; 0x15, 0, 6, 0x000086dd &#125;</span><span class="language-xml">,</span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123; 0x30, 0, 0, 0x00000016 &#125;</span><span class="language-xml">,</span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123; 0x15, 0, 4, 0x0000003a &#125;</span><span class="language-xml">,</span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123; 0x30, 0, 0, 0x00000038 &#125;</span><span class="language-xml">,</span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123; 0x15, 1, 0, 0x00000087 &#125;</span><span class="language-xml">,</span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123; 0x15, 0, 1, 0x00000088 &#125;</span><span class="language-xml">,</span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123; 0x6, 0, 0, 0x00040000 &#125;</span><span class="language-xml">,</span><br><span class="language-xml"></span><span class="hljs-template-variable">&#123; 0x6, 0, 0, 0x00000000 &#125;</span><span class="language-xml">,</span><br></code></pre></td></tr></table></figure><p>这种方法最简单，但是代码不易读，需要写注释用什么产生的。</p><h2 id="手写过滤器代码"><a href="#手写过滤器代码" class="headerlink" title="手写过滤器代码"></a>手写过滤器代码</h2><p>实例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Filter ICMPv6 messages of type neighbor soliciation</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock_filter</span> <span class="hljs-title">bpf</span>[] =</span> &#123;<br>BPF_STMT(BPF_LD | BPF_B | BPF_ABS, offsetof(<span class="hljs-keyword">struct</span> ip6_hdr, ip6_nxt)), <span class="hljs-comment">// 获取ip6_hdr的ip6_nxt偏移的一个字节</span><br>BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, IPPROTO_ICMPV6, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>),<span class="hljs-comment">//如果不是icmpv6协议，跳5行，否则继续执行下一行</span><br>BPF_STMT(BPF_LD | BPF_B | BPF_ABS, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ip6_hdr) +<br>offsetof(<span class="hljs-keyword">struct</span> icmp6_hdr, icmp6_type)),<span class="hljs-comment">//提取icmp6 type偏移的一个字节</span><br>BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, ND_NEIGHBOR_SOLICIT, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>), <span class="hljs-comment">// 如果不是NS，跳1行</span><br>BPF_STMT(BPF_RET | BPF_K, <span class="hljs-number">0xffffffff</span>),<span class="hljs-comment">//返回接收</span><br>BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, ND_NEIGHBOR_ADVERT, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>), <span class="hljs-comment">// 如果不是NA，跳1行</span><br>BPF_STMT(BPF_RET | BPF_K, <span class="hljs-number">0xffffffff</span>),<span class="hljs-comment">//返回接收</span><br>BPF_STMT(BPF_RET | BPF_K, <span class="hljs-number">0</span>),<span class="hljs-comment">//返回拒绝</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这个规则比较复杂。</p><h2 id="其他过滤api"><a href="#其他过滤api" class="headerlink" title="其他过滤api"></a>其他过滤api</h2><p>针对icmpv6有一些api可以调用，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Filter ICMPv6 package types</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">icmp6_filter</span> <span class="hljs-title">filt</span>;</span><br>ICMP6_FILTER_SETBLOCKALL(&amp;filt);<br>ICMP6_FILTER_SETPASS(ND_ROUTER_ADVERT, &amp;filt);<br>setsockopt(sock, IPPROTO_ICMPV6, ICMP6_FILTER, &amp;filt, <span class="hljs-keyword">sizeof</span>(filt));<br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[# <a href="https://www.cnblogs.com/pwl999/p/15535023.html">Linux bpf 3.1、Berkeley Packet Filter (BPF) (Kernel Document)</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>技术/bpf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BPF包过滤规则语法</title>
    <link href="/2024/03/15/a10497a90091/"/>
    <url>/2024/03/15/a10497a90091/</url>
    
    <content type="html"><![CDATA[<blockquote><p>BPF(Berkeley Packet Filter)全称为伯克利包过滤,是一种功能非常强大的过滤语法.这个语法被广泛应用于多种数据包嗅探软件,因为大部分数据包嗅探软件都依赖于使用BPF的libpcap&#x2F;WinPcap库.诸如tcpdump,wireshark等等。</p></blockquote><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>使用BPF语法创建的过滤器被称为表达式,并且每个表达式包含一个或多个原语。原语是对网络协议标头中的字段（例如，主机、端口或 TCP 端口）的引用。 BPF 语法由一个或多个原语组成，而原语通常包含以一个或多个限定符作为前缀的标识（通常为名称或数字）。</p><p><strong>type 限定符</strong><br><code>Type</code> 限定符用于指示标识名称或数字所引用的信息类型。 例如，type 可能是 host、net、port 或 portrange。 不存在 type 限定符时，假设为 host。</p><p><strong>dir 限定符</strong><br><code>Dir</code> 限定符指定与标识相关的传输方向。 例如，dir 限定符可能是 src、dst 或 src or dst。</p><p><strong>proto 限定符</strong><br><code>proto</code> 限定符将协议匹配限制于特定协议。 可能的协议包括 ether、fddi、tr、wlan、ip、ip6、arp、rarp、decnet、TCP 或 UDP。</p><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/2024-03/15-155355-c033-leon.png?x-image-process=image/quality,q_65"></p><p><strong>操作符</strong><br>操作符有（），！&#x3D;，&amp;&amp;，||。<br>英文有and,or,not。推荐使用英文，而非符号，因为使用符号需要加单引号，不然与shell的符号冲突。<br>比如：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 使用and，过滤目的地址为192.168.66.247的tcp 80端口数据</span><br><span class="hljs-attribute">tcpdump</span> -i br0 -n dst host <span class="hljs-number">192.168.66.247</span> and tcp port <span class="hljs-number">80</span><br><br><span class="hljs-comment"># 使用&amp;&amp;符号，需要用单引号包过滤器语法括起来</span><br><span class="hljs-attribute">tcpdump</span> -i br0 -n &#x27;dst host <span class="hljs-number">192.168.66.247</span> &amp;&amp; tcp port <span class="hljs-number">80</span>&#x27;<br><br><span class="hljs-comment"># 使用括号，同样需要使用单引号。过滤目的地址为192.168.66.247的http，https数据</span><br><span class="hljs-attribute">tcpdump</span> -i br0 -n &#x27;dst host <span class="hljs-number">192.168.66.247</span> &amp;&amp; (tcp port <span class="hljs-number">80</span> || tcp port <span class="hljs-number">443</span>)&#x27;<br></code></pre></td></tr></table></figure><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><h3 id="host-IP过滤"><a href="#host-IP过滤" class="headerlink" title="host IP过滤"></a>host IP过滤</h3><p><code>[src|dst] host &lt;host&gt;</code> </p><ul><li><code>dst host 192.168.1.2</code>  过滤IP地址</li><li><code>src host 192.168.1</code>  只匹配前面的IP即可，等同于<code>src net 192.168.1.0/24</code></li></ul><h3 id="host-mac过滤"><a href="#host-mac过滤" class="headerlink" title="host mac过滤"></a>host mac过滤</h3><p><code>ether [src|dst] host &lt;mac&gt;</code></p><ul><li><code>ether src host ae:96:be:6f:ab:53</code> 过滤源mac</li></ul><h3 id="net-网段过滤"><a href="#net-网段过滤" class="headerlink" title="net 网段过滤"></a>net 网段过滤</h3><p><code>[src|dst] net &lt;network&gt;</code></p><ul><li><code>src net 192.168.1.0/24</code> 等同于 <code>src host 192.168.1</code></li></ul><h3 id="按协议过滤"><a href="#按协议过滤" class="headerlink" title="按协议过滤"></a>按协议过滤</h3><p><code>(ether|ip|ip6) proto &lt;protocol&gt;</code><br>普通的协议直接输入协议名即可，如<code>icmp6</code>。一些特殊的协议可以输入数字：</p><ul><li><code>ether proto 0x893a</code>  过滤ieee1905协议。</li><li><code>ip proto 0xaa89</code> 过滤自定义协议</li></ul><h3 id="按端口过滤"><a href="#按端口过滤" class="headerlink" title="按端口过滤"></a>按端口过滤</h3><p><code>[src|dst] port &lt;port&gt; or [tcp|udp] [src|dst] port &lt;port&gt;</code></p><h3 id="按协议的字节偏移内容过滤"><a href="#按协议的字节偏移内容过滤" class="headerlink" title="按协议的字节偏移内容过滤"></a>按协议的字节偏移内容过滤</h3><p><code>icmp[0]==3</code> icmp协议头的第一个字节是否等于3<br><code>icmp[0]&amp;0x2==1</code> 位运算后比较<br><code>icmp[12:3]==0x3a3a3a</code> 取多字节，从位置12开始取3个字节</p><p>针对一些自定义协议，就可以通过字节偏移来过滤<br><code>ether[34:2]=0x370</code>  过滤从以太网头开始的35，36字节为0x370的。<br><strong>注意：一般描述从第1字节开始，但是数组下标是从0开始，要多减1</strong></p><table><thead><tr><th>BPF 过滤器示例</th><th>描述</th></tr></thead><tbody><tr><td><code>udp dst port not 53</code></td><td>未与端口 53 绑定的 UDP。</td></tr><tr><td><code>host 10.0.0.1 &amp;&amp; host 10.0.0.2</code></td><td>这些主机之间的流量。</td></tr><tr><td><code>tcp dst port 80 or 8080</code></td><td>发往任一个指定 TCP 端口的包。</td></tr><tr><td><code>ether[0:4] &amp; 0xffffff0f &gt; 25</code></td><td>基于范围的掩码，它应用于大于 25 的字节。</td></tr><tr><td><code>ip[1] != 0</code></td><td>捕获 IP 标头中的 <code>Types of Service</code> (TOS) 字段不为 0 的包。</td></tr><tr><td><code>ether host 11:22:33:44:55:66</code></td><td>匹配具有该 Mac 地址的特定主机。</td></tr><tr><td><code>ether[0] &amp; 1 = 0 and ip[16] &gt;= 224</code></td><td>捕获并非通过以太网广播或多点广播来发送的 IP 广播或多点广播。</td></tr><tr><td><code>icmp[icmptype] != icmp-echo</code></td><td>捕获所有并非回传请求的 ICMP 包。</td></tr><tr><td><code>ip[0] &amp; 0xf !=5</code></td><td>捕获所有具有选项的 IP 包。</td></tr><tr><td><code>ip[6:2] &amp; 0x1fff = 0</code></td><td>仅捕获未分段的 IPv4 数据报以及分段 IPv4 数据报的分段零。</td></tr><tr><td><code>icmp6[0]==135 or icmp6[0]==136</code></td><td>过滤NS或者NA报文</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.ibm.com/docs/zh/qsip/7.4?topic=queries-berkeley-packet-filters">Berkeley 包过滤器</a><br><a href="https://zhanghuidinah.github.io/2018/07/25/BPF%E8%BF%87%E6%BB%A4%E8%A7%84%E5%88%99/">BPF过滤规则</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>nautilus文件管理器添加文件备注功能</title>
    <link href="/2024/02/26/09c61c706b1b/"/>
    <url>/2024/02/26/09c61c706b1b/</url>
    
    <content type="html"><![CDATA[<p>关键字：注释 </p><blockquote><p>有时候我们需要对文件进行一个简单的备注，描述这个文件的作用。可以通过如下方法快速实现。</p></blockquote><p>在<code>~/.local/share/nautilus/scripts</code>目录下创建一个脚本，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>TMP_FILE=`<span class="hljs-built_in">mktemp</span>`<br>gio info --attributes=metadata::annotation <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> | sed <span class="hljs-string">&#x27;&#123;1,4 d;s/  metadata::annotation: //&#125;&#x27;</span> &gt; <span class="hljs-variable">$TMP_FILE</span><br><br>newnotes=`zenity --text-info --title=备注 --editable --width=500 --height=300 --filename=<span class="hljs-variable">$TMP_FILE</span>`<br><br><span class="hljs-keyword">if</span> [ $? = 1 ]; <span class="hljs-keyword">then</span><br>  <span class="hljs-built_in">rm</span> <span class="hljs-variable">$TMP_FILE</span><br>  <span class="hljs-built_in">exit</span><br><span class="hljs-keyword">fi</span><br><br>gio <span class="hljs-built_in">set</span> -t string <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> metadata::annotation <span class="hljs-string">&quot;<span class="hljs-variable">$newnotes</span>&quot;</span><br><span class="hljs-built_in">rm</span> <span class="hljs-variable">$TMP_FILE</span><br></code></pre></td></tr></table></figure><p>然后右键-&gt;脚本选择你的脚本就行了。</p><p>数据存在gio中，文件管理器层面移动文件，该属性还在，如果命令行mv这种移动就不行了。这些属性保存在<code>~/.local/share/gvfs-metadata/</code>下面。</p><p><strong>参考</strong><br><a href="https://askubuntu.com/questions/90853/file-notes-tab-gone-in-nautilus-3-2-1">File notes tab gone in Nautilus 3.2.1</a></p><p>有bug，特殊字符有问题</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>vscode clangd插件使用</title>
    <link href="/2024/02/22/5086bb846897/"/>
    <url>/2024/02/22/5086bb846897/</url>
    
    <content type="html"><![CDATA[<blockquote><p>以前用的微软的c&#x2F;c++插件来进行代码分析，跳转。分析代码很慢，磁盘占用多。没分析完时很难跳转。</p></blockquote><h1 id="前置工作"><a href="#前置工作" class="headerlink" title="前置工作"></a>前置工作</h1><p>clangd分析代码一样需要编译数据库文件(compile_commands.json)，需要先准备好这个文件。可以使用bear来捕获生成。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>（1）vscode安装clangd插件</p><p>（2）ubuntu上安装clangd。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install clangd<br></code></pre></td></tr></table></figure><p>ubuntu上也可以不安装clangd，vscode里面会提示你安装，会装在vscode目录。vscode里面安装的clangd版本会更高一些。建议使用这种。</p><h1 id="配置clangd"><a href="#配置clangd" class="headerlink" title="配置clangd"></a>配置clangd</h1><h2 id="compile-commands-json路径"><a href="#compile-commands-json路径" class="headerlink" title="compile_commands.json路径"></a>compile_commands.json路径</h2><p>装上之后可能第一个需要配置的就是compile_commands.json 位置，默认会在工程路径下查找。如果需要单独指定，那么配置clangd的命令行参数。<br><code>--compile-commands-dir=your_dir</code></p><h2 id="分析代码的核心数"><a href="#分析代码的核心数" class="headerlink" title="分析代码的核心数"></a>分析代码的核心数</h2><p>配置命令行参数<code>-j=10</code></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-string">&quot;clangd.arguments&quot;</span>: [<br><span class="hljs-string">&quot;-j=10&quot;</span>,<br>]<br></code></pre></td></tr></table></figure><h2 id="关闭自动插入头文件"><a href="#关闭自动插入头文件" class="headerlink" title="关闭自动插入头文件"></a>关闭自动插入头文件</h2><p>针对复杂的工程，clangd可能会插入错误的头文件。所以关闭它。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">--header-insertion</span>=never<br></code></pre></td></tr></table></figure><h2 id="format"><a href="#format" class="headerlink" title="format"></a>format</h2><p>禁用c&#x2F;c++插件后，格式化不能用了，需要选择clang。默认的clang格式化风格跟自己的不符。需要配置。<br><code>--fallback-style=Microsoft</code><br>也可以使用自定义格式，如下方法，在工作区生成.clang-format。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install clang-format<br><br><span class="hljs-comment"># 工作区运行生成.clang-format文件</span><br>clang-format --style=Microsoft --dump-config &gt; .clang-format<br></code></pre></td></tr></table></figure><p>这样就可以了，也可以根据需要深入修改这个文件。</p><h2 id="clang-tidy"><a href="#clang-tidy" class="headerlink" title="clang-tidy"></a>clang-tidy</h2><p>没看出来作用。简单的malloc,fopen描述符泄露都看不出来。</p><h1 id="和微软的c-x2F-c-插件共存"><a href="#和微软的c-x2F-c-插件共存" class="headerlink" title="和微软的c&#x2F;c++插件共存"></a>和微软的c&#x2F;c++插件共存</h1><p>网上有人说二者冲突，要禁用c&#x2F;c++插件，实则没有。只是两个都启用时，都会分析代码，无疑是多余的。<br>只需要关闭c&#x2F;c++插件的代码分析和补全就好了。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;C_Cpp.intelliSenseEngine&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;disabled&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;C_Cpp.autocomplete&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;disabled&quot;</span><br></code></pre></td></tr></table></figure><p>这样也可以使用c&#x2F;c++插件的debug功能了。</p><h1 id="资源占用"><a href="#资源占用" class="headerlink" title="资源占用"></a>资源占用</h1><p>工作区编译的文件有13000多个，分析完之后，clangd内存占用2G，磁盘缓存占用290M。下次打开工作区，能很快分析完。</p><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><h2 id="内核文件解析报错"><a href="#内核文件解析报错" class="headerlink" title="内核文件解析报错"></a>内核文件解析报错</h2><p>关键错误信息为：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Failed <span class="hljs-built_in">to</span> <span class="hljs-built_in">prepare</span> <span class="hljs-keyword">a</span> compiler instance: unknown target ABI <span class="hljs-string">&#x27;lp64&#x27;</span><br></code></pre></td></tr></table></figure><p>查了下，clangd好像处理不了编译标志<code>-mabi=lp64</code>，这个<a href="https://github.com/clangd/clangd/issues/734">issue</a>还没解决的。<br>只能自己删除compile_commands.json里面的这个标志。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">sed</span> -i <span class="hljs-string">&#x27;/mabi=lp64/ d&#x27;</span> compile_commands.json<br></code></pre></td></tr></table></figure><p>推荐使用下面的编译标志报错方法解决。</p><h2 id="一些编译标志报错"><a href="#一些编译标志报错" class="headerlink" title="一些编译标志报错"></a>一些编译标志报错</h2><p>文件可以正常解析，但是clangd的状态会显示文件报错，说未知的标志。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;Unknown argument: &#x27;-fno-allow-store-data-races&#x27;&quot;</span><br></code></pre></td></tr></table></figure><p>可以通过配置clangd的配置文件来移除这些标志。这些标志位基本都是指导gcc如果编译代码的，对语义分析影响不大。<br>针对用户的配置文件为：~&#x2F;.config&#x2F;clangd&#x2F;config.yaml<br>针对工作区的配置文件为：工作区目录&#x2F;.clangd<br>添加如下配置让clangd解析时移除这些标志即可，如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">CompileFlags:</span><br>    <span class="hljs-comment"># clangd处理这些标志会报错</span><br>    <span class="hljs-attr">Remove:</span> [<span class="hljs-string">-mno-thumb-interwork</span>, <span class="hljs-string">-ffixed-r8</span>, <span class="hljs-string">-fno-allow-store-data-races</span>, <span class="hljs-string">-mabi=lp64</span>]<br></code></pre></td></tr></table></figure><p>[文档][<a href="https://clangd.llvm.org/config#files]">https://clangd.llvm.org/config#files]</a></p><p>我的~&#x2F;.config&#x2F;clangd&#x2F;config.yaml配置为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">CompileFlags:</span><br>    <span class="hljs-comment"># clangd处理这些标志会报错</span><br>    <span class="hljs-attr">Remove:</span> [<span class="hljs-string">-mno-thumb-interwork</span>, <span class="hljs-string">-ffixed-r8</span>, <span class="hljs-string">-fno-allow-store-data-races</span>, <span class="hljs-string">-fno-var-tracking-assignments</span>,<span class="hljs-string">-mlong-calls</span>, <span class="hljs-string">-fconserve-stack</span>, <span class="hljs-string">-mabi=*</span>, <span class="hljs-string">-mno-check-zero-division</span>, <span class="hljs-string">-mno-abicalls</span>, <span class="hljs-string">-G</span>]<br></code></pre></td></tr></table></figure><p><strong>realtek方案遇到的问题</strong><br>遇到这个错<code>unknown target CPU &#39;mips32r2&#39;</code><br>编译选项里面有<code>-march=mips32r2</code>, 编译标志里面移除它就好了。最终解决方法时，在工作区目录创建.clangd文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">CompileFlags:</span><br>  <span class="hljs-comment"># 指定交叉编译器，让 clangd 能调用它获取系统 include 路径</span><br>  <span class="hljs-attr">Compiler:</span> <span class="hljs-string">/home/leon/code/rtl-ax1500/rtl819x/toolchain/msdk-6.4.1-mips-EL-4.4-u0.9.33-m32ut-190619/bin/msdk-linux-gcc</span><br><br>  <span class="hljs-comment"># 移除 clang 不认识的 flag（这些在 GCC 下正常，但 clang 会报错）</span><br>  <span class="hljs-attr">Remove:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">-mabi=*</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">-march=*</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">-EL</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">-msoft-float</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">-Wa,*</span><br></code></pre></td></tr></table></figure><h2 id="找不到头文件"><a href="#找不到头文件" class="headerlink" title="找不到头文件"></a>找不到头文件</h2><p>有时还会遇到文件无法解析，说找不到头文件。原因为存在多个compile_commands.json。虽然外层的有这个文件的编译命令，但是最里层的compile_commands.json为空，导致无法解析这个文件。删除里层的就好。</p>]]></content>
    
    
    
    <tags>
      
      <tag>工具/vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu的日志管理journalctl</title>
    <link href="/2024/02/07/c818df9bd2ba/"/>
    <url>/2024/02/07/c818df9bd2ba/</url>
    
    <content type="html"><![CDATA[<p>在 Linux 系统中，目前主流使用的systemd管理系统，<code>journalctl</code> 是systemd管理和查看系统日志的主要工具，提供了许多用于处理日志的选项。以下是一些 <code>journalctl</code> 的常用命令。</p><h1 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h1><ol><li><strong>查看所有日志</strong>: <code>journalctl</code></li><li><strong>查看特定服务日志</strong>: <code>journalctl -u [服务名]</code>，例如 <code>journalctl -u ssh</code></li><li><strong>逆序查看日志</strong>：<code>journalctl -r</code></li><li><strong>查看实时日志输出</strong>: <code>journalctl -f</code>，这将类似于传统的 <code>tail -f</code> 命令，实时显示最新的日志消息。</li><li><strong>显示原始日志</strong>：<code>journalctl -o cat</code>，这将显示原始的输入日志，不会显示journalctl添加的时间戳等信息。</li><li><strong>显示详细的日志</strong>：<code>journalctl -o verbose</code>，这将详细显示journalctl记录的所有字段。方便知道字段名，可以配置字段过滤。</li></ol><h1 id="过滤日志"><a href="#过滤日志" class="headerlink" title="过滤日志"></a>过滤日志</h1><ol><li><strong>按时间查看日志</strong>:<ul><li>查看某天的日志： <code>journalctl --since &quot;2022-01-01&quot; --until &quot;2022-01-02&quot;</code></li><li>查看最近一个小时的日志： <code>journalctl --since &quot;1 hour ago&quot;</code></li><li>显示10:05之后的日志: <code>journalctl -S 10:05</code></li><li>显示10:05之前的日志  <code>journalctl -U 10:05 </code></li><li>查看系统本次启动的日志：<code>journalctl -b</code>, <code>journalctl -b -0</code></li><li>查看上一次启动的日志：<code>journalctl -b -1</code></li></ul></li><li><strong>查看内核日志</strong> <code>journalctl -k</code></li><li><strong>grep过滤日志</strong>：<code>journalctl -g &quot;hello&quot;</code></li><li><strong>按优先级查看日志</strong>: <code>journalctl -p [优先级]</code>，比如 <code>journalctl -p err</code> 将查看所有错误级别的日志。</li><li><strong>按字段过滤日志</strong>: <code>journalctl [字段名]=[字段值]</code>，比如 <code>journalctl _COMM=sshd</code> 将查看所有来自 sshd 进程的日志。字段名可通过<code>journalctl -o verbose</code>得到</li><li><strong>查看特定进程的日志</strong>: <code>journalctl _PID=[进程ID]</code>，例如 <code>journalctl _PID=1</code> 将查看 PID 为 1 的进程的所有日志。</li><li><strong>按syslog标签过滤日志：</strong> <code>journalctl -t ddns</code>，查看标签为ddns的日志，该标签为<code>SYSLOG_IDENTIFIER</code>字段，logger生成日志时可通过logger -t ddns添加。</li></ol><h1 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h1><ul><li>查看日志占用磁盘空间： <code>journalctl --disk-usage</code></li><li>清理老旧日志： <code>sudo journalctl --vacuum-time=2weeks</code>，这将删除所有两周之前的日志消息。</li></ul><h1 id="journalctl与rsyslogd的关系"><a href="#journalctl与rsyslogd的关系" class="headerlink" title="journalctl与rsyslogd的关系"></a>journalctl与rsyslogd的关系</h1><p>在ubuntu上，他们二者是共存的。journalctl接收所有日志（内核和用户进程），进行自己的存储。然后也会把日志(通过syslog产生的)发送给rsyslogd，让rsyslogd根据自己的配置存储在&#x2F;var&#x2F;log&#x2F;或是转发到其他远程服务器。</p><p>例如&#x2F;var&#x2F;log&#x2F;auth.log里面的日志，在journalctl中也能找到。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ol><li>并不是所有日志都在journal中，标准调用syslog，进程的标准输出都在journal中。有一些进程会有自己的日志文件，就在journal中查不到。如&#x2F;var&#x2F;log&#x2F;fail2ban.log等。</li><li>有些进程可能会疯狂写日志，如linux版迅雷，钉钉，微信。4G的日志，它们可能占3.5G。基本属于垃圾日志，它们可能会刷掉其他日志。journal目前并不支持配置丢弃掉某些特殊日志。需要自己找到他们的启动脚本把输出重定向到&#x2F;dev&#x2F;null。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>工具/systemd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>raname批量重命名文件</title>
    <link href="/2024/02/01/f4b7b5e6a7f9/"/>
    <url>/2024/02/01/f4b7b5e6a7f9/</url>
    
    <content type="html"><![CDATA[<blockquote><p>linux rename命令, 正则批量重命名文件<br>安装：apt install rename</p></blockquote><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>man看到的帮助信息不多，根据使用经验来看，正则部分的用法和sed差不多。据查是perl正则。</p><p><strong>参数</strong></p><ul><li><code>-n</code> 仅打印替换效果，不做实际替换</li></ul><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将123替换为2</span><br>$ rename -n <span class="hljs-string">&#x27;s/123/2/&#x27;</span> 123-456.txt <br>rename(123-456.txt, 2-456.txt)<br><br><span class="hljs-comment"># 也可以使用其他字符分割</span><br>$ rename -n <span class="hljs-string">&#x27;s@123@C2@&#x27;</span> 123-456.txt <br>rename(123-456.txt, C2-456.txt)<br><br><span class="hljs-comment"># 默认只替换文件名里面的一次，替换多次</span><br>$ rename -n <span class="hljs-string">&#x27;s@123@C@g&#x27;</span> 123-123-456.txt <br>rename(123-123-456.txt, C-C-456.txt)<br><br><span class="hljs-comment"># 正则分组替换</span><br>$ rename -n <span class="hljs-string">&#x27;s/(12)3/a$1a/g&#x27;</span> 123-123-456.txt <br>rename(123-123-456.txt, a12a-a12a-456.txt)<br><br><span class="hljs-comment"># 一次替换个多文件</span><br>$ rename -n <span class="hljs-string">&#x27;s/(12)3/a$1a/g&#x27;</span> *.txt <br>rename(123-123-456.txt, a12a-a12a-456.txt)<br>rename(123-555.txt, a12a-555.txt)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ipv6源地址选择原理</title>
    <link href="/2024/01/25/d6c93a55c9e0/"/>
    <url>/2024/01/25/d6c93a55c9e0/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>一个接口通常有多个ipv6地址（比如可能存在多个全球地址，多个链路本地地址）。那么设备从接口发包时它会使用哪个地址作为源地址呢？</p><p>假设场景如下：<br>我们设备是路由器，br0有两个链路本地地址：fe80::1&#x2F;64, fe80::2&#x2F;64。<br>路由器下的PC发送dns查询，目的地址为fe80::1，路由器的dns server回包时会使用哪个源地址，fe80::1,还是fe80::2呢？<br>dns server发包时使用的sendto函数，而且socket也没有bind到一个特定的地址上，选择哪个源地址取决于内核的选择。<br>如果使用了fe80::2，那么糟糕，PC可能认为源地址与自己发送的目的地址不一样，丢包，导致无法上网。</p><p><strong>本文主要围绕上面问题来分析地址选择，而略过其他场景下的选择。</strong></p><h1 id="内核选择算法"><a href="#内核选择算法" class="headerlink" title="内核选择算法"></a>内核选择算法</h1><p>选择源地址的函数从<code>ipv6_dev_get_saddr</code>开始。</p><h2 id="use-oif-addrs-only"><a href="#use-oif-addrs-only" class="headerlink" title="use_oif_addrs_only"></a><code>use_oif_addrs_only</code></h2><p>如果目的地址是组播、链路本地地址、或者接口的use_oif_addrs_only配置为1，那么源地址只会从发包接口选择。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /proc/sys/net/ipv6/conf/enp3s0/use_oif_addrs_only <br>0<br></code></pre></td></tr></table></figure><p>use_oif_addrs_only默认为0，即使用全球地址通信时，源地址不一定是出接口上的IP地址。</p><h2 id="ipv6-dev-get-saddr"><a href="#ipv6-dev-get-saddr" class="headerlink" title="__ipv6_dev_get_saddr"></a><code>__ipv6_dev_get_saddr</code></h2><blockquote><p>评选出接口上评分最高的地址。这是选择地址的核心。</p></blockquote><p>它通过以下一系列的标准，从上往下比较两个地址的评分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *Choose an appropriate source address (RFC3484)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>IPV6_SADDR_RULE_INIT = <span class="hljs-number">0</span>,<br>IPV6_SADDR_RULE_LOCAL,<br>IPV6_SADDR_RULE_SCOPE,<br>IPV6_SADDR_RULE_PREFERRED,<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_IPV6_MIP6</span><br>IPV6_SADDR_RULE_HOA,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>IPV6_SADDR_RULE_OIF,<br>IPV6_SADDR_RULE_LABEL,<br>IPV6_SADDR_RULE_PRIVACY,<br>IPV6_SADDR_RULE_ORCHID,<br>IPV6_SADDR_RULE_PREFIX,<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_IPV6_OPTIMISTIC_DAD</span><br>IPV6_SADDR_RULE_NOT_OPTIMISTIC,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>IPV6_SADDR_RULE_MAX<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>IPV6_SADDR_RULE_LOCAL</strong><br>如果目的地址和接口地址相等，那么优先</p><p><strong>IPV6_SADDR_RULE_SCOPE</strong><br>使用范围的比较，这儿实际判断比较复杂，因为地址范围有好几个。<br>可以先简单理解为：在源地址范围大于等于目的地址范围的情况下，地址的使用范围越小，越优先。如果源地址范围小于目的地址范围，那么分值一样。</p><p><strong>IPV6_SADDR_RULE_PREFERRED</strong><br>地址优选期没到期的高于到期的，优选期到期的地址在ip命令里面能看到deprecated标识</p><p><strong>IPV6_SADDR_RULE_OIF</strong><br>优先使用出接口的地址</p><p><strong>IPV6_SADDR_RULE_LABEL</strong><br>如果label与目的地址相同，那么优选这个地址。</p><p><strong>IPV6_SADDR_RULE_PRIVACY</strong><br>优先使用隐私地址(临时地址)。可通过proc配置接口的use_tempaddr，默认为2，默认使用隐私地址。<br>也可通过sockopt配置。</p><p><strong>IPV6_SADDR_RULE_ORCHID</strong><br>不清楚</p><p><strong>IPV6_SADDR_RULE_PREFIX</strong><br>前缀长度，长度越长，越优先。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">ret = ipv6_addr_diff(&amp;score-&gt;ifa-&gt;addr, dst-&gt;addr);<br><span class="hljs-keyword">if</span> (ret &gt; score-&gt;ifa-&gt;prefix_len)<br>ret = score-&gt;ifa-&gt;prefix_len;<br></code></pre></td></tr></table></figure><h2 id="选谁呢"><a href="#选谁呢" class="headerlink" title="选谁呢"></a>选谁呢</h2><p>fe80::1&#x2F;64, fe80::2&#x2F;64这两个地址，用上面的选择算法走一遍，发现都是一样的。比较不出来。。<br>那么用哪个呢？用第一个，看哪个在链表最前面。<br>可以简单的理解为使用最近时间添加的一个，如果fe80::2&#x2F;64是最近添加的，那么就用它。</p><h1 id="接口上的地址顺序"><a href="#接口上的地址顺序" class="headerlink" title="接口上的地址顺序"></a>接口上的地址顺序</h1><p>接口上添加地址的函数如下。<br>地址列表是按照scope排序的。scope表示地址的使用范围，比如常见的全球地址(0x0e)和链路本地地址(0x02)。scope高的在前面，同一scope则是后填加的地址在前面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">ipv6_link_dev_addr(<span class="hljs-keyword">struct</span> inet6_dev *idev, <span class="hljs-keyword">struct</span> inet6_ifaddr *ifp)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> *<span class="hljs-title">p</span>;</span><br><span class="hljs-type">int</span> ifp_scope = ipv6_addr_src_scope(&amp;ifp-&gt;addr);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Each device address list is sorted in order of scope -</span><br><span class="hljs-comment"> * global before linklocal.</span><br><span class="hljs-comment"> */</span><br>list_for_each(p, &amp;idev-&gt;addr_list) &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inet6_ifaddr</span> *<span class="hljs-title">ifa</span></span><br><span class="hljs-class">=</span> list_entry(p, <span class="hljs-keyword">struct</span> inet6_ifaddr, if_list);<br><span class="hljs-keyword">if</span> (ifp_scope &gt;= ipv6_addr_src_scope(&amp;ifa-&gt;addr))<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>list_add_tail_rcu(&amp;ifp-&gt;if_list, p);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们通过ip命令查看到地址列表，和上面的顺序基本吻合</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs maxima"># ip -<span class="hljs-number">6</span> a <span class="hljs-built_in">show</span> dev br0<br><span class="hljs-number">23</span>: br0: &lt;BROADCAST,MULTICAST,ALLMULTI,UP,LOWER_UP&gt; mtu <span class="hljs-number">1500</span> qdisc noqueue state UP group default qlen <span class="hljs-number">1000</span><br>    inet6 <span class="hljs-number">2009</span>::<span class="hljs-number">40</span>:<span class="hljs-number">6002</span>:20ff:fe11:<span class="hljs-number">34b0</span>/<span class="hljs-number">64</span> scope global  全球<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::<span class="hljs-number">100</span>/<span class="hljs-number">64</span> scope link  链路本地，后添加<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::<span class="hljs-number">6002</span>:20ff:fe11:<span class="hljs-number">34b0</span>/<span class="hljs-number">64</span> scope link 链路本地，先添加<br>       valid_lft forever preferred_lft forever<br></code></pre></td></tr></table></figure><p><strong>dadfailed</strong><br>添加一个ipv6地址时，默认会启动地址重复检查。如果dad检查失败，会有一条相关打印，ip命令看到的地址状态如下。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">inet6</span> fe80::<span class="hljs-number">100</span>/<span class="hljs-number">64</span> scope link dadfailed tentative<br></code></pre></td></tr></table></figure><p>dadfailed的地址是无法使用的。 </p><h1 id="左右源地址优先级"><a href="#左右源地址优先级" class="headerlink" title="左右源地址优先级"></a>左右源地址优先级</h1><p>还是最初的场景，要是我们无论如何都想系统使用fe80::2,而不使用fe80::1。要怎么做呢？</p><p>从上面的分析看，有两种方法：<br>（1）添加fe80::1时，设置它的优选期为0就行了。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ip</span> a add fe80::<span class="hljs-number">1</span>/<span class="hljs-number">64</span> dev eth0 preferred_lft <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>（2）缩短地址的前缀长度</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ip</span> a add fe80::<span class="hljs-number">1</span>/<span class="hljs-number">10</span> dev eth0<br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/sinat_20184565/article/details/114433597"># IPv6源地址选择</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>obsidian插件使用</title>
    <link href="/2024/01/19/b17d1fe428c2/"/>
    <url>/2024/01/19/b17d1fe428c2/</url>
    
    <content type="html"><![CDATA[<h1 id="高级表格"><a href="#高级表格" class="headerlink" title="高级表格"></a>高级表格</h1><p>使用tab和enter，自动对齐，比较方便，还可以排序等</p><table><thead><tr><th>fdsf</th><th>fdsf</th><th>sdfsdf</th></tr></thead><tbody><tr><td>ss</td><td>sssssssssssssss</td><td>dddddddddddddd</td></tr><tr><td>fdsffdsfdsfdsfs</td><td>fdsfds</td><td>s</td></tr></tbody></table><h1 id="admonition"><a href="#admonition" class="headerlink" title="admonition"></a>admonition</h1><p>更美观的东西</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ad-bug">不清楚为啥有问题<br></code></pre></td></tr></table></figure><p>自定义标题和默认折叠（折叠这个功能很有用，可以折叠大段代码）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ad-error">title: 代码<br>collapse: close<br><br>```c<br>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;string.h&gt;<br><br>int main(int argc, char *argv[])<br>&#123;<br>    /* code */<br>    return 0;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ad-note">污染问题，和其他markdown解析器不兼容，肯定会存在一点点。不要用太高级的就行。<br>比方说通过hexo发布，就不会支持这些语法。<br></code></pre></td></tr></table></figure><h1 id="Number-headings"><a href="#Number-headings" class="headerlink" title="Number headings"></a>Number headings</h1><p>自动编号的插件。<br>它和以前用过的修改CSS的原理不一样，这个是修改源文件，添加了编号。<br>可通过ctrl+p， number移除编号和添加编号。建议不开自动编号，内容多的文章，ctrl+p打开自动编号。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu设置远程唤醒(wakeonlan)</title>
    <link href="/2024/01/17/73144aec8858/"/>
    <url>/2024/01/17/73144aec8858/</url>
    
    <content type="html"><![CDATA[<p>关键字：远程开机</p><blockquote><p>一般的主板都有网络唤醒功能(wake-on-lan)，但从来没有使用过。这个功能可以让一台关机的设备收到特定包后唤醒开机。<br>本文主要介绍linux下的操作，windows上同理也支持，只是设置方法不一样。</p></blockquote><h1 id="设置方法"><a href="#设置方法" class="headerlink" title="设置方法"></a>设置方法</h1><p>网络唤醒需要两台电脑，一台待唤醒电脑，一台唤醒别人的电脑。</p><h2 id="待唤醒电脑配置"><a href="#待唤醒电脑配置" class="headerlink" title="待唤醒电脑配置"></a>待唤醒电脑配置</h2><p>待唤醒电脑需要开启wake-on-lan功能。<br>（1）设置主板bios，开启wake-on-lan。</p><p>（2）得到网卡的mac地址</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">leon</span>@leon-ssd:~$ ifconfig eth2 | grep ether<br>        <span class="hljs-attribute">ether</span> f4:<span class="hljs-number">6</span>b:<span class="hljs-number">8</span>c:<span class="hljs-number">65</span>:<span class="hljs-number">61</span>:<span class="hljs-number">0</span>f  txqueuelen <span class="hljs-number">1000</span>  (以太网)<br></code></pre></td></tr></table></figure><p>（3）设置网卡的wake-on-lan为magic packet激活。<br>查看当前状态</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">leon<span class="hljs-meta">@leon</span>-ssd:~$ sudo ethtool eth2 | grep Wake-<span class="hljs-keyword">on</span><br>        Supports Wake-<span class="hljs-keyword">on</span>: pumbg<br>        Wake-<span class="hljs-keyword">on</span>: g<br></code></pre></td></tr></table></figure><p>各个标志位的含义如下：</p><ul><li><strong>d:</strong> Disabled</li><li><strong>p:</strong> PHY Activity</li><li><strong>u:</strong> Unicast Activity</li><li><strong>m:</strong> Multicast Activity</li><li><strong>b:</strong> Broadcast Activity</li><li><strong>a:</strong> ARP Activity</li><li><strong>g:</strong> Magic Packet Activity</li></ul><p><strong>设置为magic激活:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> ethtool -s eth2 wol g<br></code></pre></td></tr></table></figure><p>（4）开机自动设置wake-on-lan<br><code>sudo vi /lib/systemd/system/wakeonlan.service</code>， 写入如下内容</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=Enable Wake <span class="hljs-literal">On</span> Lan<br><br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">Type</span>=<span class="hljs-literal">on</span>eshot<br><span class="hljs-attr">ExecStart</span>=/usr/sbin/ethtool -s eth2 wol g<br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=basic.target<br></code></pre></td></tr></table></figure><p>再执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl <span class="hljs-built_in">enable</span> wakeonlan.service<br></code></pre></td></tr></table></figure><h2 id="唤醒方法"><a href="#唤醒方法" class="headerlink" title="唤醒方法"></a>唤醒方法</h2><p>同一个lan网络下的其他设备，如ubuntu系统，安装wakeonlan，然后执行如下命令即可：<br>mac为待唤醒设备的mac。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">wakeonlan</span> f4:<span class="hljs-number">6</span>b:<span class="hljs-number">8</span>c:<span class="hljs-number">65</span>:<span class="hljs-number">61</span>:<span class="hljs-number">0</span>f<br></code></pre></td></tr></table></figure><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>（1）网卡不能为USB网卡，无线网卡。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://pimylifeup.com/ubuntu-enable-wake-on-lan/">How to Enable Wake-on-LAN on Ubuntu</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>UBI简介</title>
    <link href="/2024/01/11/d1f17d6e484c/"/>
    <url>/2024/01/11/d1f17d6e484c/</url>
    
    <content type="html"><![CDATA[<blockquote><p>主要是翻译和自己的碎碎念 </p></blockquote><h1 id="1-UBI-Unsorted-Block-Images"><a href="#1-UBI-Unsorted-Block-Images" class="headerlink" title="1. UBI - Unsorted Block Images"></a>1. UBI - Unsorted Block Images</h1><h2 id="1-1-注意"><a href="#1-1-注意" class="headerlink" title="1.1. 注意"></a>1.1. 注意</h2><p>人们经常对 UBI 感到困惑，这就是创建此部分的原因。请注意：</p><ul><li>UBI 不是闪存转换层 (FTL)，它与 FTL 无关；</li><li>UBI 与裸闪存配合使用，不适用于 <code>MMC</code> 、 <code>RS-MMC</code> 、 <code>eMMC</code> 、 <code>SD</code> 、 <code>mini-SD</code> 、 <code>micro-SD</code> 、 <code>CompactFlash</code> 、 <code>MemoryStick</code> 、 <code>USB flash drive</code> 等消费类闪存；相反，UBI 与原始闪存设备配合使用，这些设备主要用于移动电话等嵌入式设备。</li></ul><p>请不要混淆。在<a href="http://www.linux-mtd.infradead.org/doc/ubifs.html#L_raw_vs_ftl">此处</a>阅读有关原始闪存设备与 FTL 设备有何不同的更多信息。</p><h2 id="1-2-概述"><a href="#1-2-概述" class="headerlink" title="1.2.  概述"></a>1.2.  概述</h2><p>UBI（拉丁语：“哪里？”）代表“未分类块映像”。它是一个原始闪存设备的卷管理系统，它在单个物理闪存设备上管理多个逻辑卷，并将 I&#x2F;O 负载（即磨损均衡）分布到整个闪存芯片。</p><p>从某种意义上说，UBI 可以与逻辑卷管理器 (LVM) 相比较。LVM 将逻辑扇区映射到物理扇区，而 UBI 将逻辑擦除块映射到物理擦除块。但除了映射之外，UBI 还实现了全局磨损均衡和透明错误处理。</p><p>UBI 卷是一组连续的<code>逻辑擦除块</code> (LEB)。每个逻辑擦除块都动态映射到一个<code>物理擦除块</code> (PEB)。此映射由 UBI 管理，对用户和更高级别的软件隐藏。UBI 是提供全局磨损均衡、每个物理擦除块擦除计数器以及将数据从磨损更严重的物理擦除块透明地移动到磨损较轻的物理擦除块的能力的基本机制。</p><p>创建卷时指定 UBI 卷大小，但稍后可以更改（卷可以动态调整大小）。有可用于操作 UBI 卷的用户空间工具。</p><p>UBI 卷有 2 种类型：动态卷和静态卷。静态卷是只读的，其内容受 <code>CRC-32</code> 校验和保护，而动态卷是可读写的，上层（例如文件系统）负责确保数据完整性。</p><p>静态卷通常用于内核、initramfs 和 dtb。打开时，较大的静态卷可能会产生重大损失，因为此时需要计算 <code>CRC-32</code> 。如果您想将静态卷用于除内核、initramfs 或 dtb 之外的任何内容，那么您很可能做错了，最好改用动态卷。</p><p>UBI 了解有问题的擦除块（即随着时间推移而磨损的闪存部分），并使高级软件不必自行处理有问题的擦除块。UBI 拥有预留物理擦除块的池，当物理擦除块变坏时，它会用好的物理擦除块透明地替换它。UBI 将数据从新发现的有问题的物理擦除块移至好的物理擦除块。结果是，UBI 卷的用户不会注意到 I&#x2F;O 错误，因为 UBI 会透明地处理这些错误。</p><p>NAND 闪存还容易出现读取和写入操作时发生的位翻转错误。位翻转由 ECC 校验和更正，但它们可能会随着时间的推移而累积并导致数据丢失。UBI 通过将数据从具有位翻转的物理擦除块移至其他物理擦除块来处理此问题。此过程称为擦洗。擦洗在后台透明地完成，对上层隐藏。</p><p>以下是 UBI 的主要功能的简短列表：</p><ul><li>UBI 提供可以动态创建、删除或调整大小的卷；</li><li>UBI 在整个闪存设备中实现磨损均衡（即，您可能认为您正在连续写入&#x2F;擦除 UBI 卷的同一逻辑擦除块，但 UBI 会将其扩展到闪存芯片的所有物理擦除块）；</li><li>UBI 透明地处理不良的物理擦除块；</li><li>UBI 通过擦洗最大程度地减少丢失数据的可能性。</li></ul><p>以下是 MTD 分区和 UBI 卷的比较。它们有些相似，因为：</p><ul><li>两者都由擦除块组成 - 对于 UBI 卷是逻辑擦除块，对于 MTD 分区是物理擦除块；</li><li>两者都支持三种基本操作：读取、写入和擦除。</li></ul><p>但 UBI 卷相对于 MTD 分区具有以下优势：</p><ul><li>UBI 实现磨损均衡，因此用户根本不必关心这一点，这意味着上层软件可能更简单；</li><li>UBI 处理坏擦除块，这也导致更简单的上层软件；</li><li>UBI 卷是动态的，这意味着它们可以动态创建、删除或调整大小，而 MTD 分区是静态的；</li><li>UBI 处理位翻转，这再次简化了上层软件；</li><li>UBI 提供卷更新操作，这使得检测中断的软件更新和恢复变得容易；</li><li>UBI 提供原子逻辑擦除块更改操作，该操作允许在操作期间发生不干净的重新引导时更改逻辑擦除块的内容而不丢失数据；这对于上层软件（例如，对于文件系统）可能非常有用；</li><li>UBI 有一个取消映射操作，它只是将逻辑擦除块从物理擦除块取消映射，后台来调度物理擦除，然后返回；这非常快，并且使上层软件无需实现自己的机制来延迟擦除（例如，JFFS2 必须实现此类机制）。</li></ul><p>UBI 还提供了一个块设备，允许常规面向块的文件系统安装在 UBI 卷之上。这是可能的，因为 UBI 以透明的方式处理坏块。</p><p>有一个名为 <code>gluebi</code> 的附加驱动程序，它在 UBI 卷之上模拟 MTD 设备。这看起来有点奇怪，因为 UBI 在 MTD 设备之上工作，然后 <code>gluebi</code> 在其之上模拟其他 MTD 设备，但这实际上可行，并且使得现有软件（例如，JFFS2）可以在 UBI 卷之上运行。但是，新软件可能会受益于高级 UBI 功能，并让 UBI 解决闪存技术强加的许多问题。</p><p>gluebi的内核配置为<code>CONFIG_MTD_UBI_GLUEBI</code>，它在创建删除卷时注册和注销mtd，对该mtd的访问实际是ubi的回调。</p><h2 id="1-3-Power-cuts-tolerance-断电容忍"><a href="#1-3-Power-cuts-tolerance-断电容忍" class="headerlink" title="1.3. Power-cuts tolerance - 断电容忍"></a>1.3. Power-cuts tolerance - 断电容忍</h2><p>UBI 和 UBIFS 的设计都考虑到了对断电的容忍度。</p><p>UBI 具有一个内部调试基础架构，可以模拟电源故障以进行测试。模拟的优点在于，它在将控制数据结构写入设备的关键点模拟电源故障，而使用物理断电测试在那些精确时刻中断系统的概率相当低。</p><h2 id="1-4-用户空间工具"><a href="#1-4-用户空间工具" class="headerlink" title="1.4. 用户空间工具"></a>1.4. 用户空间工具</h2><ul><li><code>ubinfo</code> - 提供有关系统中找到的 UBI 设备和卷的信息；</li><li><code>ubiattach</code> - 将 MTD 设备（描述原始闪存）与 UBI 相关联，从而创建相应的 UBI 设备；</li><li><code>ubidetach</code> - 将 MTD 设备从 UBI 设备分离（与 <code>ubiattach</code> 所做的相反）；</li><li><code>ubimkvol</code> - 在 UBI 设备上创建 UBI 卷；</li><li><code>ubirmvol</code> - 从 UBI 设备中删除 UBI 卷；</li><li><code>ubiblock</code> - 管理 UBI 卷的块接口；</li><li><code>ubiupdatevol</code> - 更新 UBI 卷；此工具使用 UBI 卷更新功能，如果更新中断，则会使卷处于“损坏”状态；此外，此工具可用于清除 UBI 卷；</li><li><code>ubicrc32</code> - 计算 <code>CRC-32</code> 文件的校验和，其初始种子与 UBI 使用的相同；</li><li><code>ubinize</code> - 生成 UBI 映像；</li><li><code>ubiformat</code> - 格式化空闪存，擦除闪存并保留擦除计数器，将 UBI 映像闪存到 MTD 设备；</li><li><code>mtdinfo</code> - 报告系统中找到的 MTD 设备的信息。</li></ul><h2 id="1-5-UBI-头"><a href="#1-5-UBI-头" class="headerlink" title="1.5. UBI 头"></a>1.5. UBI 头</h2><p>UBI 在每个非坏物理擦除块的开头存储 2 个小的 64 字节头：</p><ul><li><strong>erase counter header</strong><br>  擦除计数器头（或 EC 头），其中包含物理擦除块 (PEB) 的擦除计数器以及其他信息；</li><li><strong>volume identifier header</strong><br>  卷标识符头（或 VID 头），其中存储卷 ID 和此 PEB 所属的逻辑擦除块 (LEB) 编号。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ubi_ec_hdr</span> &#123;</span><br>__be32  magic;  <span class="hljs-comment">// UBI#</span><br>__u8    version;<br>__u8    padding1[<span class="hljs-number">3</span>];<br>__be64  ec; <span class="hljs-comment">/* Warning: the current limit is 31-bit anyway! */</span><br>__be32  vid_hdr_offset;<br>__be32  data_offset;<br>__be32  image_seq;<br>__u8    padding2[<span class="hljs-number">32</span>];<br>__be32  hdr_crc;<br>&#125; __packed;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ubi_vid_hdr</span> &#123;</span><br>__be32  magic;   <span class="hljs-comment">// UBI!</span><br>__u8    version;<br>__u8    vol_type;<br>__u8    copy_flag;<br>__u8    compat;<br>__be32  vol_id;<br>__be32  lnum;<br>__u8    padding1[<span class="hljs-number">4</span>];<br>__be32  data_size;<br>__be32  used_ebs;<br>__be32  data_pad;<br>__be32  data_crc;<br>__u8    padding2[<span class="hljs-number">4</span>];<br>__be64  sqnum;<br>__u8    padding3[<span class="hljs-number">12</span>];<br>__be32  hdr_crc;<br>&#125; __packed;<br></code></pre></td></tr></table></figure><p>这就是为什么逻辑擦除块小于物理擦除块的原因 - 头部占用了一些闪存空间。</p><p>所有 UBI 头都受 <code>CRC-32</code> 校验和保护。有关头内容的更多信息，请参阅 Linux 内核中的 <code>drivers/mtd/ubi/ubi-media.h</code> 文件。</p><p>当 UBI 连接 MTD 设备时，它必须扫描该设备，读取所有头文件，检查 <code>CRC-32</code> 校验和，并将擦除计数器和逻辑到物理擦除块映射信息存储在 RAM 中。有关与此相关的可伸缩性问题的信息，请参阅本节。</p><p>UBI 擦除 PEB 后，它会增加擦除计数器值并将其写入 EC 头文件。这意味着 PEB 始终具有有效的 EC 头文件，除了擦除后和写入 EC 头文件之前的那段短暂时间除外。如果在此短暂时间内发生意外重启，则 EC 头文件将丢失或损坏。在这种情况下，UBI 会在完成 MTD 设备扫描后立即使用平均擦除计数器写入新的 EC 头文件。</p><p>当 UBI 将 VID 头文件与 LEB 关联时，会将其写入 PEB。让我们考虑一下在某些 UBI 操作期间头文件会发生什么情况。</p><ul><li>LEB 取消映射操作只是将 LEB 从 PEB 取消映射，并将 PEB 安排为擦除。擦除 PEB 时，会立即写入 EC 头文件。不会写入 VID 头文件。</li><li>LEB 映射操作或对未映射 LEB 的写操作使 UBI 找到一个合适的 PEB 并将 VID 头写入其中（EC 头必须已存在）。请注意，对已映射 LEB 的写操作只是将数据直接写入 PEB，而不会更改 UBI 头。</li></ul><p>UBI 维护两个每个 PEB 的头，因为它需要在不同的时间向闪存写入不同的信息：</p><ul><li>PEB 被擦除后，立即写入 EC 头，这最大程度地降低了由于意外重启而丢失擦除计数器的可能性；</li><li>当 UBI 将 PEB 与 LEB 关联时，将 VID 头写入 PEB。</li></ul><p>当 EC 头写入 PEB 时，UBI 还不了解卷 ID 或此 PEB 将与之关联的 LEB 编号。这就是为什么 UBI 需要执行两个单独的写操作并拥有两个单独的头的原因。</p><h2 id="1-6-UBI-卷表"><a href="#1-6-UBI-卷表" class="headerlink" title="1.6. UBI 卷表"></a>1.6. UBI 卷表</h2><p>卷表是一个闪存数据结构，其中包含有关此 UBI 设备上每个卷的信息。卷表是一个记录卷表的数组。每个记录包含以下信息：</p><ul><li>volume size; 卷大小；</li><li>volume name; 卷名；</li><li>volume type ;  卷类型（动态或静态）；</li><li>volume alignment; 卷对齐；</li><li><a href="http://www.linux-mtd.infradead.org/doc/ubi.html#L_volupdate">update marker</a> 更新标记（在启动更新时设置在卷上，并在成功完成时清除）；</li><li><a href="http://www.linux-mtd.infradead.org/doc/ubi.html#L_autoresize">auto-resize</a> flag; 自动调整大小标志；</li><li>CRC-32 此记录的校验和。</li></ul><p>每条记录描述一个 UBI 卷。卷表数组中的记录索引对应于它描述的卷 ID。即，UBI 卷 0 由卷表中的记录 0 描述，依此类推。卷表中的记录总数受 LEB 大小限制，不能大于 128。这意味着 UBI 设备不能有超过 128 个卷。</p><p>每次创建、删除、调整大小、重命名或更新 UBI 卷时，都会更改相应的卷表记录。出于可靠性和断电容差的原因，UBI 维护卷表的两个副本。</p><h3 id="1-6-1-实现细节"><a href="#1-6-1-实现细节" class="headerlink" title="1.6.1. 实现细节"></a>1.6.1. 实现细节</h3><p>在内部，卷表驻留在一个称为布局卷的专用 UBI 卷中。此卷由 2 个 LEB 组成 - 一个用于卷表的每个副本。布局卷是一个“内部”UBI 卷，用户看不到它也无法访问它。在读取或写入布局卷时，UBI 使用与普通用户卷相同的机制。</p><p>UBI 在更新卷表记录时使用以下算法：</p><ul><li>Prepare an in-memory buffer with the new volume table contents.<br>  使用新卷表内容准备一个内存中缓冲区。</li><li><a href="http://www.linux-mtd.infradead.org/doc/ubi.html#L_unmap">Un-map</a> LEB0 of the layout volume.<br>  取消映射布局卷的 LEB0。</li><li>Write the new volume table to LEB0.<br>  将新卷表写入 LEB0。</li><li>Un-map LEB1 of the layout volume.<br>  取消映射布局卷的 LEB1。</li><li>Write the new volume table to LEB1.<br>  将新卷表写入 LEB1。</li><li>Flush the UBI work queue to make sure the PEBs are corresponding to the un-mapped LEBs are erased.<br>  刷新 UBI 工作队列，以确保与未映射 LEB 相对应的 PEB 已擦除。</li></ul><p>在连接 MTD 设备时，UBI 会确保 2 个卷表副本是等效的。如果它们不等效，这可能是由不干净的重新启动引起的，UBI 会从 LEB0 中选择一个并将其复制到布局卷的 LEB1（因为根据上面指定的算法，LEB0 是首先更新的，因此被认为具有最新信息）。如果卷表副本之一已损坏，UBI 会从另一个卷表副本中恢复它。</p><h2 id="1-7-最小-flash-input-x2F-output-单元"><a href="#1-7-最小-flash-input-x2F-output-单元" class="headerlink" title="1.7. 最小 flash input&#x2F;output 单元"></a>1.7. 最小 flash input&#x2F;output 单元</h2><p>UBI 使用闪存的抽象模型。简而言之，从 UBI 的角度来看，闪存（或 MTD 设备）由擦除块组成，这些擦除块可能是好的或坏的。可以从每个好的擦除块读取、写入或擦除。好的擦除块也可以标记为坏的。</p><p>闪存读取和写入只能以最小输入&#x2F;输出单元大小的倍数进行，这取决于闪存类型。</p><ul><li>NOR 闪存通常具有 1 字节的最小 I&#x2F;O 单元大小，因为 NOR 闪存通常允许读取和写入单个字节（事实上，甚至可以更改各个位）。</li><li>某些 NOR 闪存可能具有其他最小 I&#x2F;O 单元大小，例如在 ECC NOR 闪存的情况下为 16 或 32 字节。</li><li>NAND 闪存通常具有 512、2048 或 4096 字节的最小 I&#x2F;O 大小，这对应于它们的页大小。NAND 闪存将每页 ECC 代码存储在 OOB 区域中，这意味着必须一次写入整个 NAND 页才能计算 ECC，并且必须一次读取整个 NAND 页才能检查 ECC。</li></ul><p>最小 I&#x2F;O 单元大小是 MTD 设备的一个非常重要的特性。它影响很多事情，例如：</p><ul><li>VID 头的物理位置取决于最小 I&#x2F;O 单元大小，这意味着 LEB 大小也取决于它；通常，最小 I&#x2F;O 单元大小越大，LEB 大小越小，因此 UBI 闪存空间开销越大；</li><li>对 LEB 的所有写入都应与最小 I&#x2F;O 单元大小对齐，并且应为最小 I&#x2F;O 单元大小的倍数；这不适用于读取，但请记住，在 MTD 级别上，所有读取都是以最小 I&#x2F;O 单元大小的倍数完成的；这只是通过缓冲读取数据并将仅请求的字节量复制到用户缓冲区来对用户隐藏。</li></ul><h2 id="1-8-NAND-flash-sub-pages-NAND-闪存子页"><a href="#1-8-NAND-flash-sub-pages-NAND-闪存子页" class="headerlink" title="1.8. NAND flash sub-pages NAND 闪存子页"></a>1.8. NAND flash sub-pages NAND 闪存子页</h2><p>如前所述，所有 UBI I&#x2F;O 都以最小 I&#x2F;O 单元大小的倍数执行，这相当于 NAND 设备的页大小（在 NAND 闪存的情况下）。但是，某些 SLC NAND 闪存允许更小的 I&#x2F;O 单元，在 MTD 术语中称为子页。并非所有 NAND 设备都有子页。</p><ul><li>截至 2009 年 4 月，MLC NAND 没有子页。</li><li>SLC NAND 通常具有子页。例如，512 字节 NAND 页通常由 2x256 字节子页组成，2048 字节 NAND 页通常由 4x512 字节子页组成。</li><li>具有 2048 字节 NAND 页的 SLC OneNAND 芯片具有 4x512 字节子页。</li></ul><p>如果 NAND 闪存支持子页，则可以按子页为单位计算 ECC 代码，而不是按页为单位计算。在这种情况下，可以独立读写子页。</p><p>但是，即使 NAND 芯片可能支持子页，SoC 的 NAND 控制器也可能不支持。如果闪存由仅按页为单位计算 ECC 代码的控制器管理，则无法以子页块为单位执行 I&#x2F;O。例如，OLPC XO-1 笔记本电脑就是这种情况 - 它的 NAND 芯片支持子页，但 NAND 控制器不支持。</p><p>注意，术语“子页”是 MTD 术语，但它也称为“NOP”，代表“部分程序数”。NOP1 NAND 闪存没有子页 - UBI 将它们视为具有与 NAND 页大小相等的子页大小的 NAND。NOP2 NAND 闪存有 2 个子页（每个为半个 NAND 页），NOP4 闪存有 4 个子页（每个为四分之一 NAND 页）。</p><p>UBI 利用子页来减少闪存空间开销。如果可以使用子页，则可以减少此开销（请参阅此处）。考虑一个具有 128KiB 擦除块和 2048 字节页面的 NAND 闪存。如果没有子页，UBI 将 VID 头部放在物理偏移量 2048，因此 LEB 大小变为 124KiB（128KiB 减去一个存储 EC 头部的 NAND 页，再减去一个存储 VID 头部的 NAND 页）。相反，如果 NAND 闪存确实具有子页，则 UBI 将 VID 头部放在物理偏移量 512（第二个子页），因此 LEB 大小变为 126KiB（128KiB 减去一个用于存储两个 UBI 头部的 NAND 页）。请参阅本部分以获取有关 UBI 头部存储位置的更多信息。</p><p>子页面仅由 UBI 内部使用，并且仅用于存储头。UBI API 不允许用户对子页面单元执行 I&#x2F;O。原因之一是子页面写入可能很慢。要写入子页面，驱动程序实际上可能会写入整个 NAND 页，但在与此操作无关的子页面中放入 <code>0xFF</code> 个字节。如果是这种情况，写入 4 个子页面将比一次写入整个 NAND 页慢 4 倍。因此，UBI 确实对头使用子页面，但此技巧不适用于 UBI API。</p><h2 id="1-9-UBI-头位置"><a href="#1-9-UBI-头位置" class="headerlink" title="1.9. UBI 头位置"></a>1.9. UBI 头位置</h2><p>EC 头始终位于偏移量 0 处，占用 64 个字节，VID 头位于下一个可用的最小 I&#x2F;O 单元或子页面，也占用 64 个字节。例如：</p><ul><li>对于具有 1 字节最小 I&#x2F;O 单元的 NOR 闪存，VID 头位于偏移量 64；</li><li>对于没有子页面的 NAND 闪存，VID 头位于第二个 NAND 页；</li><li>对于具有子页面的 NAND 闪存，VID 头位于第二个子页面。</li></ul><h2 id="1-10-Flash-space-overhead-闪存空间开销"><a href="#1-10-Flash-space-overhead-闪存空间开销" class="headerlink" title="1.10. Flash space overhead 闪存空间开销"></a>1.10. Flash space overhead 闪存空间开销</h2><p>UBI 将一些闪存空间用于其自身目的，从而减少了可供 UBI 用户使用的闪存空间。即：</p><ul><li>2 个 PEB 用于存储卷表；</li><li>1 个 PEB 用于磨损均衡目的；</li><li>1 个 PEB 用于原子 LEB 更改操作；</li><li>一些 PEB 用于处理坏 PEB；这适用于 NAND 闪存，但不适用于 NOR 闪存；默认情况下，保留的 PEB 数量可配置，等于每 1024 个块中的 20 个块；</li><li>UBI 将 EC 和 VID 头部存储在每个 PEB 的开头；用于这些目的的字节数取决于闪存类型，如下所述。</li></ul><p>我们引入符号：</p><ul><li>W - 闪存芯片上的物理擦除块总数（注意：整个芯片，而非 MTD 分区）；</li><li>P - MTD 分区上的物理擦除块总数；</li><li>S P - 物理擦除块大小；</li><li>S L - 逻辑擦除块大小；</li><li>B B - MTD 分区上的坏块数；</li><li>B R - 为坏 PEB 处理预留的 PEB 数量（对于 NAND，默认值为 20 * W&#x2F;1024，对于 NOR 和其他没有坏 PEB 的闪存类型，默认值为 0）；</li><li>B - MAX(BR,BB);</li><li>O - 与以字节为单位存储 EC 和 VID 头相关联的开销，即 O &#x3D; S P - S L 。</li></ul><p>UBI 开销为 (B + 4) * S P + O * (P - B - 4)，即用户无法访问此数量的字节。O 因闪存的不同而不同：</p><ul><li>对于具有 1 字节最小 I&#x2F;O 单元的 NOR 闪存，O 为 128 字节；</li><li>对于没有子页的 NAND 闪存（例如，MLC NAND），O 为 2 个 NAND 页，即在 2KiB NAND 页的情况下为 4KiB，在 512 字节 NAND 页的情况下为 1KiB；</li><li>对于具有子页的 NAND 闪存，UBI 优化了其闪存布局，并将 EC 和 VID 头部放在同一个 NAND 页，但不同的子页；在这种情况下，O 仅为一个 NAND 页；</li><li>对于其他闪存，如果最小 I&#x2F;O 单元大小大于或等于 64 字节，则开销应为 2 个最小 I&#x2F;O 单元；如果最小 I&#x2F;O 单元大小小于 64 字节，则开销应为 2 乘以 64 字节，并与最小 I&#x2F;O 单元大小对齐。</li></ul><p><strong>算一下手上一块128MB的nand flash实际用了多少</strong><br>mtdinfo -a查看一下mtd信息，如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">mtd2</span><br><span class="hljs-attr">Name:</span>                           <span class="hljs-string">image</span><br><span class="hljs-attr">Type:</span>                           <span class="hljs-string">nand</span><br><span class="hljs-attr">Eraseblock size:</span>                <span class="hljs-number">131072</span> <span class="hljs-string">bytes,</span> <span class="hljs-number">128.0</span> <span class="hljs-string">KiB</span><br><span class="hljs-attr">Amount of eraseblocks:</span>          <span class="hljs-number">1000</span> <span class="hljs-string">(131072000</span> <span class="hljs-string">bytes,</span> <span class="hljs-number">125.0</span> <span class="hljs-string">MiB)</span><br><span class="hljs-attr">Minimum input/output unit size:</span> <span class="hljs-number">2048 </span><span class="hljs-string">bytes</span><br><span class="hljs-attr">Sub-page size:</span>                  <span class="hljs-number">2048 </span><span class="hljs-string">bytes</span><br><span class="hljs-attr">OOB size:</span>                       <span class="hljs-number">64</span> <span class="hljs-string">bytes</span><br><span class="hljs-attr">Character device major/minor:</span>   <span class="hljs-number">90</span><span class="hljs-string">:4</span><br><span class="hljs-attr">Bad blocks are allowed:</span>         <span class="hljs-literal">true</span><br><span class="hljs-attr">Device is writable:</span>             <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>我们的ubi连接的mtd2, 有1000个块，物理擦除块儿大小128KB，子页大小2KB，计算结果如下（处理坏块预留的PEB在ubinfo -a中可以查到为20）<br><code>(1000-4)*4096 + 24*131072=7056KB</code><br>就是说开销有7M。</p><h2 id="1-11-UBI-闪存器的工作原理"><a href="#1-11-UBI-闪存器的工作原理" class="headerlink" title="1.11. UBI 闪存器的工作原理"></a>1.11. UBI 闪存器的工作原理</h2><p>以下是 UBI 闪存器程序在擦除闪存或写入 UBI 映像时必须执行的操作列表。</p><ul><li><p>首先，扫描闪存并收集擦除计数器。即，它从每个 PEB 读取 EC 头，检查头部的 <code>CRC-32</code> 校验和，并将擦除计数器保存在 RAM 中。无需读取 VID 头。应跳过坏 PEB。</p></li><li><p>接下来，计算平均擦除计数器。这将用于具有损坏或丢失的 EC 头的 PEB。此类 PEB 可能由于意外重启而发生，但数量不应太多。</p></li><li><p>如果仅仅只是擦除闪存，那么必须擦除每个 PEB，并且必须在 PEB 的开头写入适当的 EC 头。EC 头应包含更新的擦除计数器。应跳过不良 PEB。对于 NAND 闪存，在擦除或写入时出现 I&#x2F;O 错误的情况下，应将 PEB 标记为不良（在此处查看有关 UBI 如何将 PEB 标记为不良的更多信息）。</p></li><li><p>如果打算写入 UBI 映像，那么闪存器应针对每个非坏 PEB 执行以下操作。  </p><ul><li>从 UBI 映像（PEB 大小字节）中读取此 PEB 的内容到缓冲区。</li><li>从缓冲区的末尾剥离充满 <code>0xFF</code> 字节的最小 I&#x2F;O 单元（详细信息如下）。</li><li>擦除 PEB。</li><li>更改缓冲区中的 EC 头 - 在此处放置新的擦除计数器值并重新计算 <code>CRC-32</code> 校验和。</li><li>将缓冲区写入物理擦除块。</li></ul><p>  一如既往，应跳过坏 PEB，对于 NAND 闪存，如果在擦除或写入时发生 I&#x2F;O 错误，则应将 PEB 标记为坏。</p></li></ul><p>实际上，输入 UBI 映像大小通常比闪存大小小，因此闪存器必须正确刷新已使用的 PEB，并正确擦除未使用的 PEB。</p><p>注意，在写入 UBI 映像时，输入 UBI 映像中的擦除块写入何处并不重要。例如，第一个输入擦除块可以写入第一个 PEB，也可以写入第二个或最后一个。</p><p>还要注意，如果您在生产时创建闪存器来写入 UBI 映像（即新闪存，仅一次），那么闪存器不必更改输入 UBI 映像的 EC 头，因为这是新闪存，并且每个 PEB 都有零擦除计数器。这意味着生产线闪存器可能会更简单。</p><p>如果您的 UBI 映像包含 UBIFS 文件系统，并且您的闪存是 NAND，则可能必须在输入 PEB 数据的末尾插入 <code>0xFF</code> 字节。这一点非常重要，尽管并非所有 NAND 闪存都要求这样做。有时，不这样做可能会导致非常不愉快的问题，以后可能很难调试。因此，我们建议始终这样做。</p><p>原因在于 UBIFS 将仅包含 <code>0xFF</code> 字节的 NAND 页（我们称之为“空 NAND 页”）视为可用。例如，假设 PEB 的第一个 NAND 页包含一些数据，第二个是空的，第三个也包含一些数据，第四个以及其余的 NAND 页也是空的。在这种情况下，UBIFS 将从第四个开始的所有 NAND 页视为可用，并将数据写入那里。如果闪存程序已将 <code>0xFF</code> 写入这些页，那么任何新的 UBIFS 数据都会导致第二次写入。但是，许多 NAND 闪存要求仅写入 NAND 页一次，即使数据仅包含 <code>0xFF</code> 字节。</p><p>换句话说，写入 <code>0xFF</code> 字节可能会产生副作用。闪存器必须做的是在写入 PEB 缓冲区之前从 PEB 缓冲区的末尾删除所有空 NAND 页。不必删除所有空 NAND 页，只需删除最后一个即可。这意味着闪存器不必扫描整个缓冲区以查找 <code>0xFF</code> 。只需从末尾扫描缓冲区，然后在第一个非 <code>0xFF</code> 字节处停止即可。这要快得多。</p><h2 id="1-12-标记擦除块为坏块"><a href="#1-12-标记擦除块为坏块" class="headerlink" title="1.12. 标记擦除块为坏块"></a>1.12. 标记擦除块为坏块</h2><p>此部分与 NAND 闪存以及表现出坏擦除块的其他闪存相关。UBI 在以下 2 种情况下将物理擦除块标记为坏块：</p><ul><li>擦除块写入操作失败，在这种情况下，UBI 将数据从该 PEB 移动到其他 PEB（数据恢复），并安排对该 PEB 进行折磨(torturing)；</li><li>擦除操作失败，错误为 <code>EIO</code> ，在这种情况下，擦除块立即标记为坏块。</li></ul><p>折磨在后台进行，目的是检测物理擦除块是否实际上是坏块。写入失败可能出于多种原因，包括驱动程序或文件系统等上层内容中的错误（例如，FS 错误地多次写入同一 NAND 页）。在折磨期间，UBI 执行以下操作：</p><ul><li>擦除擦除块；</li><li>回读并确保它只包含 0xFF 字节；</li><li>写入测试模式字节；</li><li>回读擦除块并检查模式；</li><li>依此类推，针对多个模式（ <code>0xA5</code> 、 <code>0x5A</code> 、 <code>0x00</code> ）执行。</li></ul><p>如果擦除块经受住了严酷测试，则不会将其标记为坏块。但是，严酷测试期间的位翻转是将擦除块标记为坏块的充分理由。有关详细信息，请参阅 <code>torture_peb()</code> 函数。</p><h2 id="1-13-用于坏块处理的保留块（仅适用于-NAND-芯片）"><a href="#1-13-用于坏块处理的保留块（仅适用于-NAND-芯片）" class="headerlink" title="1.13. 用于坏块处理的保留块（仅适用于 NAND 芯片）"></a>1.13. 用于坏块处理的保留块（仅适用于 NAND 芯片）</h2><p>众所周知，NAND 芯片具有一定数量的物理擦除块，制造商将其标记为坏块。在 NAND 设备的使用寿命期间，可能会出现其他坏块。尽管如此，制造商通常会保证前几个物理擦除块不是坏块，并且坏 PEB 的总数不会超过一定数量。例如，一块 256MiB（2048 个 128KiB PEB）的三星 OneNAND 芯片在耐用寿命期间保证不超过 40 个 128KiB PEB。这是 NAND 设备的常见值：20&#x2F;1024 PEB，约为闪存大小的 2%。</p><p>20&#x2F;1024 的比例是 UBI 为 UBI 设备预留的默认块数。这意味着如果 4096 PEB NAND 上有 2 个 UBI 设备，则每个 UBI 设备将预留 80 PEB。这似乎是一种空间浪费，但鉴于坏块可能出现在 NAND 闪存上的任何位置，并且在整个设备上分布不均，因此这是更安全的方式。因此，与其在 NAND 闪存上使用多个 UBI 设备，不如仅使用一个包含多个 UBI 卷的 UBI 设备更节省空间。</p><p>每 1024 PEB 保留的 20 PEB 的默认值是一个内核配置选项。对于每个 UBI 设备，可以通过内核参数或 ubiattach 参数（自内核 3.7 起）调整此值。</p><h2 id="1-14-Volume-auto-resize-卷自动调整大小"><a href="#1-14-Volume-auto-resize-卷自动调整大小" class="headerlink" title="1.14. Volume auto-resize 卷自动调整大小"></a>1.14. Volume auto-resize 卷自动调整大小</h2><p>在生产过程中要刷新 UBI 映像时，应为所有卷指定确切的大小（大小存储在 UBI 卷表中）。然而，在实践中，在嵌入式领域，我们希望有一个只读卷用于根文件系统，还有一个读&#x2F;写卷用于剩余的任何空间（日志、用户数据等）。如果根文件系统的大小是固定的，则第二个卷的大小可以因产品而异（给定不同的闪存大小）。</p><p>这是自动调整大小标志的用途。如果卷启用了自动调整大小标志，则在首次运行 UBI 时，其大小将扩展以填满剩余的未使用空间。调整卷大小后，UBI 会移除自动调整大小标志，并且不再调整卷的大小。自动调整大小标志存储在卷表中，并且只能将一个卷标记为自动调整大小。</p><h2 id="1-15-UBI-operations"><a href="#1-15-UBI-operations" class="headerlink" title="1.15. UBI operations"></a>1.15. UBI operations</h2><h3 id="1-15-1-LEB-un-map"><a href="#1-15-1-LEB-un-map" class="headerlink" title="1.15.1. LEB un-map"></a>1.15.1. LEB un-map</h3><p>LEB 取消映射操作由 <code>ubi_leb_unmap()</code> UBI 内核 API 函数实现。从内核版本 <code>2.6.29</code> 开始，取消映射操作可通过 <code>UBI_IOCEBUNMAP</code> ioctl 命令供用户空间程序使用。应针对 UBI 卷字符设备调用 ioctl。</p><p>LEB 取消映射操作：</p><ul><li>首先从相应的 PEB 取消映射 LEB；</li><li>然后计划擦除 PEB 并返回；它不会等待 PEB 的擦除完成；相反，PEB 由 UBI 后台线程擦除；</li></ul><p>当读取未映射的 LEB 时，UBI 返回所有 <code>0xFF</code> 字节，因此取消映射操作可以被视为非常快速的擦除操作。但 UBI 程序员必须注意一个方面：<br>假设您取消映射映射到 PEB P 的 LEB L。由于 P 不是同步擦除的，而只是后台擦除，因此在不干净的重新启动的情况下可能会出现“意外情况”：如果在物理擦除 P 之前重新启动，则在 UBI 在下次启动时连接 MTD 设备时，L 将再次映射到 P。事实上，UBI 将扫描 MTD 设备并找到引用 L 的 P，并将此映射信息添加到 EBA 表中。<br>但是，一旦您将任何数据写入 L，或使用 LEB 映射操作对其进行映射，它就会映射到新的 PEB，并且旧内容将永远消失，因为即使在不干净的重新启动的情况下，UBI 也会为 L 选择较新的映射。</p><h4 id="1-15-1-1-实现细节"><a href="#1-15-1-1-实现细节" class="headerlink" title="1.15.1.1. 实现细节"></a>1.15.1.1. 实现细节</h4><p>本节介绍了在 unclean 重启的情况下，UBI 如何区分 LEB 的旧版本和新版本。假设我们取消映射映射到 PEB P1 的 LEB L，这意味着 UBI 将 P1 安排为擦除。然后，我们向 L 写入一些数据，这意味着 UBI 找到另一个 PEB P2 ，将 L 映射到 P2 ，并将数据写入 P 2 。如果在 P1 物理擦除之前，但在写入操作之后发生 unclean 重启，我们最终会得到映射到同一个 LEB L 的 2 个 PEB（P1 和 P2 ）。</p><p>为了处理这种情况，UBI 维护了一个全局 64 位序列号变量。每次将 PEB 映射到 LEB 时都会递增序列号变量，并将它的值存储在 PEB 的 VID 头中。因此，每个 VID 头都有一个唯一的序列号，序列号越大，VID 头就越“年轻”。当 UBI 连接 MTD 设备时，它会将全局序列号变量初始化为现有 VID 头中找到的最高值加一。</p><p>在上述情况下，UBI 只需选择具有最高序列号的 PEB（P2）并丢弃具有较低序列号的 PEB（P1）。</p><p>请注意，如果在 UBI 将一个 PEB 的内容移动到另一个 PEB 以便进行磨损均衡时发生不干净的重新启动，或者在原子 LEB 更改操作期间发生不干净的重新启动，则情况会更加困难。在这种情况下，仅选择较新的 PEB 是不够的，还需要确保数据已到达新的 PEB。</p><h3 id="1-15-2-LEB-map"><a href="#1-15-2-LEB-map" class="headerlink" title="1.15.2. LEB map"></a>1.15.2. LEB map</h3><p>LEB 映射操作将以前未映射的逻辑擦除块 (LEB) 映射到物理擦除块 (PEB)。例如，如果对 LEB A 运行操作，UBI 将找到一个合适的 PEB，向 PEB 写入 VID 头，并修改内存中的 EBA 表。VID 头现在将引用 LEB A。此操作后，对 LEB A 的所有 I&#x2F;O 实际上都将转到映射的 PEB。</p><p>LEB 映射操作可通过 <code>ubi_leb_map()</code> UBI 内核 API 函数或通过 <code>UBI_IOCEBMAP</code> 卷字符设备 ioctl 命令使用。但是，此 ioctl 接口仅从内核版本 <code>2.6.29</code> 开始可用。</p><p>LEB 映射操作的功能之一是确保删除旧的 LEB 内容。如本节所述，当 LEB 取消映射时，相应的 PEB 不会立即擦除。如果发生不干净的重新启动，则在 UBI 连接 MTD 设备后，LEB 可能会再次映射到相同的 PEB。因此，如果在取消映射后立即映射 LEB，则可以确保删除旧的 LEB 内容。换句话说，即使在不干净的重新启动的情况下，映射操作返回后，LEB 也保证只包含 0xFF 字节。</p><p>请谨慎使用 LEB 映射操作。除非确实需要，否则请勿使用它，因为映射的 LEB 会给 UBI 磨损均衡子系统增加更多开销，与未映射的 LEB 相比。事实上，如果某个 LEB 未映射，则没有包含此 LEB 数据的 PEB，并且磨损均衡子系统不必移动任何数据来维持磨损均衡。相反，如果 LEB 映射到 PEB，则磨损均衡子系统需要关注的 PEB 会多一个，并且如果当前 PEB 的擦除计数器变得太低，则需要将一个 LEB 重新映射到另一个 PEB（然后将 LEB 重新映射到擦除计数器较高的 PEB，并将旧 PEB 用于其他操作）。</p><h3 id="1-15-3-Volume-update"><a href="#1-15-3-Volume-update" class="headerlink" title="1.15.3. Volume update"></a>1.15.3. Volume update</h3><p>卷更新操作对于设备软件更新非常有用。该操作使用新内容更改整个 UBI 卷的内容。但如果在更新过程中中断，卷将进入“已损坏”状态，并且卷上的进一步 I&#x2F;O 最终会产生 <code>EBADF</code> 错误。使卷恢复到正常状态的唯一方法是启动新的卷更新操作并完成它。</p><p>卷更新操作可以检测中断（不完整）的更新，并借助“镜像”卷（该卷具有相同的内容）或通过显示对话框（该对话框会通知用户问题并要求重新刷新）重新启动更新。相比之下，在使用原始 MTD 分区时很难检测到中断的更新。</p><p>卷更新操作可通过用户空间 UBI 接口使用，而无法通过 UBI 内核 API 使用。要更新卷，您首先必须对相应的 UBI 卷字符设备节点调用 <code>UBI_IOCVOLUP</code> ioctl，并向其传递一个指向 64 位值的指针，其中包含新卷内容的长度（以字节为单位）。然后，必须将此数量的字节写入卷字符设备节点。将最后一个字节发送到字符设备节点后，更新操作即完成。从概念上讲，该序列（以伪代码表示）为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">fd = open(<span class="hljs-string">&quot;/dev/my_volume&quot;</span>);<br>ioctl(fd, UBI_IOCVOLUP, &amp;image_size);<br>write(fd, buf, image_size);<br>close(fd);<br></code></pre></td></tr></table></figure><p>有关更多详细信息，请参见 <code>include/mtd/ubi-user.h</code> 。请记住，如果更新中断，卷的旧内容将不会被保留。此外，您不必一次写入所有新数据。可以任意多次调用 <code>write()</code> 函数，并每次传递任意数量的数据。在所有数据写入后，操作将完成。如果最后一次写入操作包含的字节数超过 UBI 预期，则会忽略多余的字节。</p><p>卷更新操作的一个特例是我们所说的卷截断，当数据长度为零时，通过相同的 ioctl 命令完成。在这种情况下，卷将被擦除，并将包含所有 <code>0xFF</code> 字节（所有 LEB 都将取消映射）。</p><p>请注意， <code>/sys/class/ubi/ubiX_X/corrupted</code> sysfs 文件反映了卷的“损坏”状态：如果卷正常，则包含 ASCII “0”，如果损坏（即如果卷更新已启动但未完成），则包含 “1”。</p><p>如果更新中断，卷更新操作不会保留其先前的内容；它不是原子的。但是，UBI 通过卷重命名操作提供原子卷更新。</p><p>卷更新借助更新标记实现。一旦用户发出 <code>UBI_IOCVOLUP</code> ioctl，UBI 会在 UBI 卷表的相应记录中设置卷的更新标记标志。此时，卷被擦除，UBI 等待用户发送数据。只有当所有数据已发送并已成功写入闪存后，更新标记才会被清除。如果更新中断（例如，不干净的重新启动、更新应用程序崩溃等），则不会清除更新标记，并且该卷被视为“已损坏”。只有在成功执行更新操作后，才会清除更新标记。</p><h3 id="1-15-4-Atomic-LEB-change-原子-LEB-更改"><a href="#1-15-4-Atomic-LEB-change-原子-LEB-更改" class="headerlink" title="1.15.4. Atomic LEB change - 原子 LEB 更改"></a>1.15.4. Atomic LEB change - 原子 LEB 更改</h3><p>原子 LEB 更改操作以原子方式更改 LEB 的内容，以便在操作中断时保留旧内容。换句话说，LEB 将始终包含旧内容或新内容。此功能可通过 <code>ubi_leb_change()</code> 内核 API 调用获得。</p><p>此操作的用户空间接口已添加到内核版本 <code>2.6.25</code> 中。其功能可通过 <code>UBI_IOCEBCH</code> ioctl 命令供用户空间使用。您必须传递一个指向正确填充的 <code>struct ubi_leb_change_req</code> 类型请求对象的指针。此对象存储要更改的 LEB 编号和新内容的长度。然后，您必须将指定数量的字节写入卷字符设备。请注意与卷更新操作的相似之处。从概念上讲，顺序（以伪代码表示）为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ubi_leb_change_req</span> <span class="hljs-title">req</span>;</span><br><br>req.lnum = lnum_to_change;<br>req.len = data_len;<br>fd = open(<span class="hljs-string">&quot;/dev/my_volume&quot;</span>);<br>ioctl(fd, UBI_IOCEBCH, &amp;req);<br>write(fd, data_buf, data_len);<br>close(fd);<br></code></pre></td></tr></table></figure><p>如果由于某种原因，用户在关闭文件之前没有将指定数量的字节写入文件描述符，则该操作将被取消，并且 LEB 的旧内容将被保留。</p><p>与卷更新操作类似，无论调用 <code>write()</code> 函数多少次以及每次向 UBI 卷传递多少数据都没有关系。原子 LEB 更改操作仅在最后一个数据字节到达后才完成。</p><p>原子 LEB 更改操作对于文件系统可能非常有用，例如 UBIFS 在提交文件系统索引时使用此功能。此行为还可用于在 UBI 之上创建 FTL 层（在此处查看该想法的说明）。</p><p>请记住，原子 LEB 更改操作会计算新数据的 <code>CRC-32</code> 校验和，因此与“LEB 擦除”+“LEB 写入”序列相比，它会产生一些开销。卷更新操作不会计算数据的 <code>CRC-32</code> 校验和，因此更新卷比原子更改其所有擦除块的速度更快。请记住此开销，并确保仅在确实需要原子性时才使用此操作。</p><h2 id="1-16-Fastmap"><a href="#1-16-Fastmap" class="headerlink" title="1.16. Fastmap"></a>1.16. Fastmap</h2><p>Fastmap 是一项实验性和可选的 UBI 功能。<br>用于加快大容量闪存的操作速度。</p><h2 id="1-17-UBI-卷之上-RO-block-devices"><a href="#1-17-UBI-卷之上-RO-block-devices" class="headerlink" title="1.17. UBI 卷之上 RO block devices"></a>1.17. UBI 卷之上 RO block devices</h2><p>UBI 允许在 UBI 卷之上创建块设备，但存在以下限制：</p><ul><li>Read-only </li><li>串行 I&#x2F;O 操作，但请记住 NAND 驱动程序内核也已对所有 I&#x2F;O 进行了串行化。</li></ul><p>尽管存在这些限制，但块设备对于在 UBI 卷之上挂载只读常规文件系统仍然非常有用。以 squashfs 为例，它可以用作 NAND 设备之上的轻量级只读 rootfs。在这种情况下，UBI 层将负责处理低级细节，例如位翻转处理和磨损均衡。</p><h4 id="1-17-1-1-Usage-用法"><a href="#1-17-1-1-Usage-用法" class="headerlink" title="1.17.1.1. Usage 用法"></a>1.17.1.1. Usage 用法</h4><p>在 UBI 卷上创建和销毁块设备有点类似于将 MTD 设备附加到 UBI。您可以使用 <code>block</code> UBI 模块参数或使用“ <code>ubiblock</code> ”用户空间工具。</p><p>为了在启动时创建块设备（例如，在该块设备上挂载 rootfs），您可以将 <code>block</code> 参数指定为内核启动参数：<br><code>ubi.mtd=5 ubi.block=0,0 root=/dev/ubiblock0_0</code></p><p>有几种方法可以指定卷：</p><ul><li>使用 UBI 卷路径：<br>  <code>ubi.block=/dev/ubi0_0</code></li><li>使用 UBI 设备和卷名称：<br>  <code>ubi.block=0,rootfs</code></li><li>同时使用 UBI 设备编号和 UBI 卷编号：<br>  <code>ubi.block=0,0</code></li></ul><p>如果您已将 UBI 构建为模块，则可以在模块加载时使用以下参数：<br>$ modprobe ubi mtd&#x3D;&#x2F;dev&#x2F;mtd5 block&#x3D;&#x2F;dev&#x2F;ubi0_0</p><p>还可以在运行时使用 <code>ubiblock</code> 用户空间工具动态创建&#x2F;删除块设备：<br>$ ubiblock –create &#x2F;dev&#x2F;ubi0_0<br>$ ubiblock –remove &#x2F;dev&#x2F;ubi0_0</p><h4 id="1-17-1-2-我这个板子的ubiblock"><a href="#1-17-1-2-我这个板子的ubiblock" class="headerlink" title="1.17.1.2. 我这个板子的ubiblock"></a>1.17.1.2. 我这个板子的ubiblock</h4><blockquote><p>我这个板子就是在ubiblock上存的squashfs</p></blockquote><p>boot里面有个参数rootfs_opts，里面记录了rootfs保存的关键信息</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># cat /proc/environment/rootfs_opts </span><br><span class="hljs-attribute">root</span>=/dev/ubiblock0_4 ubi.<span class="hljs-attribute">mtd</span>=image ubi.<span class="hljs-attribute">block</span>=0,4 <span class="hljs-attribute">rootfstype</span>=squashfs# <br></code></pre></td></tr></table></figure><p>这个参数在boot阶段会添加到linux的启动参数里面</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># cat /proc/cmdline </span><br><span class="hljs-attribute">console</span>=ttyAMA0 earlyprintk <span class="hljs-built_in">debug</span> <span class="hljs-attribute">irqaffinity</span>=0 <span class="hljs-attribute">pci</span>=pcie_bus_safe <span class="hljs-attribute">isolcpus</span>=3 rootwait <span class="hljs-attribute">mtdparts</span>=brcmnand.0:2097152(loader),131072000@2097152(image) <span class="hljs-attribute">root</span>=/dev/ubiblock0_4 ubi.<span class="hljs-attribute">mtd</span>=image ubi.<span class="hljs-attribute">block</span>=0,4 <span class="hljs-attribute">rootfstype</span>=squashfs <span class="hljs-attribute">cma</span>=0M<br></code></pre></td></tr></table></figure><p>mtd的情况为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># cat /proc/mtd </span><br><span class="hljs-attribute">dev</span>:    size   erasesize  name<br><span class="hljs-attribute">mtd0</span>: <span class="hljs-number">08000000</span> <span class="hljs-number">00020000</span> <span class="hljs-string">&quot;brcmnand.0&quot;</span><br><span class="hljs-attribute">mtd1</span>: <span class="hljs-number">00200000</span> <span class="hljs-number">00020000</span> <span class="hljs-string">&quot;loader&quot;</span><br><span class="hljs-attribute">mtd2</span>: <span class="hljs-number">07</span>d00000 <span class="hljs-number">00020000</span> <span class="hljs-string">&quot;image&quot;</span><br><span class="hljs-attribute">mtd3</span>: <span class="hljs-number">00000500</span> <span class="hljs-number">0001</span>f000 <span class="hljs-string">&quot;metadata1&quot;</span><br><span class="hljs-attribute">mtd4</span>: <span class="hljs-number">00000500</span> <span class="hljs-number">0001</span>f000 <span class="hljs-string">&quot;metadata2&quot;</span><br><span class="hljs-attribute">mtd5</span>: <span class="hljs-number">00992</span>c10 <span class="hljs-number">0001</span>f000 <span class="hljs-string">&quot;bootfs1&quot;</span><br><span class="hljs-attribute">mtd6</span>: <span class="hljs-number">01</span>f3e000 <span class="hljs-number">0001</span>f000 <span class="hljs-string">&quot;rootfs1&quot;</span><br><span class="hljs-attribute">mtd7</span>: <span class="hljs-number">00992</span>c10 <span class="hljs-number">0001</span>f000 <span class="hljs-string">&quot;bootfs2&quot;</span><br><span class="hljs-attribute">mtd8</span>: <span class="hljs-number">01</span>f3e000 <span class="hljs-number">0001</span>f000 <span class="hljs-string">&quot;rootfs2&quot;</span><br><span class="hljs-attribute">mtd9</span>: <span class="hljs-number">0041</span>e000 <span class="hljs-number">0001</span>f000 <span class="hljs-string">&quot;data&quot;</span><br><span class="hljs-attribute">mtd10</span>: <span class="hljs-number">0041</span>e000 <span class="hljs-number">0001</span>f000 <span class="hljs-string">&quot;defaults&quot;</span><br><span class="hljs-attribute">mtd11</span>: <span class="hljs-number">01819000</span> <span class="hljs-number">0001</span>f000 <span class="hljs-string">&quot;plugin&quot;</span><br></code></pre></td></tr></table></figure><p>第一个参数ubi.mtd&#x3D;image<br>(1) ubi_init将name为image的mtd，attcah到ubi设备。</p><p>第二个参数ubi.block&#x3D;0,4<br>(2) ubiblock_init把ubi0的第4个卷创建为ubiblock设备。</p><p>内核的调用先后大致为：<br>（1）start_kernel–&gt;rest_init–&gt;kernel_thread(kernel_init, NULL, CLONE_FS)<br>（2）kernel_init–&gt;kernel_init_freeable–&gt;kernel_init_freeable –&gt; do_basic_setup –&gt; do_initcalls（初始化ubi）<br>（3）ubi初始化完， prepare_namespace –&gt; mount_block_root</p><h1 id="2-参考"><a href="#2-参考" class="headerlink" title="2. 参考"></a>2. 参考</h1><p><a href="http://www.linux-mtd.infradead.org/doc/ubi.html">UBI - Unsorted Block Images</a><br><a href="https://blog.csdn.net/qq_24835087/article/details/125336305">【NAND文件系统】UBI介绍</a></p><h1 id="3-挂载ubifs"><a href="#3-挂载ubifs" class="headerlink" title="3. 挂载ubifs"></a>3. 挂载ubifs</h1><p>把ubi卷挂载到文件系统，很简单，只需要创建卷，然后挂载就行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ubimkvol /dev/ubi0 -N <span class="hljs-built_in">test</span> -s 2MiB<br>mount -vt ubifs ubi:<span class="hljs-built_in">test</span> /mnt/test<br></code></pre></td></tr></table></figure><p>根据我的测试，挂文件系统的分区最小需要2MiB的大小，不然挂载时报不合法的参数</p><h2 id="3-1-更改文件系统大小"><a href="#3-1-更改文件系统大小" class="headerlink" title="3.1 更改文件系统大小"></a>3.1 更改文件系统大小</h2><p>使用ubirsvol改过卷大小之后，然后重新挂载文件系统,df -h看到的可用空间不会变。需要清空一下数据</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">ubiupdatevol <span class="hljs-regexp">/dev/u</span>bi0_13 -t<br></code></pre></td></tr></table></figure><p>2MB的分区，可用大小只有344KB。48MB可用大小42.7MB。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>内存碎片研究</title>
    <link href="/2024/01/05/c8daabb7fcee/"/>
    <url>/2024/01/05/c8daabb7fcee/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在一个项目上，遇到进程随运行时间内存一直增长，增长有10M之多。而且不下降。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">VmPeak:</span>   <span class="hljs-number">203528</span> <span class="hljs-string">kB</span><br><span class="hljs-attr">VmSize:</span>   <span class="hljs-number">132824</span> <span class="hljs-string">kB</span><br><span class="hljs-attr">VmLck:</span>         <span class="hljs-number">0</span> <span class="hljs-string">kB</span><br><span class="hljs-attr">VmPin:</span>         <span class="hljs-number">0</span> <span class="hljs-string">kB</span><br><span class="hljs-attr">VmHWM:</span>     <span class="hljs-number">16104</span> <span class="hljs-string">kB</span><br><span class="hljs-attr">VmRSS:</span>     <span class="hljs-number">13536</span> <span class="hljs-string">kB</span><br><span class="hljs-attr">RssAnon:</span>            <span class="hljs-number">8628 </span><span class="hljs-string">kB</span><br><span class="hljs-attr">RssFile:</span>            <span class="hljs-number">4908 </span><span class="hljs-string">kB</span><br><span class="hljs-attr">RssShmem:</span>              <span class="hljs-number">0</span> <span class="hljs-string">kB</span><br><span class="hljs-attr">VmData:</span>   <span class="hljs-number">123700</span> <span class="hljs-string">kB</span><br><span class="hljs-attr">VmStk:</span>       <span class="hljs-number">132</span> <span class="hljs-string">kB</span><br><span class="hljs-attr">VmExe:</span>        <span class="hljs-number">52</span> <span class="hljs-string">kB</span><br><span class="hljs-attr">VmLib:</span>      <span class="hljs-number">6148 </span><span class="hljs-string">kB</span><br><span class="hljs-attr">VmPTE:</span>        <span class="hljs-number">60</span> <span class="hljs-string">kB</span><br><span class="hljs-attr">VmSwap:</span>        <span class="hljs-number">0</span> <span class="hljs-string">kB</span><br></code></pre></td></tr></table></figure><p>最开始以为有内存泄露，使用valgrind检查了下，并没有发现泄露。而且随着测试时间增长，内存增长会变慢，甚至不增长。<br>于是怀疑是内存碎片。</p><h1 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h1><p>以前也听说过内存碎片，但碎片占这么大内存空间（估摸至少浪费7，8M）还没遇到过。遂去网上查了一下资料。发现网上居然还有碎片1G以上的。</p><p>内存碎片离不开内存分配原理，这点比较复杂，简要总结下：<br>（1）glibc使用的内存分配器名字为ptmalloc</p><p>（2）分配内存有两个系统调用brk和mmap，小内存(默认低于128KB)使用brk，大内存使用mmap。</p><p>（3）brk是修改堆顶指针，所以只有当堆顶的内存释放后，堆占用大小才有可能收缩。<br>可通过<code>cat /proc/pid/smaps</code>查看到堆占用大小，可知当前堆大小为992KB</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0002e000</span>-<span class="hljs-number">00154000</span> rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>         <span class="hljs-meta"> [heap]</span><br><span class="hljs-attribute">Size</span>:               <span class="hljs-number">1176</span> kB<br><span class="hljs-attribute">KernelPageSize</span>:        <span class="hljs-number">4</span> kB<br><span class="hljs-attribute">MMUPageSize</span>:           <span class="hljs-number">4</span> kB<br><span class="hljs-attribute">Rss</span>:                 <span class="hljs-number">992</span> kB<br><span class="hljs-attribute">Pss</span>:                 <span class="hljs-number">992</span> kB<br></code></pre></td></tr></table></figure><p>（4）ptmalloc分配向系统申请的内存，程序free后不会立即释放，而是自己先管着，伺机还给系统。</p><p>（5）ptmalloc有一个主分配区，多个副分配区。多线程时，如果当前线程无法立即在主分配区持有锁，那么会找副分配区，如果也没有，那么会建立一个新的副分配区。<br>32位系统分配区个数限制为<code>2 * CPU核数</code>个，64位系统限制为<code> 8 * CPU核数</code>个。<br>副分配区通过mmap一次向os申请64MB（？）内存，一旦申请了，该分配区就不会释放。</p><p>检查了下代码(glibc-2.30)，开辟分配区时，64位系统才一次申请64MB。32位一次分配2M（函数new_heap）。但这个仍然和malloc_stats打印的对不上。</p><h1 id="查看malloc碎片情况"><a href="#查看malloc碎片情况" class="headerlink" title="查看malloc碎片情况"></a>查看malloc碎片情况</h1><p>（1）使用malloc_stats函数</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Arena</span> <span class="hljs-number">0</span>:<br><span class="hljs-attribute">system</span> bytes     =    <span class="hljs-number">2625536</span><br><span class="hljs-attribute">in</span> use bytes     =    <span class="hljs-number">1063008</span><br><span class="hljs-attribute">Arena</span> <span class="hljs-number">1</span>:<br><span class="hljs-attribute">system</span> bytes     =    <span class="hljs-number">2011136</span><br><span class="hljs-attribute">in</span> use bytes     =     <span class="hljs-number">314864</span><br><span class="hljs-attribute">Arena</span> <span class="hljs-number">2</span>:<br><span class="hljs-attribute">system</span> bytes     =    <span class="hljs-number">2318336</span><br><span class="hljs-attribute">in</span> use bytes     =     <span class="hljs-number">879032</span><br><span class="hljs-attribute">Arena</span> <span class="hljs-number">3</span>:<br><span class="hljs-attribute">system</span> bytes     =    <span class="hljs-number">2527232</span><br><span class="hljs-attribute">in</span> use bytes     =     <span class="hljs-number">475776</span><br><span class="hljs-attribute">Total</span> (incl. mmap):<br><span class="hljs-attribute">system</span> bytes     =    <span class="hljs-number">9482240</span><br><span class="hljs-attribute">in</span> use bytes     =    <span class="hljs-number">2732680</span><br><span class="hljs-attribute">max</span> mmap regions =         <span class="hljs-number">13</span><br><span class="hljs-attribute">max</span> mmap bytes   =    <span class="hljs-number">5701632</span><br></code></pre></td></tr></table></figure><p>system bytes表明向系统申请的，in use bytes表明使用中的。<br>从Total来看，还有6.7MB内存空闲着。</p><p>（2）使用mallinfo函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">display_mallinfo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mallinfo</span> <span class="hljs-title">mi</span>;</span><br>mi = mallinfo();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Total non-mmapped bytes (arena):       %d\n&quot;</span>, mi.arena);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;# of free chunks (ordblks):            %d\n&quot;</span>, mi.ordblks);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;# of free fastbin blocks (smblks):     %d\n&quot;</span>, mi.smblks);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;# of mapped regions (hblks):           %d\n&quot;</span>, mi.hblks);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Bytes in mapped regions (hblkhd):      %d\n&quot;</span>, mi.hblkhd);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Max. total allocated space (usmblks):  %d\n&quot;</span>, mi.usmblks);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Free bytes held in fastbins (fsmblks): %d\n&quot;</span>, mi.fsmblks);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Total allocated space (uordblks):      %d\n&quot;</span>, mi.uordblks);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Total free space (fordblks):           %d\n&quot;</span>, mi.fordblks);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Topmost releasable block (keepcost):   %d\n&quot;</span>, mi.keepcost);<br>&#125;<br></code></pre></td></tr></table></figure><p>打印如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Total non-mmapped bytes (arena):</span>       <span class="hljs-number">9482240</span><br><span class="hljs-comment"># of free chunks (ordblks):            1072</span><br><span class="hljs-comment"># of free fastbin blocks (smblks):     37</span><br><span class="hljs-comment"># of mapped regions (hblks):           0</span><br><span class="hljs-attr">Bytes in mapped regions (hblkhd):</span>      <span class="hljs-number">0</span><br><span class="hljs-attr">Max. total allocated space (usmblks):</span>  <span class="hljs-number">0</span><br><span class="hljs-attr">Free bytes held in fastbins (fsmblks):</span> <span class="hljs-number">1504</span><br><span class="hljs-attr">Total allocated space (uordblks):</span>      <span class="hljs-number">2732680</span><br><span class="hljs-attr">Total free space (fordblks):</span>           <span class="hljs-number">6749560</span><br><span class="hljs-attr">Topmost releasable block (keepcost):</span>   <span class="hljs-number">96936</span><br></code></pre></td></tr></table></figure><p>这个没有分区域，arena表明总消耗，uordblks表明总的正在使用，fordblks空闲的。</p><h1 id="可调参数"><a href="#可调参数" class="headerlink" title="可调参数"></a>可调参数</h1><p>（1）使用mallopt函数调整<br>调整方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">mallopt(M_ARENA_MAX, <span class="hljs-number">1</span>);<br>mallopt(M_MMAP_THRESHOLD, <span class="hljs-number">4</span>*<span class="hljs-number">1024</span>);<br>mallopt(M_TRIM_THRESHOLD, <span class="hljs-number">4</span>*<span class="hljs-number">1024</span>);<br></code></pre></td></tr></table></figure><p>所有参数见：<a href="https://man7.org/linux/man-pages/man3/mallopt.3.html">mallopt(3) — Linux manual page</a></p><p>（2）使用glibc环境变量调整<br>调整方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">GLIBC_TUNABLES=glibc.<span class="hljs-built_in">malloc</span>.trim_threshold=<span class="hljs-number">128</span>:glibc.<span class="hljs-built_in">malloc</span>.check=<span class="hljs-number">3</span><br>export GLIBC_TUNABLES<br></code></pre></td></tr></table></figure><p>所有参数见：<a href="https://www.gnu.org/software/libc/manual/html_node/Memory-Allocation-Tunables.html">38.2 Memory Allocation Tunables</a></p><h1 id="解决办法？"><a href="#解决办法？" class="headerlink" title="解决办法？"></a>解决办法？</h1><h2 id="替换glibc的malloc"><a href="#替换glibc的malloc" class="headerlink" title="替换glibc的malloc"></a>替换glibc的malloc</h2><p>使用tcmalloc, jemalloc这些<br>试过jemalloc，这个貌似不太适合嵌入式。初始内存占用更多了，可能需要调些参数。<br>tcmalloc没试，c++的代码，这个也是新的编译框架。</p><h2 id="调整malloc参数"><a href="#调整malloc参数" class="headerlink" title="调整malloc参数"></a>调整malloc参数</h2><p>（1）调整M_MMAP_THRESHOLD，让更多的分配走mmap，这不会产生碎片。但是性能可能降低。<br>（2）调整M_ARENA_MAX，减少分配区个数，减少碎片。但是性能可能会降低。<br>分配区个数减少为1后，性能几乎没变。检查内存占用，发现内存主要都在堆上了。以前堆上内存只有1M的样子。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">010da000</span>-<span class="hljs-number">01716000</span> rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>         <span class="hljs-meta"> [heap]</span><br><span class="hljs-attribute">Size</span>:               <span class="hljs-number">6384</span> kB<br><span class="hljs-attribute">KernelPageSize</span>:        <span class="hljs-number">4</span> kB<br><span class="hljs-attribute">MMUPageSize</span>:           <span class="hljs-number">4</span> kB<br><span class="hljs-attribute">Rss</span>:                <span class="hljs-number">6124</span> kB<br><span class="hljs-attribute">Pss</span>:                <span class="hljs-number">6124</span> kB<br></code></pre></td></tr></table></figure><p>经测试，问题进程将内存分配区域设置为1，MMAP阈值和修剪阈值设置为64KB。碎片会减少很多。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">mallopt(M_ARENA_MAX, <span class="hljs-number">1</span>);<br>mallopt(M_MMAP_THRESHOLD, <span class="hljs-number">64</span>*<span class="hljs-number">1024</span>);<br>mallopt(M_TRIM_THRESHOLD, <span class="hljs-number">64</span>*<span class="hljs-number">1024</span>);<br></code></pre></td></tr></table></figure><p><strong>调整前后对比：</strong><br>测试方法：进程起来后，下载110MB的文件20次。查看进程的RSS内存。</p><table><thead><tr><th>对比项</th><th>RSS</th><th>system bytes</th><th>in use bytes</th><th>碎片占用</th></tr></thead><tbody><tr><td>修改前</td><td>11704 KB</td><td>7925760</td><td>2487016</td><td>5483 KB</td></tr><tr><td>修改后</td><td>7068KB</td><td>1925120</td><td>1079808</td><td>845 KB</td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/dongzhiquan/p/5621906.html">linux环境内存分配原理–虚拟内存 mallocinfo</a><br><a href="https://man7.org/linux/man-pages/man3/mallinfo.3.html"># mallinfo(3) — Linux manual page</a><br><a href="https://www.jianshu.com/p/b0a6ac5bf55d">glibc内存管理——Linux内存管理小结二</a><br><a href="https://zhuanlan.zhihu.com/p/428216764">2万字|带你领略glibc内存管理精髓</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ss命令查看socket上包的占用内存</title>
    <link href="/2024/01/04/f4cdb5edc080/"/>
    <url>/2024/01/04/f4cdb5edc080/</url>
    
    <content type="html"><![CDATA[<h1 id="统计socket接收发送队列上的数据长度"><a href="#统计socket接收发送队列上的数据长度" class="headerlink" title="统计socket接收发送队列上的数据长度"></a>统计socket接收发送队列上的数据长度</h1><p>一般情况下使用只会显示接收发送队列的包数</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># ./ss -ntp</span><br><span class="hljs-attribute">State</span>      Recv-Q Send-Q  Local Address:Port    Peer Address:Port Process                             <br><span class="hljs-attribute">ESTAB</span>      <span class="hljs-number">0</span>      <span class="hljs-number">0</span>      <span class="hljs-number">192.168.66.252:54130</span> <span class="hljs-number">14.116.220.228:443</span>   users:((<span class="hljs-string">&quot;tycfs&quot;</span>,pid=<span class="hljs-number">10271</span>,fd=<span class="hljs-number">8</span>))   <br><span class="hljs-attribute">ESTAB</span>      <span class="hljs-number">0</span>      <span class="hljs-number">572</span>    <span class="hljs-number">192.168.66.252:35838</span>   <span class="hljs-number">113.249.86.3:443</span>   users:((<span class="hljs-string">&quot;tycfs&quot;</span>,pid=<span class="hljs-number">10271</span>,fd=<span class="hljs-number">15</span>))  <br><span class="hljs-attribute">ESTAB</span>      <span class="hljs-number">0</span>      <span class="hljs-number">572</span>    <span class="hljs-number">192.168.66.252:35832</span>   <span class="hljs-number">113.249.86.3:443</span>   users:((<span class="hljs-string">&quot;tycfs&quot;</span>,pid=<span class="hljs-number">10271</span>,fd=<span class="hljs-number">21</span>))  <br><span class="hljs-attribute">CLOSE</span>-WAIT <span class="hljs-number">25</span>     <span class="hljs-number">0</span>      <span class="hljs-number">192.168.66.252:55502</span>  <span class="hljs-number">14.18.110.142:443</span>   users:((<span class="hljs-string">&quot;tycfs&quot;</span>,pid=<span class="hljs-number">10282</span>,fd=<span class="hljs-number">14</span>))  <br><span class="hljs-attribute">ESTAB</span>      <span class="hljs-number">0</span>      <span class="hljs-number">0</span>      <span class="hljs-number">192.168.66.252:56252</span>  <span class="hljs-number">14.18.110.142:443</span>   users:((<span class="hljs-string">&quot;tycfs&quot;</span>,pid=<span class="hljs-number">10271</span>,fd=<span class="hljs-number">25</span>))  <br><span class="hljs-attribute">ESTAB</span>      <span class="hljs-number">0</span>      <span class="hljs-number">77</span>        <span class="hljs-number">192.168.6.1:445</span>      <span class="hljs-number">192.168.6.2:49213</span> users:((<span class="hljs-string">&quot;smbd&quot;</span>,pid=<span class="hljs-number">10839</span>,fd=<span class="hljs-number">47</span>))   <br><span class="hljs-attribute">ESTAB</span>      <span class="hljs-number">82690</span>  <span class="hljs-number">0</span>      <span class="hljs-number">192.168.66.252:35804</span>   <span class="hljs-number">113.249.86.3:443</span>   users:((<span class="hljs-string">&quot;tycfs&quot;</span>,pid=<span class="hljs-number">10271</span>,fd=<span class="hljs-number">24</span>))  <br><span class="hljs-attribute">CLOSE</span>-WAIT <span class="hljs-number">25</span>     <span class="hljs-number">0</span>      <span class="hljs-number">192.168.66.252:55542</span>  <span class="hljs-number">14.18.110.142:443</span>   users:((<span class="hljs-string">&quot;tycfs&quot;</span>,pid=<span class="hljs-number">10282</span>,fd=<span class="hljs-number">15</span>))  <br></code></pre></td></tr></table></figure><p>统计内存信息需要<code>-m</code>参数，但可能开了-m参数还是没有，这时需要打开内核宏</p><p>内核打开宏：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">CONFIG_INET_DIAG</span>=y<br><span class="hljs-attribute">CONFIG_INET_TCP_DIAG</span>=y<br>CONFIG_INET_UDP_DIAG<br></code></pre></td></tr></table></figure><p>这时输出如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># ./ss -ntpm</span><br><span class="hljs-attribute">State</span>      Recv-Q Send-Q  Local Address:Port    Peer Address:Port Process                                                                                           <br><span class="hljs-attribute">ESTAB</span>      <span class="hljs-number">0</span>      <span class="hljs-number">570</span>    <span class="hljs-number">192.168.66.252:35980</span>   <span class="hljs-number">113.249.86.3:443</span>   users:((<span class="hljs-string">&quot;tycfs&quot;</span>,pid=<span class="hljs-number">10271</span>,fd=<span class="hljs-number">14</span>))<br>         <span class="hljs-attribute">skmem</span>:(r0,rb1492008,t0,tb48640,f194176,w2432,o0,bl0,d0)      <br><span class="hljs-attribute">ESTAB</span>      <span class="hljs-number">0</span>      <span class="hljs-number">570</span>    <span class="hljs-number">192.168.66.252:35998</span>   <span class="hljs-number">113.249.86.3:443</span>   users:((<span class="hljs-string">&quot;tycfs&quot;</span>,pid=<span class="hljs-number">10271</span>,fd=<span class="hljs-number">16</span>))<br>         <span class="hljs-attribute">skmem</span>:(r0,rb1737680,t0,tb48640,f140928,w2432,o0,bl0,d0)      <br><span class="hljs-attribute">ESTAB</span>      <span class="hljs-number">0</span>      <span class="hljs-number">0</span>      <span class="hljs-number">192.168.66.252:54130</span> <span class="hljs-number">14.116.220.228:443</span>   users:((<span class="hljs-string">&quot;tycfs&quot;</span>,pid=<span class="hljs-number">10271</span>,fd=<span class="hljs-number">8</span>))<br>         <span class="hljs-attribute">skmem</span>:(r0,rb1946944,t0,tb48640,f0,w0,o0,bl0,d1)               <br><span class="hljs-attribute">ESTAB</span>      <span class="hljs-number">65652</span>  <span class="hljs-number">0</span>      <span class="hljs-number">192.168.66.252:35996</span>   <span class="hljs-number">113.249.86.3:443</span>   users:((<span class="hljs-string">&quot;tycfs&quot;</span>,pid=<span class="hljs-number">10271</span>,fd=<span class="hljs-number">13</span>))<br>         <span class="hljs-attribute">skmem</span>:(r111360,rb1408120,t0,tb48640,f32000,w0,o0,bl0,d0)     <br></code></pre></td></tr></table></figure><p>主要看r，t这两个就够了，r表示接收的包，t表示发送的包。</p><p>fwd_alloc（接收缓存），wmem_queued（发送缓存）。这两个字段没有实际意义，查了下资料，它只表明一个额度，一个水线。并不真正会占用内存。</p><h1 id="统计总共占用内存"><a href="#统计总共占用内存" class="headerlink" title="统计总共占用内存"></a>统计总共占用内存</h1><p><strong>接收缓冲占用总内存</strong>（单位KB）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./ss -napm | awk -F <span class="hljs-string">&#x27;[\(|,]&#x27;</span> <span class="hljs-string">&#x27;/skmem/ &#123;print $2&#125;&#x27;</span> | <span class="hljs-built_in">cut</span> -c 2- | awk <span class="hljs-string">&#x27;&#123;a+=$1&#125;END&#123;print a/1024&#125;&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>发送缓冲占用总内存</strong>（单位KB）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/ss -napm | awk -F <span class="hljs-string">&#x27;[\(|,]&#x27;</span> <span class="hljs-string">&#x27;/skmem/ &#123;print $4&#125;&#x27;</span> | <span class="hljs-built_in">cut</span> -c 2- | awk <span class="hljs-string">&#x27;&#123;a+=$1&#125;END&#123;print a/1024&#125;&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="其他内存信息含义"><a href="#其他内存信息含义" class="headerlink" title="其他内存信息含义"></a>其他内存信息含义</h1><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs vim">-<span class="hljs-keyword">m</span>, --memory<br>              Show socket memory usage. The output format <span class="hljs-keyword">is</span>:<br><br>              skmem:(r<span class="hljs-symbol">&lt;rmem_alloc&gt;</span>,rb<span class="hljs-symbol">&lt;rcv_buf&gt;</span>,t<span class="hljs-symbol">&lt;wmem_alloc&gt;</span>,tb<span class="hljs-symbol">&lt;snd_buf&gt;</span>,<br>                            <span class="hljs-keyword">f</span><span class="hljs-symbol">&lt;fwd_alloc&gt;</span>,<span class="hljs-keyword">w</span><span class="hljs-symbol">&lt;wmem_queued&gt;</span>,<span class="hljs-keyword">o</span><span class="hljs-symbol">&lt;opt_mem&gt;</span>,<br>                            <span class="hljs-keyword">bl</span><span class="hljs-symbol">&lt;back_log&gt;</span>,d<span class="hljs-symbol">&lt;sock_drop&gt;</span>)<br>             <span class="hljs-symbol">&lt;rmem_alloc&gt;</span><br>                     the memory allocated <span class="hljs-keyword">for</span> receiving packet<br><br>              <span class="hljs-symbol">&lt;rcv_buf&gt;</span><br>                     the total memory can <span class="hljs-keyword">be</span> allocated <span class="hljs-keyword">for</span> receiving packet<br><br>              <span class="hljs-symbol">&lt;wmem_alloc&gt;</span><br>                     the memory used <span class="hljs-keyword">for</span> sending packet (which <span class="hljs-built_in">has</span> been sent <span class="hljs-keyword">to</span> layer <span class="hljs-number">3</span>)<br><br>              <span class="hljs-symbol">&lt;snd_buf&gt;</span><br>                     the total memory can <span class="hljs-keyword">be</span> allocated <span class="hljs-keyword">for</span> sending packet<br><br>              <span class="hljs-symbol">&lt;fwd_alloc&gt;</span><br>                     the memory allocated by the socket <span class="hljs-keyword">as</span> cache, but not used <span class="hljs-keyword">for</span> receiving/sending packet yet. If need memory <span class="hljs-keyword">to</span> send/receive packet, the mem‐<br>                     ory in this cache will <span class="hljs-keyword">be</span> used before allocate additional memory.<br><br>              <span class="hljs-symbol">&lt;wmem_queued&gt;</span><br>                     The memory allocated <span class="hljs-keyword">for</span> sending packet (which <span class="hljs-built_in">has</span> not been sent <span class="hljs-keyword">to</span> layer <span class="hljs-number">3</span>)<br><br>              <span class="hljs-symbol">&lt;ropt_mem&gt;</span><br>                     The memory used <span class="hljs-keyword">for</span> storing socket option, <span class="hljs-keyword">e</span>.g., the key <span class="hljs-keyword">for</span> TCP MD5 signature<br><br>              <span class="hljs-symbol">&lt;back_log&gt;</span><br>                     The memory used <span class="hljs-keyword">for</span> the sk backlog queue. On <span class="hljs-keyword">a</span> process context, <span class="hljs-keyword">if</span> the process <span class="hljs-keyword">is</span> receiving packet, <span class="hljs-built_in">and</span> <span class="hljs-keyword">a</span> <span class="hljs-keyword">new</span> packet <span class="hljs-keyword">is</span> received,  it  will<br>                     <span class="hljs-keyword">be</span> <span class="hljs-keyword">put</span> into the sk backlog queue, <span class="hljs-keyword">so</span> it can <span class="hljs-keyword">be</span> received by the process immediately<br><br>              <span class="hljs-symbol">&lt;sock_drop&gt;</span><br>                     the <span class="hljs-keyword">number</span> of packets dropped before they are de-multiplexed into the socket            <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>flock使用体会</title>
    <link href="/2023/12/29/987d260b4c15/"/>
    <url>/2023/12/29/987d260b4c15/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>它的API很简单，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/file.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">flock</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> operation)</span>;<br></code></pre></td></tr></table></figure><p>operation可指定：</p><ul><li>LOCK_SH：设置共享（读）锁</li><li>LOCK_EX：设置独占（写）锁</li><li>LOCK_UN：解锁</li></ul><p>它是建议锁。需要所有使用该文件的人都遵循规矩先flock上锁再使用文件才有效。</p><p>它是一个系统调用，在内核<code>fs/locks.c</code>中实现。</p><h1 id="实现本质"><a href="#实现本质" class="headerlink" title="实现本质"></a>实现本质</h1><p>每个打开的文件都对应有fd—file结构—inode结构三种数据结构。fd和file结构是进程自己独有的，inode是文件系统层面，所有进程共享。<br>flock在inode上记录了加锁的file结构信息，组成一个链表。通过比较file结构，判断是否需要锁定。<br>所以它的特性很多和文件相关。关键函数如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">flock_lock_inode</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file_lock *request)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_lock</span> *<span class="hljs-title">new_fl</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_lock</span> *<span class="hljs-title">fl</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_lock_context</span> *<span class="hljs-title">ctx</span>;</span><br><span class="hljs-type">int</span> error = <span class="hljs-number">0</span>;<br><span class="hljs-type">bool</span> found = <span class="hljs-literal">false</span>;<br>LIST_HEAD(dispose);<br><br><span class="hljs-comment">// 获取inode上的lock信息</span><br>ctx = locks_get_lock_context(inode, request-&gt;fl_type);<br><span class="hljs-keyword">if</span> (!ctx) &#123;<br><span class="hljs-keyword">if</span> (request-&gt;fl_type != F_UNLCK)<br><span class="hljs-keyword">return</span> -ENOMEM;<br><span class="hljs-keyword">return</span> (request-&gt;fl_flags &amp; FL_EXISTS) ? -ENOENT : <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (!(request-&gt;fl_flags &amp; FL_ACCESS) &amp;&amp; (request-&gt;fl_type != F_UNLCK)) &#123;<br>new_fl = locks_alloc_lock();<br><span class="hljs-keyword">if</span> (!new_fl)<br><span class="hljs-keyword">return</span> -ENOMEM;<br>&#125;<br><br>percpu_down_read_preempt_disable(&amp;file_rwsem);<br>spin_lock(&amp;ctx-&gt;flc_lock);<br><span class="hljs-keyword">if</span> (request-&gt;fl_flags &amp; FL_ACCESS)<br><span class="hljs-keyword">goto</span> find_conflict;<br><br><span class="hljs-comment">// 遍历inode上的锁</span><br>list_for_each_entry(fl, &amp;ctx-&gt;flc_flock, fl_list) &#123;<br><span class="hljs-comment">// file指针比较</span><br><span class="hljs-keyword">if</span> (request-&gt;fl_file != fl-&gt;fl_file)<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-comment">// 锁类型(LOCK_EX,LOCK_SH)比较</span><br><span class="hljs-keyword">if</span> (request-&gt;fl_type == fl-&gt;fl_type)<br><span class="hljs-keyword">goto</span> out;<br>found = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// file结构上找到锁，但是类型不同，直接删除老的</span><br>locks_delete_lock_ctx(fl, &amp;dispose);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (request-&gt;fl_type == F_UNLCK) &#123;<br><span class="hljs-keyword">if</span> ((request-&gt;fl_flags &amp; FL_EXISTS) &amp;&amp; !found)<br>error = -ENOENT;<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br><br><span class="hljs-comment">//file结构上没找到锁也会走这儿</span><br>find_conflict:<br>list_for_each_entry(fl, &amp;ctx-&gt;flc_flock, fl_list) &#123;<br><span class="hljs-keyword">if</span> (!flock_locks_conflict(request, fl))<br><span class="hljs-keyword">continue</span>;<br>error = -EAGAIN;<br><span class="hljs-keyword">if</span> (!(request-&gt;fl_flags &amp; FL_SLEEP))<br><span class="hljs-keyword">goto</span> out;<br><span class="hljs-comment">// 返回这个就会上锁</span><br>error = FILE_LOCK_DEFERRED;<br>locks_insert_block(fl, request);<br><span class="hljs-keyword">goto</span> out;<br>&#125;<br><span class="hljs-keyword">if</span> (request-&gt;fl_flags &amp; FL_ACCESS)<br><span class="hljs-keyword">goto</span> out;<br>locks_copy_lock(new_fl, request);<br>locks_insert_lock_ctx(new_fl, &amp;ctx-&gt;flc_flock);<br>new_fl = <span class="hljs-literal">NULL</span>;<br>error = <span class="hljs-number">0</span>;<br><br>out:<br>spin_unlock(&amp;ctx-&gt;flc_lock);<br>percpu_up_read_preempt_enable(&amp;file_rwsem);<br><span class="hljs-keyword">if</span> (new_fl)<br>locks_free_lock(new_fl);<br>locks_dispose_list(&amp;dispose);<br>trace_flock_lock_inode(inode, request, error);<br><span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><blockquote><p>从上面的原理可知：</p></blockquote><ul><li>fork,dup文件描述符后，fd对应的file结构不变，锁定关系不变。</li><li>单个进程可使用一个fd多次重复加锁（内核实际只加锁一次），所以只需要解锁一次。</li><li>单个进程对同一文件open两个fd（file结构不同），在这两个fd上依次加锁会死锁</li><li>关闭文件fd，在该fd上加的锁自动释放</li></ul><h1 id="flock命令"><a href="#flock命令" class="headerlink" title="flock命令"></a>flock命令</h1><p>有时一个命令或者脚本需要执行很久，有可能多个同时运行，我们需要串行的执行他们，避免出现问题。可以这样</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">flock <span class="hljs-string">/tmp/xxxx.lock</span> your_<span class="hljs-keyword">command</span><br></code></pre></td></tr></table></figure><p>比如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">flock /tmp/hexo_post<span class="hljs-selector-class">.lock</span> hexo <span class="hljs-selector-tag">g</span> -d<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C语言实现默认参数</title>
    <link href="/2023/12/14/b3979ae8f5b4/"/>
    <url>/2023/12/14/b3979ae8f5b4/</url>
    
    <content type="html"><![CDATA[<p>关键字：可变参数，可变长参数</p><p>疑惑open函数为什么可以两个参数，也可以三个参数。如下是man open看到的声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode)</span>;<br></code></pre></td></tr></table></figure><p>c语言本身不支持重载，它是怎么做到的呢？</p><p>下面来一个简单的实现。<br>利用逗号表达式和宏来实现，c为默认参数，默认0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> aa(a,b,c...) _aa(a,b,(0,##c))</span><br><br><span class="hljs-type">void</span> _aa(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d,%d\n&quot;</span>, a,b,c);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>aa(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>aa(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span><br><span class="hljs-attribute">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>malloc何时返回失败</title>
    <link href="/2023/12/12/9f5df2999f1d/"/>
    <url>/2023/12/12/9f5df2999f1d/</url>
    
    <content type="html"><![CDATA[<p>关键字：内存分配机制</p><p>在 [[linux是怎样工作的-内存管理]]中怀疑过malloc返回值的意义，感觉它从来不会失败。下面来分析一下应用层的内存分配机制。</p><h1 id="应用层机制"><a href="#应用层机制" class="headerlink" title="应用层机制"></a>应用层机制</h1><p>从系统层面看，进程分配内存有两种方式，brk和mmap（暂不考虑共享内存）。<br><strong>1、brk是将数据段(.data)的最高地址指针_edata往高地址推；</strong><br><strong>2、mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存</strong>。<br><strong>这两种方式分配的都是虚拟内存，没有分配物理内存</strong>。<strong>在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。</strong></p><p>一般程序分配内存使用的标准c库提供的malloc&#x2F;free。c库本身使用上面的两种方式向内核申请一块内存，然后自己管理。<br><strong>默认情况下，当malloc分配的内存小于128KB, 使用brk，分配的内存大于128KB时使用mmap</strong></p><h2 id="情况1-使用brk"><a href="#情况1-使用brk" class="headerlink" title="情况1 - 使用brk"></a>情况1 - 使用brk</h2><p>因为小内存分配才调用brk， brk只是推数据段的指针，而数据段的虚拟地址限制是很长的（多长以后再来填坑）。所以brk调用不会失败，即malloc不会失败。</p><p>系统调用的实现函数：<code>SYSCALL_DEFINE1(brk, unsigned long, brk)</code></p><h2 id="情况2-使用mmap"><a href="#情况2-使用mmap" class="headerlink" title="情况2 - 使用mmap"></a>情况2 - 使用mmap</h2><p>mmap的内核实现很复杂，梳理出检查内存的大致路线为：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">do_mmap</span> --&gt;</span> <span class="hljs-function"><span class="hljs-title">mmap_region</span> --&gt;</span> <span class="hljs-function"><span class="hljs-title">security_vm_enough_memory_mm</span> --&gt;</span> __vm_enough_memory<br></code></pre></td></tr></table></figure><p><code>__vm_enough_memory</code>只是检查”剩余可用内存”，而mmap次数限制，地址空间限制在前面的流程就检查了。</p><p>那么函数<code>__vm_enough_memory</code>何时返回ENOMEM呢？</p><h1 id="内核机制"><a href="#内核机制" class="headerlink" title="内核机制"></a>内核机制</h1><p>应用层分配的虚拟内存大于系统的物理内存这种情况叫overcommit。<br>overcommit有三种策略，可通过<code>/proc/sys/vm/overcommit_memory</code>调整，默认值为0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERCOMMIT_GUESS0   <span class="hljs-comment">//估测可用内存，限制overcommit</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERCOMMIT_ALWAYS1   <span class="hljs-comment">//不限制，随意overcommit</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERCOMMIT_NEVER2   <span class="hljs-comment">//不允许overcommit</span></span><br></code></pre></td></tr></table></figure><p>当配置为策略为<code>OVERCOMMIT_NEVER</code>时，如下两个参数起作用：</p><ul><li>overcommit_kbytes：当不允许overcommit时，设置vm允许申请值的上限</li><li>overcommit_ratio：当不允许overcommit时，设置vm允许申请的百分比，默认50%</li></ul><p>查看内存分配够不够的关键函数为<code>__vm_enough_memory</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERCOMMIT_GUESS0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERCOMMIT_ALWAYS1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERCOMMIT_NEVER2</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Check that a process has enough memory to allocate a new virtual</span><br><span class="hljs-comment"> * mapping. 0 means there is enough memory for the allocation to</span><br><span class="hljs-comment"> * succeed and -ENOMEM implies there is not.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * cap_sys_admin is 1 if the process has admin privileges, 0 otherwise.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> __vm_enough_memory(<span class="hljs-keyword">struct</span> mm_struct *mm, <span class="hljs-type">long</span> pages, <span class="hljs-type">int</span> cap_sys_admin)<br>&#123;<br><span class="hljs-type">long</span> <span class="hljs-built_in">free</span>, allowed, reserve;<br>    <span class="hljs-comment">//增加vm_committed_as计数，这个全局变量统计系统当前vm申请量</span><br>    <span class="hljs-comment">//这个值也就是/proc/meminfo里Committed_AS的值</span><br>    <span class="hljs-comment">//因为最开始就增加了，因此本次申请数量也包含了</span><br>vm_acct_memory(pages);<br><br><span class="hljs-comment">//完全不限制虚拟内存的分配，随意overcommit，因此总是能成功</span><br><span class="hljs-keyword">if</span> (sysctl_overcommit_memory == OVERCOMMIT_ALWAYS)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//根据一定规则限制vm的overcommit，这也是系统默认行为</span><br>    <span class="hljs-comment">//这时就要计算下当前系统free的内存了</span><br><span class="hljs-keyword">if</span> (sysctl_overcommit_memory == OVERCOMMIT_GUESS) &#123;<br>        <span class="hljs-comment">//1、NR_FREE_PAGES是系统完全free的内存，也就是free命令查到的free项</span><br><span class="hljs-built_in">free</span> = global_page_state(NR_FREE_PAGES);<br>        <span class="hljs-comment">//2、NR_FILE_PAGES是page cache使用的页面，这些页面是可以释放的，</span><br>        <span class="hljs-comment">//因此也要计入free中，但是要扣除共享内存</span><br><span class="hljs-built_in">free</span> += global_page_state(NR_FILE_PAGES);<br><br><span class="hljs-comment">//3、NR_SHMEM是共享内存，这些不能计入free中</span><br><span class="hljs-built_in">free</span> -= global_page_state(NR_SHMEM);<br>        <span class="hljs-comment">//4、获取swap的free页数</span><br><span class="hljs-built_in">free</span> += get_nr_swap_pages();  <br><br><span class="hljs-comment">//5、slab里可回收的肯定是要记入free中啦</span><br><span class="hljs-built_in">free</span> += global_page_state(NR_SLAB_RECLAIMABLE);<br><br><span class="hljs-comment">//6、考虑系统运行的基本需求，也要占用一部分内存，因此free肯定不能小于该值</span><br><span class="hljs-comment">// totalreserve_pages大致等于high water</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">free</span> &lt;= totalreserve_pages)<br><span class="hljs-keyword">goto</span> error;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">free</span> -= totalreserve_pages;<br><br><span class="hljs-comment">//7、根据admin_reserve_kbytes的设置</span><br>        <span class="hljs-comment">//留一部分内存给root用户保证紧急情况下能登录系统，并恢复系统</span><br>        <span class="hljs-comment">//比如需要启动sshd/login, bash, and top/kill</span><br><span class="hljs-keyword">if</span> (!cap_sys_admin)<br><span class="hljs-built_in">free</span> -= sysctl_admin_reserve_kbytes &gt;&gt; (PAGE_SHIFT - <span class="hljs-number">10</span>);<br>        <span class="hljs-comment">//到最后了，free大于要分配的内存，这就是真能分配了</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">free</span> &gt; pages)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">goto</span> error;<br>&#125;<br>    <span class="hljs-comment">//这里就是完全不允许overcommit的情况了</span><br>    <span class="hljs-comment">//allowed用于统计系统vm上限，这个是就是/proc/meminfo里CommitLimit的值</span><br>    <span class="hljs-comment">//计算公式:CommitLimit = (Physical RAM * vm.overcommit_ratio / 100) + Swap</span><br>allowed = vm_commit_limit();<br><span class="hljs-comment">//同上，留一部分内存给root用户</span><br><span class="hljs-keyword">if</span> (!cap_sys_admin)<br>allowed -= sysctl_admin_reserve_kbytes &gt;&gt; (PAGE_SHIFT - <span class="hljs-number">10</span>);<br><br>    <span class="hljs-comment">//保证单进程不要使用完所有vm空间，至少保证自己能恢复</span><br>    <span class="hljs-comment">//和admin_reserve_kbytes类似，也要给自己留点退路，不然只能让root用户来恢复系统了</span><br><span class="hljs-keyword">if</span> (mm) &#123;<br>        <span class="hljs-comment">//给普通用户保留的空间为min(当前进程vm的32分之一，将近3%，user_reserve_kbytes)</span><br>reserve = sysctl_user_reserve_kbytes &gt;&gt; (PAGE_SHIFT - <span class="hljs-number">10</span>);<br>allowed -= <span class="hljs-type">min_t</span>(<span class="hljs-type">long</span>, mm-&gt;total_vm / <span class="hljs-number">32</span>, reserve);<br>&#125;<br>    <span class="hljs-comment">//vm_committed_as保存当前系统中已申请(包含本次)的vm数量</span><br>    <span class="hljs-comment">//如果已分配数量小于系统允许分配上限，那就是此次内存申请ok</span><br><span class="hljs-keyword">if</span> (percpu_counter_read_positive(&amp;vm_committed_as) &lt; allowed)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>error:<br>vm_unacct_memory(pages);<br>    <span class="hljs-comment">//内存不足</span><br><span class="hljs-keyword">return</span> -ENOMEM;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Committed memory limit enforced when OVERCOMMIT_NEVER policy is used</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">vm_commit_limit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> allowed;<br>    <span class="hljs-comment">//如果设置了overcommit_kbytes参数，那么commit就不能超过该值</span><br><span class="hljs-keyword">if</span> (sysctl_overcommit_kbytes)<br>allowed = sysctl_overcommit_kbytes &gt;&gt; (PAGE_SHIFT - <span class="hljs-number">10</span>);<br><span class="hljs-keyword">else</span><br>        <span class="hljs-comment">//如果没设置overcommit_kbytes参数，将读取overcommit_ratio参数的值</span><br>        <span class="hljs-comment">//既然是百分比，那么就需要有基数(总内存页面减去大页使用的内存)</span><br>allowed = ((totalram_pages - hugetlb_total_pages())<br>   * sysctl_overcommit_ratio / <span class="hljs-number">100</span>);<br>    <span class="hljs-comment">//同样别忘了还有swap页面数量</span><br>allowed += total_swap_pages;<br><br><span class="hljs-keyword">return</span> allowed;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="malloc失败发生过吗"><a href="#malloc失败发生过吗" class="headerlink" title="malloc失败发生过吗"></a>malloc失败发生过吗</h1><p>在嵌入式编程里面，很少遇到malloc失败的情况。因为内存不足时，还有缓存回收机制。<br>当程序的代码段都需要释放掉，用时才从flash上读出来时，系统此时已经很卡了。</p><p><strong>所以大多数情况下检查malloc返回值都没有意义。</strong><br>真正的大内存（至少大于128KB）分配检查才是有意义的：比如升级时。</p><p>但上面的描述仅限于linux，可能随着内核得更新实现也有区别。所以编写可移植，长久可靠的还是检查一下比较好。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/u010039418/article/details/104663831">vm内核参数之虚拟内存申请overcommit</a><br><a href="https://www.cnblogs.com/zhaoyl/p/3820852.html">malloc原理和内存碎片</a><br><a href="">知其然知其所以然，&#x2F;PROC&#x2F;MEMINFO之谜</a><br>[[meminfo详解]]</p>]]></content>
    
    
    
    <tags>
      
      <tag>技术/内存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gcc选项跟踪函数调用</title>
    <link href="/2023/08/28/b38c13ae5dd0/"/>
    <url>/2023/08/28/b38c13ae5dd0/</url>
    
    <content type="html"><![CDATA[<p>关键字：trace</p><blockquote><p>有时需要追踪函数究竟挂在了哪儿，gdb是一个不错的调试工具，但遇到栈被破坏的情况，并不能打印出调用栈，这时下面的方法就排上用处了。</p></blockquote><p><strong>增加gcc编译选项 -finstrument-functions</strong><br>gcc会自动在函数的入口和出口增加一个函数调用，函数原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __cyg_profile_func_exit(<span class="hljs-type">void</span>* callee, <span class="hljs-type">void</span>* callsite) __attribute__((no_instrument_function));<br><span class="hljs-type">void</span> __cyg_profile_func_enter(<span class="hljs-type">void</span>* callee, <span class="hljs-type">void</span>* callsite) __attribute__((no_instrument_function));<br></code></pre></td></tr></table></figure><p>以下为自定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;execinfo.h&gt;</span></span><br><br><span class="hljs-type">void</span> __cyg_profile_func_exit(<span class="hljs-type">void</span>* callee, <span class="hljs-type">void</span>* callsite) __attribute__((no_instrument_function));<br><span class="hljs-type">void</span> __cyg_profile_func_enter(<span class="hljs-type">void</span>* callee, <span class="hljs-type">void</span>* callsite) __attribute__((no_instrument_function));<br><br><span class="hljs-type">void</span> __cyg_profile_func_enter(<span class="hljs-type">void</span>* callee, <span class="hljs-type">void</span>* callsite) &#123;<br>    <span class="hljs-type">void</span>    *funptr = callee;<br>    <span class="hljs-type">char</span> **p = backtrace_symbols(&amp;funptr, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[;31m Entering: %s \033[0m\n&quot;</span>, *p);<br>    <span class="hljs-built_in">free</span>(p);<br>&#125;<br><br><span class="hljs-type">void</span> __cyg_profile_func_exit(<span class="hljs-type">void</span>* callee, <span class="hljs-type">void</span>* callsite) &#123;<br>    <span class="hljs-type">void</span>    *funptr = callee;<br>    <span class="hljs-type">char</span> **p = backtrace_symbols(&amp;funptr, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\033[;31m Exiting: %s \033[0m\n&quot;</span>, *p);<br>    <span class="hljs-built_in">free</span>(p);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行时就会打印出来函数调用来了，如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Entering: ./<span class="hljs-built_in">blink</span>() <span class="hljs-selector-attr">[0x1bb2c]</span> <br>Entering: ./<span class="hljs-built_in">blink</span>() <span class="hljs-selector-attr">[0x2028c]</span> <br>Entering: ./<span class="hljs-built_in">blink</span>() <span class="hljs-selector-attr">[0x1ffe4]</span> <br>Entering: ./<span class="hljs-built_in">blink</span>() <span class="hljs-selector-attr">[0x1f400]</span> <br>Exiting: ./<span class="hljs-built_in">blink</span>() <span class="hljs-selector-attr">[0x1f400]</span> <br></code></pre></td></tr></table></figure><p>再用addr2line(进程加了-g编译)来解析地址：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit">/opt/toolchains/crosstools-arm-gcc<span class="hljs-string">-9</span>.2-linux<span class="hljs-string">-4</span>.19-glibc<span class="hljs-string">-2</span>.30-binutils<span class="hljs-string">-2</span>.32/usr/bin/arm-buildroot-linux-gnueabi-addr2line -e tmp/blink -f 0x1f400<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">hgdpi_is_debug<br><span class="hljs-regexp">/home/</span>leon<span class="hljs-regexp">/code/</span>bcm-ax3000-cmcc<span class="hljs-regexp">/userspace/</span><span class="hljs-keyword">private</span><span class="hljs-regexp">/apps/</span>blink-sdk-publish<span class="hljs-regexp">/adapt/</span>public_adapt/blink_msg.cpp:<span class="hljs-number">57</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu xfce桌面升级后锁屏无法输入登录问题</title>
    <link href="/2023/03/30/cab790f4b84f/"/>
    <url>/2023/03/30/cab790f4b84f/</url>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>系统更新后，发现xfce桌面超时锁屏后，密码处无法输入字符。无法登录。只能重启。重启后桌面超时锁屏后又无法登录。</p><p>网上看到一篇文章 <a href="https://bugzilla.redhat.com/show_bug.cgi?id=1955993">https://bugzilla.redhat.com/show_bug.cgi?id=1955993</a> ，说是有两个锁屏在运行，导致出现问题。<br>xfce4-screensaver<br>xscreensaver</p><p>可以ps查看一下这两个进程是否存在，如果存在那么可能就是同一个问题。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>卸载掉xscreensaver，然后重启一下lightdm</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt <span class="hljs-built_in">remove</span> xscreensaver<br>sudo<span class="hljs-built_in"> service </span>lightdm restart <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>生成树协议STP算法</title>
    <link href="/2022/09/09/04d8542f8bb4/"/>
    <url>/2022/09/09/04d8542f8bb4/</url>
    
    <content type="html"><![CDATA[<h1 id="生成树协议STP算法"><a href="#生成树协议STP算法" class="headerlink" title="生成树协议STP算法"></a>生成树协议STP算法</h1><blockquote><p>以太网网桥使用生成树协议STP(Spanning Tree Protocol)，可以在提高网络可靠性的同时，又避免环路带来的各种问题。</p></blockquote><p>生成树算法STA(Spanning Tree Algorithm)是生成树协议的核心。它的目的是：在包含有物理环路的网络中，构建出一个能够连通全网各个节点的树形无环路逻辑拓扑。</p><p><strong>生成树算法三步骤</strong><br>（1）选举根网桥<br>（2）选举根端口<br>（3）选举指定端口并阻塞备用端口</p><h2 id="选举根网桥"><a href="#选举根网桥" class="headerlink" title="选举根网桥"></a>选举根网桥</h2><p>选举规则为：<strong>网桥ID（BID）最小者为根网桥。</strong></p><p>网桥ID由两部分组成：优先级，网桥的mac地址。<br>优先级范围为：0-61440，默认为32768，步长4096(优先级用一个字节高4bit表示，1表示的优先级为4096)。</p><p>网桥ID的比较方法为：<br>（1）优先级小的，则网桥ID越小。<br>（2）优先级相同，则比较MAC地址。MAC地址从左至右比较，数值小的，则网桥ID越小。</p><h2 id="选举根端口RP（Root-Port）"><a href="#选举根端口RP（Root-Port）" class="headerlink" title="选举根端口RP（Root Port）"></a>选举根端口RP（Root Port）</h2><p>每个非根网桥上都有一个根端口RP ，并且只有一个。<br>根端口RP用于接收根交换机发来的BPDU，也用于转发普通流量。</p><h3 id="根端口的选举条件为"><a href="#根端口的选举条件为" class="headerlink" title="根端口的选举条件为"></a>根端口的选举条件为</h3><p>（1）BPDU接收端口到根交换机的路径成本最小。<br>　　链路带宽　　成本值<br>　　 10Mbs&#x2F;s 　　100<br>　　 100Mb&#x2F;s 　　19<br>　　 1Gb&#x2F;s　　　　4<br>　　 10Gb&#x2F;s 　　　2<br>（2）对端的网桥ID最小。<br>（3）对端的端口ID（PID）最小。<br>　　端口ID由优先级和端口序号组成。<br>　　优先级范围为0-240，默认128，步长16。</p><h2 id="选举指定端口DP（Designated-Port）"><a href="#选举指定端口DP（Designated-Port）" class="headerlink" title="选举指定端口DP（Designated Port）"></a>选举指定端口DP（Designated Port）</h2><p>在每个网段选出指定端口，并且只有一个。<br>（前面说的网段，又有称LAN的，可以理解为：连接两个网桥的每条物理链路，每条物理链路上都有且一个指定端口）</p><p>指定端口用于转发根交换机发出来的BPDU，也用于转发普通流量。</p><h3 id="指定端口的选举条件"><a href="#指定端口的选举条件" class="headerlink" title="指定端口的选举条件"></a>指定端口的选举条件</h3><p>（1）根网桥的所有端口都是指定端口。<br>（2）根端口对端的端口一定是指定端口。<br>（3）BPDU转发端口到根交换机的路径成本最小的端口。<br>（4）本端的网桥ID最小者。</p><p>指定端口选举完成后，剩余端口便是备用端口AP(Alternate Port)，将他们阻塞。</p><h2 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h2><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/2022-09/09-152649-a99a-leon.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>popen后台执行进程问题</title>
    <link href="/2022/09/07/9c818c7ca46e/"/>
    <url>/2022/09/07/9c818c7ca46e/</url>
    
    <content type="html"><![CDATA[<h1 id="popen里面使用-amp-后台进程问题"><a href="#popen里面使用-amp-后台进程问题" class="headerlink" title="popen里面使用&amp;后台进程问题"></a>popen里面使用&amp;后台进程问题</h1><blockquote><p>这个例子可以加深对linux下fork,文件等的理解</p></blockquote><p>直接进入主题，如下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br><span class="hljs-type">char</span> line[<span class="hljs-number">128</span>];<br>FILE *fp = popen(<span class="hljs-string">&quot;ping 127.0.0.1 &amp;&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br><span class="hljs-keyword">if</span>(!fp)&#123;<br>perror(<span class="hljs-string">&quot;popen&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br># 参数个数控制是否获取输出<br><span class="hljs-keyword">if</span>(argc == <span class="hljs-number">2</span>)&#123;<br><span class="hljs-keyword">while</span>(fgets(line, <span class="hljs-keyword">sizeof</span>(line), fp))&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;== %s\n&quot;</span>, line);<br>&#125;<br>&#125;<br>pclose(fp);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>分别以<code>./a.out</code>和<code>./a.out get</code>运行结果是怎样? </p><ul><li>ping能在后台运行吗？</li><li>a.out会立即退出吗？</li><li>a.out能捕获到ping输出吗？</li></ul><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><p>（1）以 .&#x2F;a.out 运行，<strong>ping不能再后台运行</strong>，a.out也会立即退出。<br>（2）以 .&#x2F;a.out get运行，ping能在后台运行，a.out可以捕获到ping输出，a.out不会立即退出。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>通过strace跟踪系统调用，分析如下：<br><strong>popen原理</strong><br>（1） 创建管道<br>（2）fork<br>（3）（子进程）将管道描述符dup到标准输入输出上<br>（4）（子进程）exec程序<br>（5）（父进程）（这是pclose调用）wait子进程</p><p><strong>命令行程序后加&amp;</strong><br>fork两次，然后子进程退出，孙子进程运行命令行程序。<br><strong>注意：fork的过程中，并没有去操作描述符</strong></p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><blockquote><p>先分析这个过程：以 .&#x2F;a.out 运行，<strong>ping不能再后台运行</strong>，a.out也会立即退出。</p></blockquote><p>（1）由于是后台运行ping，所以pclose会很快收到子进程退出，然后返回，a.out便退出了。注意：这是popen创建的管道读端便关闭了。<br>（2）ping程序运行时，标准输出为a.out的管道写端描述符。当ping程序输出时，会失败，因为a.out已经退出，管道的读已经关闭，会收到SIGPIPE信号，默认动作就是退出。所以ping并不能在后台一直运行。</p><blockquote><p>再分析这个过程：以 .&#x2F;a.out get运行，ping能在后台运行，a.out可以捕获到ping输出，a.out不会立即退出。</p></blockquote><p>和前面类似，子进程虽然已经退出，但孙子进程ping也随着fork复制了这个管道，子进程关闭管道读只是把引用计数-1，并不会真正关闭读管道，所以a.out进程可以一直读。a.out不退出，ping自然可以向管道输出，持续执行，不会遇到SIGPIPE信号。</p>]]></content>
    
    
    
    <tags>
      
      <tag>编程/c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cut命令使用</title>
    <link href="/2022/09/04/5f598beeb2a8/"/>
    <url>/2022/09/04/5f598beeb2a8/</url>
    
    <content type="html"><![CDATA[<h1 id="cut命令使用"><a href="#cut命令使用" class="headerlink" title="cut命令使用"></a>cut命令使用</h1><blockquote><p>cut的作用主要是对每一行进行剪切，然后输出。可以按三种方式剪切：-b 以字节的形式，-c 以字符的形式，-f 通过分隔符按域。<br>分隔符按域的功能比较弱，可用awk替代。</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1，3-7字符</span><br>leon@home-ubuntu22:~$ echo 12345678 | cut -c 1,3-7<br>134567<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">第4个字符到结束</span><br>leon@home-ubuntu22:~$ echo 12345678 | cut -c 4-<br>45678<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从开始到第6个字符</span><br>leon@home-ubuntu22:~$ echo 12345678 | cut -c -6<br>123456<br></code></pre></td></tr></table></figure><p><strong>-c字符和-b字节区别</strong><br>对于英文字符，没有区别，对于中文，一个中文字符可能游多个字节就有区别了。（但我实测中文按字符剪切还是乱码，可能和编码也存在关系）</p><p>去掉第一个和最后倒数第一个字符</p><blockquote><p>cut本身并不支持倒数这种语法，需要借助其他工具。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">leon@home-ubuntu22:~$ <span class="hljs-built_in">echo</span> 12345678 | <span class="hljs-built_in">cut</span> -c 2- | rev | <span class="hljs-built_in">cut</span> -c 2- | rev<br>234567<br></code></pre></td></tr></table></figure><p>rev: 倒置一串字符。上面倒置切割再倒置。</p>]]></content>
    
    
    
    <tags>
      
      <tag>命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sed使用</title>
    <link href="/2022/09/03/04910dde347d/"/>
    <url>/2022/09/03/04910dde347d/</url>
    
    <content type="html"><![CDATA[<p>关键字：用法</p><h1 id="sed使用"><a href="#sed使用" class="headerlink" title="sed使用"></a>sed使用</h1><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sed [<span class="hljs-keyword">option</span>] [address]<span class="hljs-keyword">command</span> [input <span class="hljs-keyword">file</span>]<br></code></pre></td></tr></table></figure><p>如果没有输入文件，那么从标准输入中读取。</p><h4 id="option"><a href="#option" class="headerlink" title="option"></a>option</h4><table><thead><tr><th>option</th><th>作用</th></tr></thead><tbody><tr><td>-n</td><td>阻止输入行的自动输出(如需打印得需要p命令)</td></tr><tr><td>-f</td><td>使用脚本文件而不是命令行输入命令</td></tr><tr><td>-e</td><td>说明后面跟命令，命令行输入多个命令时使用。也可以使用大括号来实现</td></tr><tr><td>-E</td><td>使用扩展的正则</td></tr></tbody></table><p>sed默认使用的正则元字符较少（如不支持+？()|），所以<strong>建议加<code>-E</code>选项使用扩展的正则</strong>。这样和<code>egrep</code>, <code>grep -E</code>,<code>awk</code>正则表达式才相一致。</p><h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p>默认情况下，sed对每一个输入行都会执行command命令，如果只想对特定的行操作，那么需要address参数。</p><p>sed可以指定一个或两个地址。<br>如果只有一个地址，那么命令应用于这个地址匹配的行。<br>如果有两个地址，那么命令应用于第一个地址行和第二个地址行区间的所有行。</p><p>地址可以是一个数字，也可以是一个正则表达式。</p><p>如果地址后面跟有感叹号<code>!</code>，那么表示不匹配这些地址的行才应用命令。</p><p><strong>以删除命令d举例：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">删除每一行</span><br>sed &#x27;d&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除第二行</span><br>sed &#x27;2d&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除最后一行</span><br>sed &#x27;$d&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除空行</span><br>sed &#x27;/^$/d&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除带有hello的行，地址和<span class="hljs-built_in">command</span>之间可以加一个空格</span><br>sed &#x27;/hello/ d&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除从第一行到以<span class="hljs-built_in">id</span>:开始的行</span><br>sed &#x27;1,/^id:/ d&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除start开头，end结束之外的行</span><br>sed &#x27;/start/,/end/! d&#x27;<br></code></pre></td></tr></table></figure><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>d</td><td>删除</td></tr><tr><td>p</td><td>打印</td></tr><tr><td>s</td><td>替换</td></tr><tr><td>a</td><td>在处理行后面追加新行</td></tr><tr><td>i</td><td>在处理行之前插入</td></tr><tr><td>c</td><td>以内容替换当前行</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">打印匹配的行</span><br>sed -n &#x27;/aaa/p&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果aaa匹配，那么把这一行替换为bbb</span><br>sed &#x27;/aaa/ cbbbb&#x27;<br></code></pre></td></tr></table></figure><h2 id="替换-s"><a href="#替换-s" class="headerlink" title="替换(s)"></a>替换(s)</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[address]</span> s/<span class="hljs-selector-tag">pattern</span>/replacement/flags<br></code></pre></td></tr></table></figure><p>模式使用正则表达式，可以用任意字符分割，如果模式里面游<code>/</code>字符，那么使用其他字符分割更清晰，如替换网站协议(使用@分割)：<code>s@https://@http://@</code></p><h3 id="flags"><a href="#flags" class="headerlink" title="flags"></a>flags</h3><table><thead><tr><th>标志</th><th>作用</th></tr></thead><tbody><tr><td>n</td><td>1-512的一个数字，表示对第n次出现进行替换</td></tr><tr><td>g</td><td>对模式的所有次出现都做替换，默认第替换第一次出现</td></tr><tr><td>p</td><td>打印行,如果sed指定了-n不输出参数，这个参数有用</td></tr></tbody></table><h2 id="多重命令与地址嵌套"><a href="#多重命令与地址嵌套" class="headerlink" title="多重命令与地址嵌套"></a>多重命令与地址嵌套</h2><p>多重命令通过大括号包起来，分号分割。<br>地址嵌套就是通过大括号在命令前面再加地址即可。<br>举例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">把每一行的br0替换为br1, up替换为down</span><br>sed -E &#x27;&#123;s/br0/br1/; s/up/down/&#125;&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">对1-5行内，删除以#开头的行</span><br>sed -E &#x27;1,5 &#123;/^#/ d&#125;&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">对1-6行内，删除包含stp的行，行内包含eth0则进行替换</span><br>sed -E &#x27;1,6 &#123;/stp/ d; /eth0/ s/addif/delif/&#125;&#x27;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu server安装xfce4桌面</title>
    <link href="/2022/04/20/9027c38cc919/"/>
    <url>/2022/04/20/9027c38cc919/</url>
    
    <content type="html"><![CDATA[<h1 id="ubuntu-server安装xfce4桌面"><a href="#ubuntu-server安装xfce4桌面" class="headerlink" title="ubuntu server安装xfce4桌面"></a>ubuntu server安装xfce4桌面</h1><blockquote><p>一般而言不需要使用桌面环境，只是为了使用gitk看log，通过smaba共享，在windows上看log比较慢。</p><p>xfce桌面环境据说比较轻量，快捷，linus大神都是用这个</p></blockquote><h2 id="安装xfce4桌面"><a href="#安装xfce4桌面" class="headerlink" title="安装xfce4桌面"></a>安装xfce4桌面</h2><p>使用如下命令安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install xfce4 xfce4-terminal<br></code></pre></td></tr></table></figure><p>xfce4-terminal一并装上，不然桌面终端会使用xterm，xterm实在太简陋了（主要是字体太小，还不好调（ctrl+右键可以临时调一下））。</p><p>装完之后登录时需要选择xfce4桌面</p><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/image/2022-04/20-234459-7894-leon.png" alt="image-20220420234456899"></p><p>登录之后就可以看到桌面了<br><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/image/2022-04/20-234948-fbdd-leon.png"></p><h2 id="安装xrdp"><a href="#安装xrdp" class="headerlink" title="安装xrdp"></a>安装xrdp</h2><blockquote><p>如果图形化不方便，还可以使用远程桌面</p></blockquote><p>安装xrdp</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install xrdp<br></code></pre></td></tr></table></figure><p>配置默认会话使用xfce4（不然登录上自动断开了）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> xfce4-session &gt;~/.xsession<br></code></pre></td></tr></table></figure><p>如果不是用的xfce桌面，可以执行下面命令看下有那些session管理器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">update-alternatives <span class="hljs-attr">--display</span> <span class="hljs-attribute">x</span>-session-manager<br></code></pre></td></tr></table></figure><p>然后使用windows自带的远程桌面软件远程。</p><p><strong>只支持同一用户拥有一个会话，即本地用户登录后，远程用户便无法登录，必须要logout一个后才能登录。</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客使用</title>
    <link href="/2022/04/04/e4fd2d78b4bb/"/>
    <url>/2022/04/04/e4fd2d78b4bb/</url>
    
    <content type="html"><![CDATA[<h1 id="博客使用"><a href="#博客使用" class="headerlink" title="博客使用"></a>博客使用</h1><h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><p>略，这种东西搭一次要用好久，下一次再搭时，方法已经过时了，找官方搭建方法即可(<strong>官方的过时很久了，有坑</strong>)</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span>hexo-cli -g<br>hexo init <span class="hljs-keyword">blog</span><br><span class="hljs-keyword"></span>cd <span class="hljs-keyword">blog</span><br><span class="hljs-keyword"></span>npm <span class="hljs-keyword">install</span><br><span class="hljs-keyword"></span>hexo server<br></code></pre></td></tr></table></figure><p>hexo安装后，安装了fluid主题。然后配置了一下。</p><p><a href="https://hexo.io/zh-cn/docs/index.html">hexo官方文档</a><br><a href="https://fluid-dev.github.io/hexo-fluid-docs/start/">fluid官方文档</a></p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-comment">-- 这是生成的静态页面，hexo g命令生成，hexo clean会删除这个目录</span><br>source <span class="hljs-comment">-- 保存的文章</span><br></code></pre></td></tr></table></figure><h2 id="hexo命令"><a href="#hexo命令" class="headerlink" title="hexo命令"></a>hexo命令</h2><ul><li><p><code>hexo init name</code><br>初始化一个博客</p></li><li><p><code>hexo new title</code>, 简写<code>hexo n</code><br>新建一个文章，也可以不用这命令，直接去source&#x2F;_posts目录建md文件，差不太多</p></li><li><p><code>hexo generate</code>, 简写<code>hexo g</code><br>生成静态文件，可加<code>-d</code>选项，表示生成后部署</p></li><li><p><code>hexo server</code>，简写<code>hexo s</code><br>启动本地服务器</p></li><li><p><code>hexo deploy</code>，简写<code>hexo d</code><br>将静态页面部署出去</p></li><li><p><code>hexo clean</code><br>清理生成的静态文件<br>如果已经发布的文章，无法删除，需要删掉<code>.deploy_git</code>目录</p></li></ul><h2 id="分类，标签"><a href="#分类，标签" class="headerlink" title="分类，标签"></a>分类，标签</h2><p>markdown文件中添加如下内容</p><p>date–创建时间<br>updated–更新时间</p><p>如果不指定时间，将会根据文件的创建修改时间决定</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章名</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2017-05-26 12:12:57</span><br><span class="hljs-attr">updated:</span> <span class="hljs-number">2022-4</span><span class="hljs-number">-3</span> <span class="hljs-number">17</span><span class="hljs-string">:11:27</span><br><span class="hljs-attr">categories:</span> <br><span class="hljs-bullet">-</span> <span class="hljs-string">分类名只能有一个</span><br><span class="hljs-attr">tags:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">标签</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">表格</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">表单验证</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p> 如果是部署到github page，那么<code>hexo g -d</code>提交代码后，大约隔一分钟访问才会刷新，这是gitbub page的编译机制吧。</p><p>配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:leon0625/leon0625.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br></code></pre></td></tr></table></figure><p>然后在git仓库里面加开发者秘钥。</p><h2 id="自动部署"><a href="#自动部署" class="headerlink" title="自动部署"></a>自动部署</h2><p>要在每台电脑上写博客，那么需要在每台电脑上安装hexo。通过nextcloud同步博客数据虽说也不是太麻烦。但笔记本身会在obsidian存一份，需要发布的笔记又要复制一份到blog目录，更新的时候也需要复制，不是很方便。</p><p>构想如下：</p><pre><code class=" mermaid">sequenceDiagramautonumberparticipant J as obsidianparticipant N as nextcloud服务器participant G as github.ioN -&gt;&gt; N: 检查是否有md文件修改J-&gt;&gt;N: 编辑保存后同步过来N -&gt;&gt; G:检查到有posthex标志&lt;br/&gt;有的话自动构建部署</code></pre><p><strong>nextcloud上的处理流程</strong></p><pre><code class=" mermaid">flowchart a1((启动)) --&gt; a2(遍历obsidian目录) --&gt; a3(有postHexo标志) --&gt;|是| a4(分析文本)a3 --&gt; |否|a2a2 --&gt; |遍历结束| b1(监控文件变化)a4 --&gt; c2(&quot;复制到hexo blog目录(重命名文件，更新updated字段)&quot;) b1 --&gt; |文件变化| d1(有postHexo标志) --&gt; |否|b1 c1(&quot;提取updated字段，提取title&quot;) d1 --&gt; |是|c1 --&gt; c2 --&gt; e1(hexo g -d部署)</code></pre><p>updated字段使用nextcloud上文件的修改时间。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ros ipv6配置</title>
    <link href="/2022/03/22/0621cfc53e84/"/>
    <url>/2022/03/22/0621cfc53e84/</url>
    
    <content type="html"><![CDATA[<h1 id="ros-ipv6配置"><a href="#ros-ipv6配置" class="headerlink" title="ros ipv6配置"></a>ros ipv6配置</h1><p>官方文档：<a href="https://wiki.mikrotik.com/wiki/Manual:TOC">https://wiki.mikrotik.com/wiki/Manual:TOC</a></p><h2 id="拓扑图"><a href="#拓扑图" class="headerlink" title="拓扑图"></a>拓扑图</h2><pre><code class=" mermaid">flowchart TBgm(&quot;光猫(桥模式)&quot;)ROS((&quot;ROS&quot;))R1(&quot;Router1&quot;)R2(&quot;Router2&quot;)R3(&quot;Router3...&quot;)R4(&quot;Router4&quot;)gm ---|pppoe拨号| ROSROS ---|&quot;pppoe或者dhcp&quot;|R1ROS ---|&quot;pppoe或者dhcp&quot;| R2ROS ---|&quot;pppoe或者dhcp&quot;| R3R1---PC(&quot;电脑&quot;)R1 -.- phone(&quot;手机&quot;)R2 x--x |不能再连路由器,R2无法提供前缀|R4</code></pre><h2 id="安装ipv6包"><a href="#安装ipv6包" class="headerlink" title="安装ipv6包"></a>安装ipv6包</h2><p>默认没有安装，需要手动点击安装</p><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/image/2022-03/22-162110-d8a8-leon.png" alt="image-20220322162110532"></p><h2 id="操作原理"><a href="#操作原理" class="headerlink" title="操作原理"></a>操作原理</h2><p>IPV6不同于IPV4最大的一点在于IPV6的地址是全局的。这就需要上级路由器在路由时能够准确把各个地址路由到不同的设备。</p><p>ROS拨号运营商时，可以通过dhcp获取到一个60位长度的代理前缀。ipv6前缀长度至多64位。所以给ROS的操作空间还有4位（<strong>共16个前缀可用</strong>）。</p><p>ROS bridge自身使用一个前缀，一个pppoe客户端会使用两个前缀。一个dhcp客户端使用一个前缀。</p><p>所以理论上可以供15个dhcp客户端（或者7个pppoe客户端）获取代理前缀。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>先把光猫拨号这边配置好，拿到运营商给的代理前缀。</p><h3 id="pppoe-client拨号配置"><a href="#pppoe-client拨号配置" class="headerlink" title="pppoe client拨号配置"></a>pppoe client拨号配置</h3><p>主要是选好拨号接口（ether1），profile创建一个新的（配置默认即可）避免和后面的pppoe 服务器冲突</p><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/image/2022-03/23-184217-1954-leon.png" alt="image-20220323184217839"></p><h3 id="dhcp-v6-client配置"><a href="#dhcp-v6-client配置" class="headerlink" title="dhcp v6 client配置"></a>dhcp v6 client配置</h3><p>配置dhcp v6 client去获取代理前缀。</p><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/image/2022-03/23-184433-3d47-leon.png" alt="image-20220323184433626"></p><p>勾选前缀代理之后，获取到前缀后会自动生成一条pool配置，如下：</p><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/image/2022-03/23-184458-8914-leon.png" alt="image-20220323184458077"></p><p><code>prefix</code>是上级通过dhcpv6下发下来，<code>prefix length</code>是上面自己配置的，即这个pd_auto_pool地址池下发前缀的活动空间有4bit位。如果配置的Pool Prefix Length小于下发的长度，那么prefix length默认会在代理前缀长度的基础上加8。</p><h3 id="dhcp-v6-server配置"><a href="#dhcp-v6-server配置" class="headerlink" title="dhcp v6 server配置"></a>dhcp v6 server配置</h3><p>这个配置比较简单，只需要选中前面自动生成的pool即可。</p><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/image/2022-03/22-163801-e5df-leon.png" alt="image-20220322163801321"></p><p><strong>注意：我实测有状态从ros拿地址拿不到，不清楚原因。看了mikrotik的wiki，没找到有状态配置的相关信息，直接不支持有状态获取地址了？</strong></p><h3 id="桥接口地址配置"><a href="#桥接口地址配置" class="headerlink" title="桥接口地址配置"></a>桥接口地址配置</h3><p>给桥接口配置ipv6地址，地址为pool前缀::1&#x2F;64，advertise勾上，会自动在ND配置prefix（radvd的前缀）</p><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/image/2022-03/22-164033-967b-leon.png" alt="image-20220322164033783"></p><p>配置完这一步，会在ND配置哪儿自动生成prefix，如下：</p><p>这下面有三个prefix，都是自动生成的。</p><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/image/2022-03/23-184650-a1b8-leon.png" alt="image-20220323184650839"></p><h3 id="RADVD配置"><a href="#RADVD配置" class="headerlink" title="RADVD配置"></a>RADVD配置</h3><p>就是上面的ND interfaces里面，基本不用配置，默认配置即可。</p><p><strong>配置前缀和有效期</strong></p><blockquote><p>配置有效期，避免ROS上的前缀已经过期了，设备还一直使用</p></blockquote><p>ND –&gt; prefixes –&gt; default</p><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/image/2022-03/30-190111-31c2-leon.png" alt="image-20220330190111202"></p><h3 id="pppoe服务器配置"><a href="#pppoe服务器配置" class="headerlink" title="pppoe服务器配置"></a>pppoe服务器配置</h3><p>重点配置为如下勾选的三个。</p><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/image/2022-03/23-185233-c8cc-leon.png" alt="image-20220323185233891"></p><p>当勾选Remote Ipv6 prefix pool后，会自动给ROS的ppp接口添加ipv6前缀广播RA，这样下级路由器的ppp接口就能拿到全局地址</p><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/image/2022-03/23-185438-38ba-leon.png" alt="image-20220323185438395"></p><p>当勾选DHCPv6 PD Pool时，会自动生成dhcpv6的配置</p><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/image/2022-03/23-185607-4d96-leon.png" alt="image-20220323185607047"></p><p><code>Interface List</code>配置为LAN，确保路由器pppoe客户端拨号后，能够拿到代理前缀。以及拨号的情况下，确保PC可以进ROS管理页面。</p><p>（不是LAN上来的数据包会在filter里面被过滤掉）</p><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/image/2022-03/23-185817-0b2b-leon.png" alt="image-20220323185817403"></p><p>配置为LAN后，会自动添加如下配置</p><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/image/2022-03/23-185942-ea98-leon.png" alt="image-20220323185942930"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>ROS貌似不支持有状态获取地址。它的文档里面也没有提及有状态获取地址的部分。</li><li>如上的配置不支持路由器下面再接路由器，因为没有可供使用的前缀了。</li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="路由器DHCP切换PPPOE接入，无法拿到代理前缀问题"><a href="#路由器DHCP切换PPPOE接入，无法拿到代理前缀问题" class="headerlink" title="路由器DHCP切换PPPOE接入，无法拿到代理前缀问题"></a>路由器DHCP切换PPPOE接入，无法拿到代理前缀问题</h3><p>抓包看，ROS下发的dhcpv6里面的代理前缀的合法时间为0，导致路由器反复请求。</p><p><strong>解决办法：</strong></p><p>在ROS的DHCP Server里面删掉这个设备之前DHCP的Bindings条目即可。</p><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/2022-04/22-181049-a72a-leon.png"></p><p><strong>可能原因分析：</strong></p><p>dhcp和pppoe接入时，路由器使用的DUID是一样的，可能导致ROS出现问题。而且路由器在断开DHCP前是发了RELEASE的。</p><p>如果设置路由器的DUID为mac+时间类型，则没有问题。</p><p><strong>ROS v7.7版本解决了这个问题</strong></p><p><strong>高版本的ros好像无法配置静态的ipv6地址池</strong><br>地址池配置为fd00，dhcp服务器那边才可以使用。</p>]]></content>
    
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>perl语言入门第六版读书笔记</title>
    <link href="/2022/02/20/d716b92474cf/"/>
    <url>/2022/02/20/d716b92474cf/</url>
    
    <content type="html"><![CDATA[<h1 id="perl语言入门第六版"><a href="#perl语言入门第六版" class="headerlink" title="perl语言入门第六版"></a>perl语言入门第六版</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>本书涵盖的最低版本5.8</li><li>CPAN,perl综合典藏网，里面包含扩展，文档等</li><li>perl解析器能一次完成编译和运行这两个动作。（注意是有先编译，即运行前就可以检查到整个代码的语法错误）</li></ul><h2 id="标量数据"><a href="#标量数据" class="headerlink" title="标量数据"></a>标量数据</h2><ul><li>perl每个语句必须以分号；结束</li><li>perl的数字可以通过下划线分割，方便理解<code>0x1234_2222_ffff</code></li><li>perl虽然都是浮点数，但是支持取模运算（%）</li><li>如果源代码中有ascii之外的字符，那么加上一行<code>use utf8;</code>，让编译器正确解释你的代码。</li><li>单引号内除了反斜杠和自身，所有字符都代表它们自己，包块换行符</li><li>字符串的连接操作使用的<code>.</code>号</li><li>字符串的重复操作使用的小写字母<code>x</code>，<code>&quot;aaa&quot; x 3</code>重复aaa 3次。</li><li>perl里面包含大量的默认行为，当发现程序不对时，可以打开警告<code>use warnings;</code>，也可在命令行中添加<code>-w</code>选项。<code>use warnings;</code>说的更灵活，可以指定某几行代码警告。</li><li>标量的变量前缀为<code>$</code></li><li>字符串比较运算符使用的<code>eq</code>,<code>ne</code>不等，<code>lt</code>小于操作符</li><li>字符串’0’非空，但是代表条件假。它是唯一的非空字符串假</li><li><code>&lt;STDIN&gt;</code>获取用户输入</li><li><code>chomp($text)</code>去掉结尾的换行符，<code>chomp($text=&lt;STDIN&gt;)</code></li><li>要判断某个字符串是undef而不是空字符串，可使用defined函数，如果是undef,那么返回假</li><li>print函数中内插变量时，如果变量后面紧跟字符，那么变量应使用形式<code>print &quot;$&#123;var&#125;a&quot;</code>形式，避免perl认为变量名包含后面紧跟的字符a</li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul><li>截取字符串函数substr<br><code>my $part = substr($string, $pos, $length);</code><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># 截取开头4个字符，末尾两个字符，用..拼接起来。</span><br><span class="hljs-keyword">print</span> <span class="hljs-keyword">substr</span>(<span class="hljs-variable">$_</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>) . <span class="hljs-string">&quot;..&quot;</span> . <span class="hljs-keyword">substr</span>(<span class="hljs-variable">$_</span>, -<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure></li></ul><h2 id="列表和数组"><a href="#列表和数组" class="headerlink" title="列表和数组"></a>列表和数组</h2><ul><li>引用整个数组时，数组名前面添加<code>@</code>符号。</li><li>数组下标从0开始，最后一个索引值为<code>$#array</code>，取最后一个元素，可直接用<code>$array[-1]</code></li><li>可用两个点<code>..</code>操作符产生一个整数列表，如<code>1..100</code>，只能递增。</li><li>可用<code>qw</code>操作符，产生一个字符串列表，perl发明人可真懒</li><li>pop读出数组最后一个元素并返回，push添加元素到最后</li><li>shift,unshift操作最左边的元素，和pop,push类似</li><li><code>@removed = splice @array,idx,del_num,@insert_array</code>, 移除idx开始的n个元素，并插入一个数组，返回移除的数组。后两个参数可选，默认移除从idx到最后的所有元素。</li><li><code>print @array</code>会将数组元素一个个打印出来，<code>print &quot;@array&quot;</code>，会在数组元素中间加一个空格打印出来。<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">foreach</span> <span class="hljs-variable">$i</span> (<span class="hljs-keyword">qw</span> / aa bb cc /)&#123;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;<span class="hljs-variable">$i</span>&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>foreach的控制变量并没有复制数组里面的值，相当于引用。修改控制变量会直接修改到数组本身。</li><li>foreach可以省略控制变量，会使用默认变量<code>$_</code></li><li><code>reverse</code>返回一个持续相反的列表，并不改变原列表</li><li><code>sort</code>返回ascii序的列表，也不会改变原列表</li><li>数组的名称在列表上下文，返回元素的列表。在标量的上下文，返回数组元素个数。</li><li><code>chomp(@lines = &lt;STDIN&gt;)</code> 读所有行，并移除换行符</li></ul><h2 id="子程序"><a href="#子程序" class="headerlink" title="子程序"></a>子程序</h2><ul><li>不需要子程序事先声明，如果有两个同名子程序，后面的会覆盖前面的</li><li>所有子程序都有返回值，没有明确指定return的话，返回值就是最后一次运算结果的值</li><li>perl自动将参数列表存在名为<code>@_</code>的数组变量中，那么第一个参数为<code>$_[0]</code></li><li>默认perl的所有变量都是全局变量，创建私有变量要使用<code>my</code>。</li><li>my操作符后面不加括号，只能声明单个局部变量，加括号才能声明多个，实际上是声明的一个列表。</li><li><code>use strict</code>让perl严格约束代码</li><li>如果编译器在调用子程序时看到过子程序的定义，那么调用子程序的时候可以省略<code>&amp;</code>号，添加<code>&amp;</code>也可以避免和perl内置函数同名的问题，<code>&amp;</code>总是会调用自定义的子程序。</li><li>单写一个return不给任何参数，表明返回的空。对于标量上下文，就是undef，列表上下文就是空列表。</li><li>持久私有变量。类似于静态变量。state操作符声明，需要使用<code>use feature &#39;state&#39;</code>语句</li></ul><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">while</span>(&lt;&gt;)&#123;<br><span class="hljs-keyword">chomp</span>;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;get line: <span class="hljs-variable">$_</span>\n&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">print</span> &lt;&gt;; <span class="hljs-comment">#相当于cat命令</span><br><span class="hljs-keyword">print</span> <span class="hljs-keyword">sort</span> &lt;&gt;; <span class="hljs-comment">#相当于sort命令</span><br></code></pre></td></tr></table></figure><ul><li>建议用大写字母命名文件句柄</li><li>有6个特殊的文件句柄是perl保留的：STDIN,STDOUT,STDERR,DATA,ARGV,ARGVOUT</li><li>可通过如下命令打开文件句柄</li></ul><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">open</span> FH, <span class="hljs-string">&#x27;filename&#x27;</span>; <span class="hljs-regexp">//</span>默认读打开<br><span class="hljs-keyword">open</span> FH, <span class="hljs-string">&#x27;&lt;filename&#x27;</span>;<span class="hljs-regexp">//</span>读<br><span class="hljs-keyword">open</span> FH, <span class="hljs-string">&#x27;&gt;filename&#x27;</span>;<span class="hljs-regexp">//</span>写<br><span class="hljs-keyword">open</span> FH, <span class="hljs-string">&#x27;&gt;&gt;filename&#x27;</span>;<span class="hljs-regexp">//</span>追加<br><br><span class="hljs-comment"># 也可以用三个参数的写法</span><br><span class="hljs-keyword">open</span> FH, <span class="hljs-string">&#x27;&gt;&#x27;</span>,<span class="hljs-string">&#x27;filename&#x27;</span>;<br><span class="hljs-comment"># 可以指定编码</span><br><span class="hljs-keyword">open</span> FH, <span class="hljs-string">&#x27;&lt;:encoding(UTF-8)&#x27;</span>, <span class="hljs-string">&#x27;filaname&#x27;</span>;<br><br><span class="hljs-comment">#关闭</span><br><span class="hljs-keyword">close</span> FH;<br><br><span class="hljs-comment"># 从5.6开始，句柄可以存放到变量中，方便作为参数传递，控制作用域</span><br><span class="hljs-keyword">my</span> <span class="hljs-variable">$fh</span>;<br><span class="hljs-keyword">open</span> <span class="hljs-variable">$fh</span>, <span class="hljs-string">&quot;&gt;&quot;</span>, <span class="hljs-string">&quot;filename&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li>二进制方式读写<code>binmode</code></li><li><code>die &quot;some error: $!&quot;;</code>结束程序并打印东西，<code>$!</code>表示系统错误信息，类似strerror。</li><li>die会自动打印行号和文件名，如果不需要打印这个，那么只需在后面加一个换行符。</li><li>warn函数差不多，只是不会终止程序运行。</li><li>5.10开始，可以用<code>use autodie;</code>。它如果检查到系统调用级别的错误，就会自动die。相当于不用检查文件打开是否成功这类错误了。</li><li>$0中保存了程序的名字</li><li>文件句柄的使用和之前用得STDIN差不多。<code>print LOG &quot;xxxx&quot;</code>，将字符串输出到LOG这个句柄里。</li><li>重新打开已经打开的句柄时，perl会自动关闭原来的句柄，比如可通过如下语句重定向错误输出到文件<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">open STDERR, <span class="hljs-string">&quot;&gt;&gt;error.log&quot;</span>;<br></code></pre></td></tr></table></figure></li><li>5.10开始有一个say函数，和print差不多，只是自动加一个换行符。</li></ul><p><strong>ARGV相关</strong></p><ul><li><p><code>$ARGV</code> 表示参数命令行的文件中，当前正在处理的文件名</p></li><li><p><code>@ARGV</code> 里面保存了命令行的参数列表，一般就是输入的文件名，在<code>&lt;&gt;</code>操作中，列表的元素会一个个移除</p></li><li><p><code>ARGV</code>表示<code>&lt;&gt;</code>当前正在处理的文件句柄。</p></li></ul><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><ul><li><p>键必须是唯一的字符串</p></li><li><p>访问hash的语法为<code>$hash&#123;$key&#125;</code>，大括号</p></li><li><p>访问整个哈希，可以使用%作为前缀。哈希可以转换为列表。列表也可以赋值给hash。</p></li><li><p><code>%reverse_hash = reverse %any_hash</code> 可以建立一个反序的哈希，即key-value变为value-key。</p></li><li><p>给hash赋值可以使用列表的形式：<code>%some_hash = (&#39;key1&#39;, 22, &#39;key2&#39;, &quot;333&quot;)</code>。这种形式不方便看。可以使用胖箭头 <code>=&gt;</code> ，对perl而言，它只是逗号的另一种写法，唯一的区别在于胖箭头左边的裸字都会加上引号。于是可以这样初始化hash：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">my</span> <span class="hljs-variable">%some_hash</span> = (<br><span class="hljs-string">key1 =&gt;</span> <span class="hljs-string">&quot;1231&quot;</span>,<br><span class="hljs-string">key2 =&gt;</span><span class="hljs-number">123</span>,<br><span class="hljs-string">key3 =&gt;</span> &#123; <span class="hljs-comment"># hash嵌套</span><br><span class="hljs-string">aaa =&gt;</span> <span class="hljs-number">222</span>,<br><span class="hljs-string">bbb=&gt;</span> <span class="hljs-number">233</span>,<br>&#125;<br>);<br></code></pre></td></tr></table></figure></li><li><p><strong>注意hash初始化使用的圆括号,嵌套时用大括号</strong></p></li><li><p>访问hash元素的时候可以省略key的引号，<code>$hash&#123;&quot;aaa&quot;&#125;</code> 和<code>$hash&#123;aaa&#125;</code>同义。</p></li><li><p><code>my @k = keys %hash</code>， <code>my @v = values %hash</code> 两个函数可用于提取所有key和value</p></li><li><p>each函数变量hash</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">while</span> ((<span class="hljs-variable">$key</span>, <span class="hljs-variable">$value</span>) = <span class="hljs-keyword">each</span> <span class="hljs-variable">%hash</span>)&#123;<br>;<br>&#125;<br></code></pre></td></tr></table></figure><p>echo会从hash中返回键值对，这是一个两个元素的列表。而赋值后得到的列表在标量上下文就是元素个数，为2。所以一直循环，知道取不出来值。</p></li><li><p><code>exists</code>函数用户检查hash中是否存在某个键：<code>if(exists $books&#123;leon&#125;)</code></p></li><li><p><code>delete $books&#123;leon&#125;</code> 函数用于删除某个键值对。</p></li><li><p>hash元素可以内插，但是不支持内插整个hash。如果想要打印整个hash，可以先把hash赋值给列表，然后内插整个列表。</p></li><li><p><code>%ENV</code>这个内置的hash存储了环境变量</p></li></ul><h2 id="漫游正则表达式王国"><a href="#漫游正则表达式王国" class="headerlink" title="漫游正则表达式王国"></a>漫游正则表达式王国</h2><ul><li>正则表达式和glob（shell的文件名匹配模式）不是同一个东西</li><li>捕获分组时，反向应用的方法是<code>\1</code>,<code>\2</code>。如何知道是第一个还是第二个，从左到右数括号的序号即可。从perl 5.10开始支持<code>\g&#123;N&#125;</code>来表示是第几组，可以更方便，可以指定负数</li><li>perl 5.10开始引入<code>\R</code>能匹配任意一种换行符</li><li>反义简写，<code>\D</code>非数字，<code>\W</code>非单词, <code>\S</code>非空白符</li></ul><h2 id="用正则表达式进行匹配"><a href="#用正则表达式进行匹配" class="headerlink" title="用正则表达式进行匹配"></a>用正则表达式进行匹配</h2><ul><li><p><code>m/xxx/flag</code> ，如果以<code>//</code>作为定界符，那么m可以省略。当然为了方便可以用其他的定界符。flag有：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">i <span class="hljs-comment">-- 忽略大小写</span><br>m <span class="hljs-comment">-- 多行匹配</span><br>s <span class="hljs-comment">-- 匹配任意字符，默认情况下点号 . 无法匹配换行符，如果指定了这个就可以匹配了。</span><br>x <span class="hljs-comment">-- 忽略正则表达式中的空白符，这样方便分割正则表达式，让正则表达式看起来更清晰(可以分行写，每行写注释)</span><br>p <span class="hljs-comment">-- ^PREMATCH, ^MATCH, ^POSTMATCH变量使用</span><br><br>perl <span class="hljs-number">5.14</span>开始可以指定如果解释字符：<br><span class="hljs-keyword">a</span> <span class="hljs-comment">-- ascii</span><br>u <span class="hljs-comment">-- unicode</span><br>l <span class="hljs-comment">-- 使用本地化的语言设置</span><br></code></pre></td></tr></table></figure></li><li><p>锚位，不匹配任何字符，但可以指定位置</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ada">^ <span class="hljs-comment">-- 行首</span><br>$ <span class="hljs-comment">-- 行尾</span><br>\A <span class="hljs-comment">-- 字符串的绝对开头，多行的情况下和^有一点区别，单行和^同义</span><br>\Z <span class="hljs-comment">-- 字符串的绝对末尾</span><br>\b <span class="hljs-comment">-- 单词边界</span><br>\B <span class="hljs-comment">-- 非单词边界</span><br></code></pre></td></tr></table></figure></li><li><p>绑定操作符<code>=~</code>，默认情况下，正则匹配<code>$_</code>变量，<code>$var =~ /reg/</code>可以使其匹配<code>$var</code>变量。</p></li><li><p>正则表达式中可以内插变量。</p></li><li><p>如果正则表达式有括号，表示要捕获这个分组，但有时不想捕获，可以使用<code>(?:xxx)</code>，表示不捕获这个分组。</p></li><li><p>命名捕获。perl 5.10开始，可以直接把捕获的分组存入内置的<code>%+</code>这个hash变量中， <code>(?&lt;name&gt;regex)</code>。使用这个变量的方法为<code>$+&#123;name&#125;</code></p></li><li><p>使用命名捕获后，反向引用的语法也随之改变为<code>\g&#123;label&#125;</code></p></li><li><p>自动捕获变量。perl会自动把匹配前，匹配，匹配后的三串字符串存入如下三个变量，perl 5.10后，使用<code>/p</code> flags会将结果存入更容易记忆的几个变量。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$`</span>  --- <span class="hljs-variable">$&#123;</span>^PREMATCH&#125;<br><span class="hljs-variable">$&amp;</span>  --- <span class="hljs-variable">$&#123;</span>^MATCH&#125;<br><span class="hljs-variable">$&#x27;</span>  --- <span class="hljs-variable">$&#123;</span>^POSTMATCH&#125;<br><span class="hljs-comment"># 后面的三个变量也好理解，外面的花括号围住表示其中是完整的变量名，变量名前面加^避免重复。</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="用正则表达式处理文本"><a href="#用正则表达式处理文本" class="headerlink" title="用正则表达式处理文本"></a>用正则表达式处理文本</h2><ul><li><p><code>s///</code>进行替换，返回bool值，成功为真，否则为假</p></li><li><p><code>/g</code>全局替换</p></li><li><p>同<code>m//</code>一样，替换也可以使用不同的定界符，对于没有左右之分的字符，写三个就行，如果不是就需要成对写，如下几种意思一样：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">s</span>/<span class="hljs-number">123</span>/<span class="hljs-number">456</span>/<br><span class="hljs-attribute">s</span>|<span class="hljs-number">123</span>|<span class="hljs-number">456</span>|<br><span class="hljs-attribute">s</span>&#123;<span class="hljs-number">123</span>&#125;&#123;<span class="hljs-number">456</span>&#125;<br><span class="hljs-attribute">s</span>[<span class="hljs-number">123</span>](<span class="hljs-number">456</span>)<br></code></pre></td></tr></table></figure></li><li><p>和<code>m//</code>一样，替换也可以使用绑定操作符<code>$aa =~ s/123/456/</code></p></li><li><p><code>/r</code>不直接操作源字符串，而是返回一个新的。<code>my $copy = $orig =~ s/111/222/</code></p></li><li><p>大小写转换</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\U</span> -- 把之后的所有字符转为大写， s<span class="hljs-regexp">/aaa/</span><span class="hljs-string">\U$var/</span><br><span class="hljs-string">\L</span> -- 把后面的所有字符转为小写<br><span class="hljs-string">\E</span> -- 停止后面的字符转换<br><span class="hljs-string">\u,</span> <span class="hljs-string">\l</span> -- 只转换一个字符<br></code></pre></td></tr></table></figure><p>上面的转换在print里面也是可以用得。</p></li><li><p><code>split /separator/, &#39;$string&#39;</code>操作符。分割字符串，返回列表。默认以空白字符分割，默认操作<code>$_</code>变量。</p></li><li><p>如果要在split的模式中使用分组，那么要使用分组不捕获写法<code>(?:)</code></p></li><li><p><code>join aaa, @array</code>，在字符串中加入粘合剂</p></li><li><p>在列表上下文，使用<code>m//</code>，匹配成功返回所有捕获分组的列表，失败返回空列表</p></li><li><p><code>$^I = &quot;.bak&quot;</code>变量，设置后，钻石操作符<code>s///</code>时，会直接写原文件，但会有一个备份文件生成。如果设置这个字符串为空串，那么不会生成备份文件。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-variable">$^I</span> = <span class="hljs-string">&quot;.bak&quot;</span>;<br><span class="hljs-keyword">while</span> (&lt;&gt;)&#123;<br><span class="hljs-regexp">s/aaa/bbb/g</span>;<br><span class="hljs-keyword">print</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>有时替换可以先使用占位符<code>\0</code>，或者chomp后使用<code>\n</code>。</p></li></ul><h2 id="其他控制结构"><a href="#其他控制结构" class="headerlink" title="其他控制结构"></a>其他控制结构</h2><ul><li><p>表达式修饰符，即可以在一行里面写上if , foreach这种。使用foreach修饰符的时候无法自选控制变量，必须使用<code>$_</code></p><p><code>print &quot;ok&quot; if $ok;</code></p></li><li><p>foreach和for其实等价，如果括号内没有分号，那么是foreach循环，如果有分号那么是for循环。</p></li><li><p>last操作符等价于break</p></li><li><p>next操作符等价于continue</p></li><li><p>redo操作符合next相似，区别在于，next会继续下一次迭代，而redo会重新执行这次迭代</p></li><li><p>带标签的块，可以让里层直接跳到外层的某个循环点</p></li><li><p>定义或操作符<code>//</code>，看着跟着注释符一样…。如果左侧的值未定义（undef），那么使用右侧的值，常用于赋默认值</p><p><code>my $last_name = $last_name&#123;$someone&#125; // &#39;(no last name)&#39;;</code></p></li></ul><h2 id="perl模块"><a href="#perl模块" class="headerlink" title="perl模块"></a>perl模块</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> File::Basename; <span class="hljs-comment"># 导入模块</span><br><span class="hljs-keyword">use</span> File::Basename <span class="hljs-keyword">qw</span>/basename/; <span class="hljs-comment"># 导入模块的特定函数</span><br>basename <span class="hljs-variable">$name</span>; <span class="hljs-comment">#只是使用模块内函数名</span><br>File::Basename::dirname <span class="hljs-variable">$name</span>; <span class="hljs-comment"># 全称使用模块函数</span><br></code></pre></td></tr></table></figure><ul><li>还有中面向对象的模块，使用的使用需要使用瘦箭头<code>-&gt;</code></li></ul><h3 id="DateTime模块"><a href="#DateTime模块" class="headerlink" title="DateTime模块"></a>DateTime模块</h3><p><a href="https://metacpan.org/release/DROLSKY/DateTime-0.31/view/lib/DateTime.pm">文档</a></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> DateTime; <br><span class="hljs-keyword">my</span> <span class="hljs-variable">$dt</span> = DateTime-&gt;now;<br><span class="hljs-variable">$ymd</span>    = <span class="hljs-variable">$dt</span>-&gt;ymd;           <span class="hljs-comment"># 2002-12-06</span><br><span class="hljs-variable">$ymd</span>    = <span class="hljs-variable">$dt</span>-&gt;ymd(<span class="hljs-string">&#x27;/&#x27;</span>);      <span class="hljs-comment"># 2002/12/06 - also date</span><br> <br><span class="hljs-variable">$mdy</span>    = <span class="hljs-variable">$dt</span>-&gt;mdy;           <span class="hljs-comment"># 12-06-2002</span><br><span class="hljs-variable">$mdy</span>    = <span class="hljs-variable">$dt</span>-&gt;mdy(<span class="hljs-string">&#x27;/&#x27;</span>);      <span class="hljs-comment"># 12/06/2002</span><br> <br><span class="hljs-variable">$dmy</span>    = <span class="hljs-variable">$dt</span>-&gt;dmy;           <span class="hljs-comment"># 06-12-2002</span><br><span class="hljs-variable">$dmy</span>    = <span class="hljs-variable">$dt</span>-&gt;dmy(<span class="hljs-string">&#x27;/&#x27;</span>);      <span class="hljs-comment"># 06/12/2002</span><br> <br><span class="hljs-variable">$hms</span>    = <span class="hljs-variable">$dt</span>-&gt;hms;           <span class="hljs-comment"># 14:02:29</span><br></code></pre></td></tr></table></figure><h3 id="Time-Piece模块"><a href="#Time-Piece模块" class="headerlink" title="Time::Piece模块"></a>Time::Piece模块</h3><p>（5.10内置）</p><p><a href="https://metacpan.org/pod/Time::Piece">文档</a></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">use</span> Time::Piece;<br> <br><span class="hljs-keyword">my</span> <span class="hljs-variable">$t</span> = <span class="hljs-keyword">localtime</span>; <span class="hljs-comment"># 得到一个当前时间的对象，里面可以便捷的访问时间</span><br><span class="hljs-variable">$t</span>-&gt;sec                 <span class="hljs-comment"># also available as $t-&gt;second</span><br><span class="hljs-variable">$t</span>-&gt;min                 <span class="hljs-comment"># also available as $t-&gt;minute</span><br><span class="hljs-variable">$t</span>-&gt;hour                <span class="hljs-comment"># 24 hour</span><br><span class="hljs-variable">$t</span>-&gt;hms                 <span class="hljs-comment"># 12:34:56</span><br><span class="hljs-variable">$t</span>-&gt;hms(<span class="hljs-string">&quot;.&quot;</span>)            <span class="hljs-comment"># 12.34.56</span><br></code></pre></td></tr></table></figure><h3 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h3><p>先在cpan网搜索自己需要什么模块，然后通过命令安装,<br>示例如下，第一次可能需要配置，自动即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">sudo</span> cpan</span><br><span class="hljs-meta prompt_">cpan[1]&gt; </span><span class="language-bash">install JSON</span><br><span class="hljs-meta prompt_">cpan[2]&gt; </span><span class="language-bash">install Text::CSV</span><br></code></pre></td></tr></table></figure><h2 id="文件测试"><a href="#文件测试" class="headerlink" title="文件测试"></a>文件测试</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">if</span>(-e <span class="hljs-variable">$filename</span>)&#123;<br><span class="hljs-keyword">print</span> <span class="hljs-string">&quot;xxxxxx\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/image/2022-02/27-095920-cbb6-leon.png" alt="image-20220227095918759"></p><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/image/2022-02/27-100000-d0fb-leon.png" alt="image-20220227095959828"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>git用法总结</title>
    <link href="/2020/10/14/1132452c5a90/"/>
    <url>/2020/10/14/1132452c5a90/</url>
    
    <content type="html"><![CDATA[<h1 id="git使用"><a href="#git使用" class="headerlink" title="git使用"></a>git使用</h1><blockquote><p>git 2.23之后，多了switch和restore命令，git –help已看不到checkout的踪影（还是支持）。因为checkout用法太多，语义的歧义太大了。</p><p>但是很多商业公司一直用着老旧的系统，老旧的软件，所以下面基本只会涉及checkout命令。</p></blockquote><p>[toc]</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>（1）初次配置用户名邮箱</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;leon&quot;</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> xxx@xxx<br></code></pre></td></tr></table></figure><p>（2）解决git status中文文件名乱码</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">git config --global core.quotepath <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>（3）关闭git自动转换换行符</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">git config --global core.<span class="hljs-built_in">auto</span>crlf <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>（4）git status时忽略权限改变</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">git config core.filemode <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>（5）配置默认编辑器</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global core.editor vim</span><br>git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global merge.tool vimdiff</span><br></code></pre></td></tr></table></figure><p>（6）配置别名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global alias.st status<br>git config --global alias.co checkout<br>git config --global alias.br branch<br><span class="hljs-comment"># 简短的查看日志</span><br>git config --global alias.slog <span class="hljs-string">&#x27;log --pretty=format:&quot;%h %aN %ad %s&quot; --date=format:&quot;%Y-%m-%d %H:%M:%S&quot;&#x27;</span><br><span class="hljs-comment"># 彩色查看log</span><br>git config --global alias.clog <span class="hljs-string">&#x27;log --pretty=format:&quot;%Cred%h%Creset %Cgreen%cr%Creset %s %Cblue%aN%Creset&quot;&#x27;</span><br><span class="hljs-comment"># 图形化log</span><br>git config --global alias.cglog <span class="hljs-string">&#x27;log --graph --pretty=format:&quot;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset%n&quot; --abbrev-commit --date=relative --branches&#x27;</span><br><br>alias.calog=<span class="hljs-built_in">log</span> --graph --pretty=format:<span class="hljs-string">&quot;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset%n&quot;</span> --abbrev-commit --<span class="hljs-built_in">date</span>=relative --branches<br><span class="hljs-comment"># 清理，但是保留一些文件</span><br>mclean = clean -xfd -e .cache -e .clang-format -e .vscode -e compile_commands.json<br></code></pre></td></tr></table></figure><p>（7）配置提交注释模版</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">vi ~<span class="hljs-string">/.gitCommitTemplate</span><br>git config <span class="hljs-params">--global</span> commit.template ~<span class="hljs-string">/.gitCommitTemplate</span><br></code></pre></td></tr></table></figure><p>（8）查看现有配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --list<br><span class="hljs-comment"># 同时显示来源</span><br>git config --list --show-origin<br></code></pre></td></tr></table></figure><h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><p>创建<code>.gitignore</code>文件即可，忽略遵从如下规则</p><ul><li><code>#</code>开头的行表示注释</li><li>可以使用标准的 glob 模式匹配，它会<strong>递归</strong>地应用在整个工作区中</li><li>匹配模式可以以（&#x2F;）开头防止递归</li><li>匹配模式可以以（&#x2F;）结尾指定目录</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 忽略所有的 .a 文件</span><br>*<span class="hljs-string">.a</span><br><br><span class="hljs-comment"># 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件</span><br>!lib.a<br><br><span class="hljs-comment"># 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO</span><br><span class="hljs-string">/TODO</span><br><br><span class="hljs-comment"># 忽略任何目录下名为 build 的文件夹</span><br>build/<br><br><span class="hljs-comment"># 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt</span><br>doc/*<span class="hljs-string">.txt</span><br><br><span class="hljs-comment"># 忽略 doc/ 目录及其所有子目录下的 .pdf 文件</span><br>doc/**/*<span class="hljs-string">.pdf</span><br></code></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="git中的重要概念"><a href="#git中的重要概念" class="headerlink" title="git中的重要概念"></a>git中的重要概念</h3><h4 id="工作区、暂存区、仓库"><a href="#工作区、暂存区、仓库" class="headerlink" title="工作区、暂存区、仓库"></a>工作区、暂存区、仓库</h4><p>这是经常用到的概念，关系图如下：</p><pre><code class=" mermaid">sequenceDiagramparticipant ws as 工作区participant staged as 暂存区(staged)&lt;br/&gt;git里叫indexparticipant .git as .git目录(仓库)participant remote as 远程仓库ws -&gt;&gt; staged: git addstaged-&gt;&gt;ws: git reset &lt;file&gt;staged-&gt;&gt;.git: git commit.git-&gt;&gt;ws: git checkout.git-&gt;&gt;remote: git pushremote-&gt;&gt;.git: git fetchremote-&gt;&gt;ws: git pull</code></pre><h3 id="查看修改diff"><a href="#查看修改diff" class="headerlink" title="查看修改diff"></a>查看修改diff</h3><ul><li><p>查看当前工作区的修改(修改后还未暂存)<br><code>git diff </code></p></li><li><p>查看暂存区中的修改(已暂存，下一次commit的修改)<br><code>git diff --staged</code></p></li><li><p>查看某几个版本间修改文件列表<br><code>git diff --stat 38bb22e88660..HEAD -- . :^userspace/public/apps/lighttpd/web</code><br><code>:^</code>表示排除这个目录</p></li></ul><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看远程仓库</span><br>git remote -v<br><span class="hljs-comment"># 添加远程仓库</span><br>git remote add shortName https://github.com/paulboone/ticgit<br><span class="hljs-comment"># 从远程仓库拉取(原厂仓库的所有内容会获取下来)</span><br>git fetch<br><span class="hljs-comment"># 将提交推送到远程仓库</span><br>git push origin master<br></code></pre></td></tr></table></figure><h3 id="日志查看"><a href="#日志查看" class="headerlink" title="日志查看"></a>日志查看</h3><p><code>-p</code> 显示修改内容</p><p><code>-2</code> 显示最近两次修改</p><p><code>git log -p -2</code></p><p><code>git log --stat</code> 查看提交修改的文件统计</p><p><code>git log --since=&quot;2023-06-16 00:00:00&quot;</code> 查看从某天起迄今的日志。</p><p><strong>查看某个函数的修改记录</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">git log -L <span class="hljs-symbol">:FunctionName</span><span class="hljs-symbol">:FilePath</span><br>git log -L <span class="hljs-symbol">:lan_connect</span><span class="hljs-symbol">:users/tianyi/tylib/ty_common/system/set_bridge</span>.c<br></code></pre></td></tr></table></figure><p><strong>查看某行的修改记录</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> blame -L <span class="hljs-number">58</span>,<span class="hljs-number">100</span> file_name # <span class="hljs-number">58</span>~<span class="hljs-number">100</span> 行代码<br></code></pre></td></tr></table></figure><h4 id="双点和三点"><a href="#双点和三点" class="headerlink" title="双点和三点"></a>双点和三点</h4><p>分支多了，merge，cherry-pick混合使用，有时不清楚一个分支上究竟有哪些提交是独有的，可以通过如下命令来办。</p><p><strong>双点</strong></p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss">git <span class="hljs-built_in">log</span> foo..<span class="hljs-built_in">bar</span><br>等价于： git <span class="hljs-built_in">log</span> ^foo <span class="hljs-built_in">bar</span>, 包含<span class="hljs-built_in">bar</span>不包含foo的部分，即<span class="hljs-built_in">bar</span>特有的<br></code></pre></td></tr></table></figure><p><strong>三点</strong></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">git</span></span> <span class="hljs-built_in">log</span> foo...bar<br>等价于：包含 foo bar，但不包含二者公共部分<br></code></pre></td></tr></table></figure><p>可以通过下图看懂命令的不同</p><p><img src="https://pic-0625.obs.cn-south-1.myhuaweicloud.com/2023-12/20-155858-1f30-leon.png?x-image-process=image/quality,q_65"></p><h4 id="忽略cherry-pick，merge的提交"><a href="#忽略cherry-pick，merge的提交" class="headerlink" title="忽略cherry-pick，merge的提交"></a>忽略cherry-pick，merge的提交</h4><p>每次merge和cherry-pick都会产生新的提交，默认在使用双点，3点命令时，这些提交也会显示出来。但实际上并不希望看到这些。可通过如下参数控制。（实测双点没有效果，3点效果较好）<br><code>git log foo...bar</code>，只是打印二者所有的不同提交，看不出来谁是谁的，使用<code>--left-right</code>可以看出来哪边是哪边的</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs node-repl">git log --left-right master...experiment<br>&lt; F <br>&lt; E<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">D</span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">C</span><br></code></pre></td></tr></table></figure><p><code>--no-merges</code>将不显示merge的提交<br><code>--cherry-pick</code>将会把cherry-pick的视为相同的提交<br><code>--left-only</code> <code>--right-only</code>将只显示一边的提交<br><code>--cherry-mark</code>将相同的提交用”&#x3D;”号表示，不同的用”+”号标记</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 显示foo特有的</span><br>git log <span class="hljs-params">--cherry-pick</span> <span class="hljs-params">--left-only</span> <span class="hljs-params">--no-merges</span>  foo.<span class="hljs-string">..bar</span> <br><span class="hljs-comment"># 显示bar特有的</span><br>git log <span class="hljs-params">--cherry-pick</span> <span class="hljs-params">--right-only</span> <span class="hljs-params">--no-merges</span>  foo.<span class="hljs-string">..bar</span> <br></code></pre></td></tr></table></figure><h4 id="cherry-pick大量代码"><a href="#cherry-pick大量代码" class="headerlink" title="cherry-pick大量代码"></a>cherry-pick大量代码</h4><p>master分支上，哪些需要合并到ctc分支</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 检查从2025-3-1日起，哪些带通用的提交，可能需要合并到ctc上</span><br>git <span class="hljs-built_in">log</span> --cherry-pick --left-only --no-merges --grep <span class="hljs-string">&quot;通用&quot;</span> --since <span class="hljs-string">&quot;2025-03-01&quot;</span>  --pretty=format:<span class="hljs-string">&quot;%ad %h %s (%an)&quot;</span> --<span class="hljs-built_in">date</span>=format:<span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>  master...ctc <br></code></pre></td></tr></table></figure><p>终端还是不方便，借助gitk来使用</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">gitk --cherry-pick --left-only --no-merges  --since=<span class="hljs-string">&quot;2025-3-1&quot;</span> master...ctc<br></code></pre></td></tr></table></figure><p>gitk界面搜索”通用”来过滤，右键cherry-pick</p><h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><p>(1) 修改刚提交的日志信息</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">git</span> <span class="hljs-string">commit</span> <span class="hljs-built_in">--amend</span> -<span class="hljs-string">m</span> <span class="hljs-string">&quot;刚修改错了&quot;</span><br></code></pre></td></tr></table></figure><p>(2) 提交时漏了文件</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">add</span> forget_file<br>git <span class="hljs-keyword">commit</span> <span class="hljs-comment">--amend -m &quot;漏了文件，重新提交&quot;</span><br></code></pre></td></tr></table></figure><p>(3) 撤销暂存区的文件（不会修改文件，只是取消文件暂存）</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">git <span class="hljs-keyword">reset</span> HEAD xxx.<span class="hljs-keyword">file</span><br></code></pre></td></tr></table></figure><p>(4) 撤销对文件的修改，会拷贝最新版本的文件覆盖当前文件</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">git checkout <span class="hljs-comment">-- xxx.file</span><br></code></pre></td></tr></table></figure><p>(5) git commit之后撤销，只撤销commit，代码修改仍在</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--soft HEAD^</span><br></code></pre></td></tr></table></figure><p><code>--soft</code> 不删除工作空间改动代码</p><p><code>--hard</code> 删除工作空间改动</p><p><code>HEAD^</code> 上一个版本，也可以写成<code>HEAD~1</code></p><p>(6) 撤销中间某次commit</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">git <span class="hljs-built_in">revert</span> commit_id<br></code></pre></td></tr></table></figure><p>执行之后会自动提交。</p><h3 id="status"><a href="#status" class="headerlink" title="status"></a>status</h3><p>（1）git status不显示Untracked的文件</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git status -uno</span><br></code></pre></td></tr></table></figure><p>（2）取消某个文件的跟踪</p><p>如下命令会删除对这个文件的跟踪，即从版本库中删除，但本地还存在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">rm</span> --cached -r <span class="hljs-built_in">dir</span><br>git commit -m <span class="hljs-string">&quot;untrack some dir&quot;</span><br></code></pre></td></tr></table></figure><p><a href="evernote:///view/11143895/s57/cf393bae-cbbf-4e33-90e5-b251cf729bbe/cf393bae-cbbf-4e33-90e5-b251cf729bbe/">git忽略已经被提交的文件 - SegmentFault 思否</a></p><p>（3）对于已经跟踪的文件，使用.gitignore文件无效，可以使用</p><p>这个命令只对本地生效，只是设置了文件未修改的标记。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">update</span>-<span class="hljs-keyword">index</span> <span class="hljs-comment">--assume-unchanged file命令</span><br></code></pre></td></tr></table></figure><p>显示哪些文件做了标记</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">git <span class="hljs-keyword">ls</span>-<span class="hljs-keyword">files</span> -v | <span class="hljs-keyword">grep</span> <span class="hljs-string">&#x27;^[[:lower:]]&#x27;</span><br>git <span class="hljs-keyword">ls</span>-<span class="hljs-keyword">files</span> -v | <span class="hljs-keyword">grep</span> <span class="hljs-string">&#x27;^h&#x27;</span><br></code></pre></td></tr></table></figure><p>撤销对这些文件的忽略</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">git <span class="hljs-keyword">update</span>-<span class="hljs-built_in">index</span> --<span class="hljs-keyword">no</span>-assume-unchanged <span class="hljs-keyword">file</span><br></code></pre></td></tr></table></figure><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 新建分支</span><br>git branch iss90<br><span class="hljs-comment"># 切换到分支</span><br>git checkout iss90<br><span class="hljs-comment"># 两个命令可以合并</span><br>git checkout -b iss90<br><br><span class="hljs-comment"># 查看分支</span><br>git branch<br><span class="hljs-comment"># 查看已合并过的分支</span><br>git branch --merged<br><br><span class="hljs-comment"># 合并分支到主线,先切换到master分支，然后合并</span><br>git checkout master<br>git merge iss90<br><br><span class="hljs-comment"># 删除分支</span><br>git branch -d iss90<br></code></pre></td></tr></table></figure><h3 id="查看未合并的分支"><a href="#查看未合并的分支" class="headerlink" title="查看未合并的分支"></a>查看未合并的分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看已合并的分支</span><br>git br --merged<br><span class="hljs-comment"># 查看未合并的分支</span><br>git br --no-merged<br><br><span class="hljs-comment"># 查看分支ft上有哪些提交没有合并到master分支上</span><br>git <span class="hljs-built_in">log</span> master..ft<br><br><span class="hljs-comment"># 忽略merge的提交，因为merge是一条单独的提交</span><br>git <span class="hljs-built_in">log</span> master..ft --no-merges<br></code></pre></td></tr></table></figure><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><h4 id="合并单条提交"><a href="#合并单条提交" class="headerlink" title="合并单条提交"></a>合并单条提交</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> cherry-pick <span class="hljs-number">62</span>ecb3<br></code></pre></td></tr></table></figure><h3 id="变基rebase"><a href="#变基rebase" class="headerlink" title="变基rebase"></a>变基rebase</h3><p>变基：修改当前分支的基底。</p><p>如果可以直接快进合并，那么不需要变基。此时变基会提示：<br><code>Current branch mesh_bug is up to date.</code></p><p>如果两边分支都有提交，那么可以变基，如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将experiment分支上的修改变基到master分支上</span><br>$ git checkout experiment<br>$ git rebase master<br>First, rewinding <span class="hljs-built_in">head</span> to replay your work on top of it...<br>Applying: added staged <span class="hljs-built_in">command</span><br><span class="hljs-comment"># 然后进行一次快进合并</span><br>$ git checkout master<br>$ git merge experiment<br></code></pre></td></tr></table></figure><p>如果要线性修改提交记录，那么可以一直使用rebase，pull代码时也是用rebase:  <code>git pull -r</code></p><h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">git remote show <span class="hljs-tag">&lt;<span class="hljs-name">remote</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="贮藏-stash"><a href="#贮藏-stash" class="headerlink" title="贮藏 stash"></a>贮藏 stash</h2><p>有时需要切换分支，但本地工作区已经很乱了，改了很多东西。想临时储存一下当前混乱的工作区。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 贮藏当前修改（只会贮藏已修改和已暂存的，未跟踪的不会贮藏）</span><br>git stash push<br><span class="hljs-comment"># 贮藏所有内容（未跟踪的也会贮藏，.gitignore忽略的文件也会贮藏，贮藏之后工作区完全干干净净）</span><br>git stash push -a -m <span class="hljs-string">&quot;msg&quot;</span><br><br><span class="hljs-comment"># 查看贮藏列表</span><br>git stash list<br><br><span class="hljs-comment"># 恢复上一次贮藏</span><br>git stash apply<br><span class="hljs-comment"># 贮藏很多次后，恢复指定贮藏</span><br>git stash apply stash@&#123;1&#125;<br><br><span class="hljs-comment"># 丢弃贮藏</span><br>git stash drop stash@&#123;1&#125;<br><br><span class="hljs-comment"># 恢复上一次贮藏并丢弃它</span><br>git stash pop<br><br><span class="hljs-comment"># 查看贮藏区的修改</span><br>git stash show stash@&#123;0&#125;<br><span class="hljs-comment"># 查看修改内容</span><br>git stash show -p stash@&#123;0&#125;<br></code></pre></td></tr></table></figure><h2 id="交互式暂存"><a href="#交互式暂存" class="headerlink" title="交互式暂存"></a>交互式暂存</h2><p>有时我们修改了一个文件的两个地方，但是想分开提交，一次只提交文件中某几处差异。这时就可以使用交互式暂存。<code>git add -i</code></p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add -i</span><br>           staged     unstaged path<br>  1:    unchanged        +0/-1 TODO<br>  2:    unchanged        +1/-1 index.html<br>  3:    unchanged        +5/-1 lib/simplegit.rb<br><br>*** Commands ***<br>  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked<br>  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp<br>What now&gt;<br></code></pre></td></tr></table></figure><p>s查看状态，p就是我们需要的命令。<br><code>p</code>后，会让你选择要操作那个文件，选择文件后，<strong>什么也不输入回车</strong>，进入下一个选择页面，这个页面会一次次的出现差异，让你选择是否暂存，输入y或者n即可。</p><h2 id="三棵树"><a href="#三棵树" class="headerlink" title="三棵树"></a>三棵树</h2><p>HEAD: 上一次提交的快照，下一次提交的父节点，相当于该分支的最后一次提交。</p><p>Index：预期的下一次提交的快照，就是暂存区</p><p>work目录：就是自己的工作区。前两个都是抽象的.git目录下的一些东西。</p><p>每一次git操作，都会有一个快照产生，三棵树都指向各自的快照。</p><p>当work和index快照指向不同，那么git status就会显示“文件已修改，但未暂存”</p><p>当index和HEAD指向不同，那么git status就会显示“文件已暂存”</p><p>当三棵树的指向全部相同，那么git status就是干净的。</p><h2 id="reset命令"><a href="#reset命令" class="headerlink" title="reset命令"></a>reset命令</h2><p>对三棵树的操作根据选项不同，区别如下(默认是mixed选项)</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-comment">--mixed               reset HEAD and index</span><br><span class="hljs-comment">--soft                reset only HEAD</span><br><span class="hljs-comment">--hard                reset HEAD, index and working tree</span><br></code></pre></td></tr></table></figure><p><strong>–soft</strong></p><p>只是修改HEAD指向，相当于撤回了commit动作。所有修改的文件都是已暂存状态。</p><p>所以可以用–soft合并之前的多个提交（压缩提交，有时在一个bug分支上修改bug，修改完后又发现引入新问题，还要修改，提交了几次，最后验收通过，为了让分支上的日志就更容易看出来具体修改，而不是几次不完善的修改，可以压缩提交）。</p><p><strong>–mixed</strong></p><p>修改HEAD和index指向，相当于撤回了commit和add动作。所有撤回的修改都存在工作区中。</p><p><strong>–hard</strong></p><p>三棵树同时修改，相当于撤回了commit,add,和本地修改。（因为之前的已经提交了，还可以通过reflog救回来）</p><p><strong>git reset [版本aa] 路径</strong></p><p>git reset 跟路径的情况下，会把index更改为reset的版本状态，把work中的文件改为HEAD中的状态（即修改撤回到work了）。如果此时直接commit，那么commit后仓库中的文件跟版本aa是一样。</p><p><strong>例子</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 回退到当前版本</span><br>git reset HEAD <br><span class="hljs-comment"># 回退到上一个版本</span><br>git reset HEAD~ <br><span class="hljs-comment"># 回退到指定版本</span><br>git reset 3f51 <br><br><span class="hljs-comment"># 撤销暂存区的文件（不会修改文件，只是取消文件暂存）</span><br>git reset HEAD xxx.file<br><br><span class="hljs-comment"># git commit之后撤销，只撤销commit，代码修改仍在</span><br>git reset --soft HEAD^<br></code></pre></td></tr></table></figure><h2 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h2><h3 id="查看tag"><a href="#查看tag" class="headerlink" title="查看tag"></a>查看tag</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git tag<br><span class="hljs-comment"># 模糊匹配</span><br>git tag -l <span class="hljs-string">&quot;v1.8.5*&quot;</span><br></code></pre></td></tr></table></figure><h3 id="添加tag"><a href="#添加tag" class="headerlink" title="添加tag"></a>添加tag</h3><p><strong>添加有注释的tag</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> tag -a v1.<span class="hljs-number">4</span>.<span class="hljs-number">1</span> -m <span class="hljs-string">&quot;my version 1.4&quot;</span><span class="hljs-meta"> [shaid]</span><br></code></pre></td></tr></table></figure><p>如果不使用-m参数，会打开编辑器，让你输入信息。查看tag的提交信息可以使用</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> show v1.<span class="hljs-number">4</span>.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>添加轻量级tag</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> tag v1.<span class="hljs-number">4</span>.<span class="hljs-number">1</span><span class="hljs-meta"> [shaid]</span><br></code></pre></td></tr></table></figure><h3 id="推送tag"><a href="#推送tag" class="headerlink" title="推送tag"></a>推送tag</h3><p>tag默认不会推送到远程服务器。需要自己推送。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> push origin v1.<span class="hljs-number">4</span>.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>如果要推送所有tag，可以使用如下命令，会推送所有本地的tag到远端服务器。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> --tags<br></code></pre></td></tr></table></figure><p>gerrit推送tag也是上面这种命令，没有特殊的地方。</p><h3 id="删除tag"><a href="#删除tag" class="headerlink" title="删除tag"></a>删除tag</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git tag -d v.1.4.1<br><span class="hljs-comment"># 删除远程标签</span><br>git push origin --delete &lt;tagname&gt;<br></code></pre></td></tr></table></figure><h2 id="git-svn"><a href="#git-svn" class="headerlink" title="git-svn"></a>git-svn</h2><blockquote><p>使用git本地管理，修改推送到svn</p></blockquote><p><strong>注意：</strong></p><p>git-svn并不能使用完整的git功能，为了避免遇到麻烦，保持线性提交，不能有merge产生的提交。把master分支外的修改全部变基到master分支。</p><p>（1）clone分支，-T表示trunk目录的名字，-b表示分支的名字，这样才会把分支这些一起clone下来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git svn <span class="hljs-built_in">clone</span> file:///tmp/test-svn -T trunk -b branches -t tags<br><br><span class="hljs-comment"># 不clone所有版本，有的svn仓库提交非常多，使用-r只clone部分提交下来</span><br>git svn <span class="hljs-built_in">clone</span> http://192.168.21.225/svn/rtl-ax1800-umc/trunk rtl-ax1800-umc-git-code -r 1400:HEAD<br></code></pre></td></tr></table></figure><p>svn上分支管理有可能比较乱，没有统一命名和目录管理，所以可以不用弄这些，直接clone一个分支</p><p>（2）日常修改，然后把修改推送到svn</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add<br>git commit<br><span class="hljs-comment"># stash一下，保持本地干净，不然svn dcommit不上去</span><br>git stash push<br><span class="hljs-comment"># 默认dcommit后会拉取远程修改合并到本地</span><br>git svn dcommit<br><span class="hljs-comment"># 贮藏的修改再拉下来</span><br>git stash pop<br></code></pre></td></tr></table></figure><p>（3）如果本地在git分支上修改，需要先变基到跟踪的分支，再dcommit</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git rebase master<br>git checkout master<br>git svn dcommit<br></code></pre></td></tr></table></figure><p>（4）拉取远程修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git svn fetch<br>git rebase<br><span class="hljs-comment"># 以上两个命令也可以合成以下一个命令</span><br>git svn rebase<br></code></pre></td></tr></table></figure><p>（5）其他svn操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git svn <span class="hljs-built_in">log</span><br>git svn info<br></code></pre></td></tr></table></figure><p>（6）添加svn分支（针对不规则命名情况）<br>参考 <a href="https://www.cnblogs.com/h2zZhou/p/6136948.html">git-svn：通过git来管理svn代码</a><br>通过如下命令来添加分支<br><code>git config --add svn-remote.&lt;远程分支名称&gt;.url &lt;svn地址，要包含具体分支路径&gt;</code><br><code>git config --add svn-remote.&lt;远程分支名称&gt;.fetch :refs/remotes/&lt;远程分支名称&gt;</code><br>实例如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby">git config --add svn-remote.svn/<span class="hljs-variable constant_">AX5410</span>.url <span class="hljs-symbol">http:</span>/<span class="hljs-regexp">/172.20.1.217/svn</span><span class="hljs-regexp">/bcm-ax3000-ctcc/branches</span><span class="hljs-regexp">/products/</span><span class="hljs-variable constant_">FY</span>-<span class="hljs-variable constant_">AX5410</span><br>git config --add svn-remote.svn/<span class="hljs-variable constant_">AX5410</span>.fetch <span class="hljs-symbol">:refs/remotes/svn/AX5410</span><br></code></pre></td></tr></table></figure><p>然后下载分支代码</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">git svn fetch <span class="hljs-variable">&lt;远程分支名称&gt;</span>   <span class="hljs-comment">#如 git svn fetch svn/AX5410</span><br></code></pre></td></tr></table></figure><p>（7）如何同时在两个svn分支上开发</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 基于远程分支创建本地分支</span><br>git br feiyi_ui remotes/origin/feiyi_ui <br>git co feiyi_ui<br></code></pre></td></tr></table></figure><p>注意：<code>git br -vv</code>并不能看到当前分支的跟踪分支是哪个svn分支，这和git远程分支不太一样。当git svn dcommit时，它会自动去找这个本地分支是从哪个svn分支来的，自动提交到对应的svn分支。</p><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>当dcommit有冲突时，需要<code>git svn rebase</code>拉取远程修改合入本地，解决冲突后再dcommit</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># dcommit发现冲突</span><br>git svn dcommit<br><span class="hljs-comment"># 拉取svn新代码合入本地，会有冲突的文件</span><br>git svn rebase<br><span class="hljs-comment"># 查看那些文件冲突</span><br>git st<br><span class="hljs-comment"># 修改文件，解决冲突</span><br>vi xxx<br><span class="hljs-comment"># 标记冲突已解决</span><br>git add xxx<br><span class="hljs-comment"># 继续变基</span><br>git rebase --<span class="hljs-built_in">continue</span><br><span class="hljs-comment"># 提交代码</span><br>git svn dcommit<br></code></pre></td></tr></table></figure><h3 id="空目录问题"><a href="#空目录问题" class="headerlink" title="空目录问题"></a>空目录问题</h3><p>git不支持空目录权限管理，无法git add空目录，所以如果svn服务器上有空目录。使用会有一些注意点：<br>（1）git svn clone的最后一步，git会主动建立空目录，保持代码一致<br>（2）<strong>如果rm所有代码，然后git reset –hard，这时空目录会丢失</strong>。<br>（3）<strong>如果git stash -a暂存所有文件，空目录也会丢失。</strong><br>（4）<strong>恢复办法为：git svn rebase</strong>，这时空目录会重新创建。</p><p><strong>解决办法</strong><br>（1）先通过svn下载代码，然后查找空文件夹 <code>find -type d -empty</code><br>（2）在空文件夹下建一个.gitkeep（约定俗成），并提交这个空目录（视情况）</p><p><strong>删除空目录问题</strong><br>git 删除空目录传了之后，git svn dcommit并没有删除空目录。</p><h3 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h3><p>2个固定分支<br>master主分支：不做任何修改，用于merge要提交的代码，从原厂仓库拉最新代码<br>工作空间分支：提交本地化的管理型代码（gitignore,.vscode,.gitkeep），同步最新的master分支</p><p>其他特性分支：从工作空间创建，修改bug，特性开发的分支。修改完后，将修改点rebase或者merge到master。从master提交代码，</p><p>（1）git svn clone代码<br>（2）创建工作空间分支，编译<br>（3）在工作空间分支创建特性分支<br>（4）将特性分支的修改merge到master<br>（5）在master上提交，拉取远程仓库代码<br>（6）把master分支合并到特性分支</p><h3 id="修改url"><a href="#修改url" class="headerlink" title="修改url"></a>修改url</h3><p>(1)  <code>vi .git/config </code>修改url为新的url<br>(2) <code>git svn fetch</code><br>(3) <code>vi .git/config</code> 修改url为老的url<br>(4) <code>git svn rebase -l</code><br>(5)  <code>vi .git/config</code> 修改url为新的url<br>(6) <code>git svn rebase</code></p><h2 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h2><p>clean用于清理未暂存的文件，保持干净的工作区，可以代替make clean<br><code>git clean -xfd</code></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-f, --force           force</span><br><span class="hljs-deletion">-d                    remove whole directories</span><br><span class="hljs-deletion">-x                    remove ignored files, too 默认忽略的文件不会清理，-x会一并清理</span><br><span class="hljs-deletion">-e 排除某些文件</span><br></code></pre></td></tr></table></figure><p><strong>会删除空目录，记得git svn rebase</strong></p><h2 id="github"><a href="#github" class="headerlink" title="github"></a>github</h2><h3 id="如何在github上下载某个项目的单独某个目录？"><a href="#如何在github上下载某个项目的单独某个目录？" class="headerlink" title="如何在github上下载某个项目的单独某个目录？"></a>如何在github上下载某个项目的单独某个目录？</h3><p>使用svn来下载，例如我想下载我的practice项目的hash_table目录</p><p>（1）在github上点开这个目录，浏览器地址栏可以得到这个地址</p><p><a href="https://github.com/leon0625/practice/tree/master/hash_table">https://github.com/leon0625/practice</a><a href="https://github.com/leon0625/practice/tree/master/hash_table">&#x2F;tree&#x2F;master</a>&#x2F;hash_table</p><p>（2）将地址里的tree&#x2F;master换成trunk</p><p><a href="https://github.com/leon0625/practice/trunk/hash_table">https://github.com/leon0625/practice</a><a href="https://github.com/leon0625/practice/trunk/hash_table">&#x2F;trunk</a>&#x2F;hash_table</p><p>（3）使用svn下载上面的地址</p><p>svn co <a href="https://github.com/leon0625/practice/trunk/hash_table">https://github.com/leon0625/practice</a><a href="https://github.com/leon0625/practice/trunk/hash_table">&#x2F;trunk</a>&#x2F;hash_table</p><h1 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h1><h2 id="添加子模块"><a href="#添加子模块" class="headerlink" title="添加子模块"></a>添加子模块</h2><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs console">git submodule add https://github.com/chaconinc/DbConnector<br></code></pre></td></tr></table></figure><p>添加之后，查看状态会出现一个.gitmodules文件和一个目录，这两个文件都要提交</p><h2 id="克隆包含子模块的项目"><a href="#克隆包含子模块的项目" class="headerlink" title="克隆包含子模块的项目"></a>克隆包含子模块的项目</h2><p>直接clone之后，包含模块目录，但是不包含模块代码。有如下<strong>三种方式</strong>来clone完整代码<br>（1）分步执行</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs console"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://github.com/chaconinc/MainProject</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git submodule init</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git submodule update</span><br></code></pre></td></tr></table></figure><p>（2）clone添加参数<code>--recurse-submodules</code></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">clone</span> <span class="hljs-title">--recurse-submodules</span> https://github.com/chaconinc/MainProject<br></code></pre></td></tr></table></figure><p>（3）update添加init,recursive参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://github.com/chaconinc/MainProject</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git submodule update --init --recursive</span><br></code></pre></td></tr></table></figure><h2 id="更新子模块"><a href="#更新子模块" class="headerlink" title="更新子模块"></a>更新子模块</h2><p>当运行 <code>git submodule update --remote</code> 时，Git 默认会尝试更新 <strong>所有</strong> 子模块， 所以如果有很多子模块的话，你可以传递想要更新的子模块的名字。<br>更新之后，需要提交一下子模块目录，不然远程库上引用的子模块版本不会变</p><h2 id="在子模块上提交"><a href="#在子模块上提交" class="headerlink" title="在子模块上提交"></a>在子模块上提交</h2><p>进入子模块目录，直接操作就好。推到远程库之后，记得在主仓库里面更新一下子模块。然后提交引用。</p><h2 id="删除子模块"><a href="#删除子模块" class="headerlink" title="删除子模块"></a>删除子模块</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">submodule </span>deinit -f &lt;<span class="hljs-keyword">submodule_path&gt; </span> <br>git rm -f &lt;<span class="hljs-keyword">submodule_path&gt; </span> <br>git commit -m <span class="hljs-string">&quot;Remove submodule &lt;name&gt;&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>工具/git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>valgrind使用</title>
    <link href="/2020/08/21/25d4a948ddf5/"/>
    <url>/2020/08/21/25d4a948ddf5/</url>
    
    <content type="html"><![CDATA[<h1 id="valgrind使用"><a href="#valgrind使用" class="headerlink" title="valgrind使用"></a>valgrind使用</h1><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>如下是编译armv7的版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">./configure --prefix=`<span class="hljs-built_in">pwd</span>`/llm CC=/projects/hnd/tools/bcm/crosstools-arm-gcc-5.5-linux-4.1-glibc-2.26-binutils-2.28.1/usr/bin/arm-buildroot-linux-gnueabi-gcc --host=armv7-linux<br><span class="hljs-built_in">mkdir</span> llm<br>make -j6<br>make install<br></code></pre></td></tr></table></figure><h3 id="打包使用"><a href="#打包使用" class="headerlink" title="打包使用"></a>打包使用</h3><p>编译出来的install目录有100多M，全部拷到设备里面内存没那么大。所以只拷贝关键的<br>bin&#x2F;valgrind 文件<br>Libexec下所有文件，然后删掉里面最大的一些可执行文件（删掉不需要用的，检查内存泄漏的话，只保留memcheck-arm-linux这个可执行文件即可，其他的库文件，xml都要保留）</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><strong>注意需要设置环境变量</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /tmp<br><span class="hljs-built_in">mkdir</span> 123<br><span class="hljs-built_in">cd</span> 123<br>tftp -gr valgrind 192.168.10.123<br>tftp -gr test_arm 192.168.10.123<br>tftp -gr libexec.tar 192.168.10.123<br>tar -xf libexec.tar <br><span class="hljs-built_in">rm</span> libexec.tar<br><span class="hljs-comment"># 下面这个目录根据实际情况修改</span><br><span class="hljs-built_in">export</span> VALGRIND_LIB=/tmp/123/libexec/valgrind<br><span class="hljs-built_in">chmod</span> +x -R ./<br>./valgrind --leak-check=full ./test_arm<br></code></pre></td></tr></table></figure><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">fun1()<br>&#123;<br><span class="hljs-type">char</span> *p=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span>);<br><span class="hljs-built_in">memset</span>(p,<span class="hljs-number">0x2</span>,<span class="hljs-number">100</span>);<br>&#125;<br><br>fun2()<br>&#123;<br><span class="hljs-type">char</span> *p=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span>);<br><span class="hljs-built_in">memset</span>(p,<span class="hljs-number">0x2</span>,<span class="hljs-number">100</span>);<br><br>fun1();<br>&#125;<br><br>main()<br>&#123;<br>fun2();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>打印如下：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-number">1199</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span> Memcheck<span class="hljs-punctuation">,</span> a memory error detector<br><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-number">1199</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span> Copyright <span class="hljs-punctuation">(</span>C<span class="hljs-punctuation">)</span> <span class="hljs-number">2002</span><span class="hljs-punctuation">-</span><span class="hljs-number">2017</span><span class="hljs-punctuation">,</span> and GNU GPL&#x27;d, by Julian Seward et al.<br>==<span class="hljs-number">1199</span>== Using Valgrind-3.17.0 and LibVEX; rerun with -h for copyright info<br>==<span class="hljs-number">1199</span>== Command: ./test_arm<br>==<span class="hljs-number">1199</span>== <br>==<span class="hljs-number">1199</span>== <br>==<span class="hljs-number">1199</span>== HEAP SUMMARY:<br>==<span class="hljs-number">1199</span>==     in use at exit: 200 bytes in 2 blocks<br>==<span class="hljs-number">1199</span>==   total heap usage: 2 allocs, 0 frees, 200 bytes allocated<br>==<span class="hljs-number">1199</span>== <br>==<span class="hljs-number">1199</span>== 100 bytes in 1 blocks are definitely lost in loss record 1 of 2<br>==<span class="hljs-number">1199</span>==    at 0x<span class="hljs-number">484876</span>C: malloc (vg_replace_malloc.c:380)<br>==<span class="hljs-number">1199</span>==    by 0x<span class="hljs-number">1048</span>B: fun2 (test.c:9)<br>==<span class="hljs-number">1199</span>==    by 0x104C3: main (test.c:17)<br>==<span class="hljs-number">1199</span>== <br>==<span class="hljs-number">1199</span>== 100 bytes in 1 blocks are definitely lost in loss record 2 of 2<br>==<span class="hljs-number">1199</span>==    at 0x<span class="hljs-number">484876</span>C: malloc (vg_replace_malloc.c:380)<br>==<span class="hljs-number">1199</span>==    by 0x<span class="hljs-number">1044</span>F: fun1 (test.c:3)<br>==<span class="hljs-number">1199</span>==    by 0x104A7: fun2 (test.c:12)<br>==<span class="hljs-number">1199</span>==    by 0x104C3: main (test.c:17)<br>==<span class="hljs-number">1199</span>== <br>==<span class="hljs-number">1199</span>== LEAK SUMMARY:<br>==<span class="hljs-number">1199</span>==    definitely lost: 200 bytes in 2 blocks<br>==<span class="hljs-number">1199</span>==    indirectly lost: 0 bytes in 0 blocks<br>==<span class="hljs-number">1199</span>==      possibly lost: 0 bytes in 0 blocks<br>==<span class="hljs-number">1199</span>==    still reachable: 0 bytes in 0 blocks<br>==<span class="hljs-number">1199</span>==         suppressed: 0 bytes in 0 blocks<br>==<span class="hljs-number">1199</span>== <br>==<span class="hljs-number">1199</span>== For lists of detected and suppressed errors, rerun with: -s<br>==<span class="hljs-number">1199</span>== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)<br></code></pre></td></tr></table></figure><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>运行报错，错误如下：<br><code>valgrind setrlimit(RLIMIT_NOFILE) error: Operation not permitted</code><br>根据查资料来看貌似是valgrind的限制，如下<a href="https://stackoverflow.com/questions/52070477/setrlimit-fails-with-operation-not-permitted-when-run-under-valgrind">https://stackoverflow.com/questions/52070477/setrlimit-fails-with-operation-not-permitted-when-run-under-valgrind</a><br>不支持进程调用这个，需要在代码里面去掉这个setrlimit，我调试的进程是cm_init调用的。去掉相关代码即可。</p><h3 id="因strip运行报错"><a href="#因strip运行报错" class="headerlink" title="因strip运行报错"></a>因strip运行报错</h3><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">valgrind:</span>  Fatal <span class="hljs-keyword">error</span> at startup: a <span class="hljs-keyword">function</span> redirection<br><span class="hljs-symbol">valgrind:</span>  which <span class="hljs-built_in">is</span> mandatory <span class="hljs-keyword">for</span> this platform-tool combination<br><span class="hljs-symbol">valgrind:</span>  cannot be <span class="hljs-keyword">set</span> up.  Details <span class="hljs-keyword">of</span> the redirection are:<br><span class="hljs-symbol">valgrind:</span>  <br><span class="hljs-symbol">valgrind:</span>  A must-be-redirected <span class="hljs-keyword">function</span><br><span class="hljs-symbol">valgrind:</span>  whose name matches the pattern:      index<br><span class="hljs-symbol">valgrind:</span>  <span class="hljs-keyword">in</span> an <span class="hljs-type">object</span> <span class="hljs-keyword">with</span> soname matching:   ld-linux.so.<span class="hljs-number">3</span><br><span class="hljs-symbol">valgrind:</span>  was <span class="hljs-built_in">not</span> found whilst processing<br><span class="hljs-symbol">valgrind:</span>  symbols <span class="hljs-keyword">from</span> the <span class="hljs-type">object</span> <span class="hljs-keyword">with</span> soname: ld-linux.so.<span class="hljs-number">3</span><br><span class="hljs-symbol">valgrind:</span>  <br><span class="hljs-symbol">valgrind:</span>  Possible fixes: (<span class="hljs-number">1</span>, <span class="hljs-type">short</span> term): install glibc<span class="hljs-comment">&#x27;s debuginfo</span><br><span class="hljs-symbol">valgrind:</span>  package <span class="hljs-keyword">on</span> this machine.  (<span class="hljs-number">2</span>, longer term): ask the packagers<br><span class="hljs-symbol">valgrind:</span>  <span class="hljs-keyword">for</span> your Linux distribution <span class="hljs-keyword">to</span> please <span class="hljs-keyword">in</span> future ship a non-<br><span class="hljs-symbol">valgrind:</span>  stripped ld.so (<span class="hljs-built_in">or</span> whatever the dynamic linker .so <span class="hljs-built_in">is</span> called)<br><span class="hljs-symbol">valgrind:</span>  that exports the above-named <span class="hljs-keyword">function</span> <span class="hljs-keyword">using</span> the standard<br><span class="hljs-symbol">valgrind:</span>  calling conventions <span class="hljs-keyword">for</span> this platform.  The package you need<br><span class="hljs-symbol">valgrind:</span>  <span class="hljs-keyword">to</span> install <span class="hljs-keyword">for</span> fix (<span class="hljs-number">1</span>) <span class="hljs-built_in">is</span> called<br><span class="hljs-symbol">valgrind:</span>  <br><span class="hljs-symbol">valgrind:</span>    <span class="hljs-keyword">On</span> Debian, Ubuntu:                 libc6-dbg<br><span class="hljs-symbol">valgrind:</span>    <span class="hljs-keyword">On</span> SuSE, openSuSE, Fedora, RHEL:   glibc-debuginfo<br><span class="hljs-symbol">valgrind:</span>  <br><span class="hljs-symbol">valgrind:</span>  Note that <span class="hljs-keyword">if</span> you are debugging a <span class="hljs-number">32</span> bit process <span class="hljs-keyword">on</span> a<br><span class="hljs-symbol">valgrind:</span>  <span class="hljs-number">64</span> bit system, you will need a corresponding <span class="hljs-number">32</span> bit debuginfo<br><span class="hljs-symbol">valgrind:</span>  package (e.g. libc6-dbg:i386).<br></code></pre></td></tr></table></figure><p>这是由于ld-linux.so.3这个库被strip了，编译一个不strip的软件。<br>博通的改法是：<br>targets&#x2F;buildFS文件, 最后几行代码前添加如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># leon add, vagraind使用</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;##leon cp <span class="hljs-variable">$INSTALL_DIR</span>/lib/ld-linux.so.3 <span class="hljs-variable">$TARGETS_DIR</span>/<span class="hljs-variable">$ROOTFS</span>/lib/&quot;</span><br><span class="hljs-built_in">cp</span> <span class="hljs-variable">$INSTALL_DIR</span>/lib/ld-linux.so.3 <span class="hljs-variable">$TARGETS_DIR</span>/<span class="hljs-variable">$ROOTFS</span>/lib/<br></code></pre></td></tr></table></figure><h3 id="共享内存运行报错"><a href="#共享内存运行报错" class="headerlink" title="共享内存运行报错"></a>共享内存运行报错</h3><p>cms框架使用mdm的会共享内存，shmat报错如下</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros">[0216 19:19:32] ==<span class="hljs-attribute">15363</span>== Either way, Valgrind will now raise a SIGILL signal which will<br>[0216 19:19:32] ==<span class="hljs-attribute">15363</span>== probably kill your program.<br>[0216 19:19:33] ==<span class="hljs-attribute">15363</span>== Warning:<span class="hljs-built_in"> client </span>syscall shmat tried <span class="hljs-keyword">to</span> modify addresses 0x58800000-0x5890ffff<br>[0216 19:19:33] hgcmif::730.543<span class="hljs-keyword">:error</span>:oalShm_init:209:Could <span class="hljs-keyword">not</span> attach <span class="hljs-keyword">to</span> <span class="hljs-attribute">shmId</span>=0 at 0x58800000, <span class="hljs-attribute">error</span>=Invalid argument<br>[0216 19:19:33] <span class="hljs-built_in">Error</span> at:InitCms,77  cmsMdm_init ret[9002]<br>[0216 19:19:33] Start hgcmif ipc thread<br>[0216 19:19:35] ==<span class="hljs-attribute">15363</span>== Invalid read of size 4<br>[0216 19:19:35] ==<span class="hljs-attribute">15363</span>==    at 0x4D5832C: mdm_getObjectNodeFlags (<span class="hljs-keyword">in</span> /lib/libmdm_db.so)<br>[0216 19:19:35] ==<span class="hljs-attribute">15363</span>== <span class="hljs-built_in"> Address </span>0x0 is <span class="hljs-keyword">not</span> stack<span class="hljs-string">&#x27;d, malloc&#x27;</span>d <span class="hljs-keyword">or</span> (recently) free<span class="hljs-string">&#x27;d</span><br></code></pre></td></tr></table></figure><p>共享内存的地址是写死的，据说和valgrind的重叠了，所以不行。修改这个地址才行（改成0x58d00000就行）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MDM_SHM_ATTACH_ADDR  0x58d00000  <span class="hljs-comment">//0x58800000</span></span><br></code></pre></td></tr></table></figure><p>如果不是用的MDM_SHM_ATTACH_ADDR这个地址，同理也应当修改其他宏即可。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>只显示确认的泄漏 <code>--show-leak-kinds=definite</code>参数</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">./valgrind</span> <span class="hljs-params">--leak-check=full</span> <span class="hljs-params">--show-leak-kinds=definite</span> <span class="hljs-string">./test</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
